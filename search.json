[
  {
    "objectID": "examples/julia/lp/index.html",
    "href": "examples/julia/lp/index.html",
    "title": "TCA in Local Projections",
    "section": "",
    "text": "This part of the website is still under construction. Our apologies.",
    "crumbs": [
      "Home",
      "Julia",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html",
    "href": "examples/matlab/dynare/index.html",
    "title": "TCA in DSGEs using Dynare",
    "section": "",
    "text": "In this example, we replicate the results from Section 5.3 of Wegner et al. (2025). Before we begin, download both the code and the Dynare model. Make sure to unzip the Dynare model, and place both the sw2007.m script and the SW2007 folder into the same directory.\nTo ensure a clean environment, we recommend starting a new Matlab session. Alternatively, run the following lines to clear the workspace and console:",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#computing-the-linearised-dsge-using-dynare",
    "href": "examples/matlab/dynare/index.html#computing-the-linearised-dsge-using-dynare",
    "title": "TCA in DSGEs using Dynare",
    "section": "Computing the Linearised DSGE using Dynare",
    "text": "Computing the Linearised DSGE using Dynare\nSection 5.3 of Wegner et al. (2025) studies the wage channel of a contractionary monetary policy shock using the DSGE model of Smets and Wouters (2007). To analyse this channel, we first obtain the model’s first-order approximation using Dynare. Follow Dynare’s official installation instructions if necessary.\nTo use Dynare and the TCA Toolbox, we first add both to the Matlab path. You will likely need to adjust the file paths in the quotation marks:\naddpath(\"~/Documents/repos/tca-matlab-toolbox/\")\naddpath(\"~/Documents/repos/tca-matlab-toolbox/models/\")\naddpath(\"~/Documents/repos/tca-matlab-toolbox/plotting/\")\naddpath(\"/Applications/Dynare/6.3-arm64/matlab/\")\nAssuming the SW2007 folder is in the current directory, we can now generate the first-order approximation:\ncd SW2007;\ndynare SW2007;\ncd ..;\nclc;",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#tca-setup",
    "href": "examples/matlab/dynare/index.html#tca-setup",
    "title": "TCA in DSGEs using Dynare",
    "section": "TCA Setup",
    "text": "TCA Setup\nWith the TCA Toolbox added to the path, we can create a DSGE model from Dynare’s output structures:\nmodel = DSGE(M_, options_, oo_);\nTCA requires impulse response functions (IRFs) to decompose effects. We obtain them as follows, extracting the IRF array from the IRFContainer:\nmaxHorizon = 20;\nirfObj = model.IRF(maxHorizon);\nirfs = irfObj.getIrfArray();",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#defining-transmission-channels",
    "href": "examples/matlab/dynare/index.html#defining-transmission-channels",
    "title": "TCA in DSGEs using Dynare",
    "section": "Defining Transmission Channels",
    "text": "Defining Transmission Channels\nAt this stage, we have the DSGE’s first-order solution and the IRFs. We can now define the transmission channels of interest.\nFirst, define the transmission matrix. Following Wegner et al. (2025), we order variables so that interest rates (robs) come first, wages (dw) second, and inflation (pinfobs) last. The ordering of variables between wages and inflation does not matter1:\norder = {'robs', 'dw', 'labobs', 'dc', 'dinve', 'dy', 'pinfobs'};\nNext, we define the transmission channels. The demand channel is defined as the effect that does not pass through wages (dw) during any period from 0 to 20. We define this channel using the notThrough function:\nchannelDemand = model.notThrough('dw', 0:maxHorizon, order);\nThe wage channel, capturing any effect through wages in at least one period, is the complement:\nchannelWage = ~channelDemand;",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#computing-transmission-effects",
    "href": "examples/matlab/dynare/index.html#computing-transmission-effects",
    "title": "TCA in DSGEs using Dynare",
    "section": "Computing Transmission Effects",
    "text": "Computing Transmission Effects\nWe can now compute the transmission effects using the transmission method of the DSGE model. We specify the shock (em), the transmission channel, the transmission matrix, and the maximum horizon:\neffectDemand = model.transmission('em', channelDemand, order, maxHorizon);\neffectWage = model.transmission('em', channelWage, order, maxHorizon);\nThe output has the same structure as the original IRFs, with variables appearing in their original order and adjustments made for the defined shock size.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#visualising-transmission-effects",
    "href": "examples/matlab/dynare/index.html#visualising-transmission-effects",
    "title": "TCA in DSGEs using Dynare",
    "section": "Visualising Transmission Effects",
    "text": "Visualising Transmission Effects\nTo better understand the transmission effects, we plot their decomposition. We first name the channels:\nchannelNames = [\"Demand Channel\", \"Wage Channel\"];\nNext, identify the indices of the outcome variable (inflation) and the shock (monetary policy shock em):\nidxInflation = model.getVariableIdx('pinfobs');\nidxShock = model.getShockIdx('em');\nThen collect the transmission effects into a cell array:\ncellChannelEffects = {effectDemand, effectWage};\nFinally, create the decomposition plot:\nfig = plotDecomposition(idxInflation, irfs(:, idxShock, :), cellChannelEffects, channelNames);\nThe plot shows:\n\nTotal effect (black scatter-line)\nEffect through the demand channel (blue bars)\nEffect through the wage channel (red bars)\n\n\n\n\n\n\n\nFigure 1: Decomposition of the effect of a contractionary monetary policy shock on inflation into the effect through a demand and a wage channel.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#using-an-alternative-transmission-matrix",
    "href": "examples/matlab/dynare/index.html#using-an-alternative-transmission-matrix",
    "title": "TCA in DSGEs using Dynare",
    "section": "Using an Alternative Transmission Matrix",
    "text": "Using an Alternative Transmission Matrix\nWegner et al. (2025) also explore an alternative ordering, where wages are placed second to last. We define the new ordering as:\norder = {'robs', 'labobs', 'dc', 'dinve', 'dy', 'dw', 'pinfobs'};\nTransmission channels and effects are then redefined and recomputed:\n% Defining the channel again.\nchannelDemandAlt = model.notThrough('dw', 0:maxHorizon, order);\nchannelWageAlt = ~channelDemandAlt;\n% Computing the alternative effects\neffectDemandAlt = model.transmission('em', channelDemandAlt, order, maxHorizon);\neffectWageAlt = model.transmission('em', channelWageAlt, order, maxHorizon);\nThe decomposition plot for the alternative ordering can be created as follows:\nchannelNames = [\"Demand Channel\", \"Wage Channel\"];\nidxInflation = model.getVariableIdx(\"pinfobs\");\nidxShock = model.getShockIdx('em');\ncellChannelEffectsAlt = {effectDemandAlt, effectWageAlt};\nfig = plotDecomposition(idxInflation, irfs(:, idxShock, :), cellChannelEffectsAlt, channelNames);\nThe resulting plot mirrors the previous setup, with the only difference being the transmission matrix. The black scatter-line and the blue and red bars retain the same meaning as in the previous plot: the black scatter-line shows the total effect, the blue bars represent the demand channel, and the red bars represent the wage channel.\n\n\n\n\n\n\nFigure 2: Alternative decomposition of the effect of a contractionary monetary policy shock on inflation into the effect through a demand and a wage channel using the alternative transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#comparing-transmission-effects-of-different-transmission-matrices",
    "href": "examples/matlab/dynare/index.html#comparing-transmission-effects-of-different-transmission-matrices",
    "title": "TCA in DSGEs using Dynare",
    "section": "Comparing Transmission Effects of Different Transmission Matrices",
    "text": "Comparing Transmission Effects of Different Transmission Matrices\nWe can place Figure 1 and Figure 2 side-by-side for comparison. As shown in Figure 3, differences are minor:\n\n\n\n\n\n\n\n\nFirst-round\n\n\n\n\n\n\n\nSecond-round\n\n\n\n\n\n\nFigure 3: Comparing the decomposition of a contractionary monetary policy shock on inflation across the two transmission matrices.\n\n\n\nA more precise comparison uses the plotCompareDecompositions function. The following code generates Figure Figure 4:\nfig = plotCompareDecompositions(...\n    idxInflation, ...\n    irfs(:, idxShock, :), ...\n    cellChannelEffectsAlt, ...\n    cellChannelEffects, ...\n    channelNames, ...\n    [\"Ordering 2\", \"Ordering 1\"] ...\n);\nFigure Figure 4 shows small but detectable differences, as predicted by theory.\n\n\n\n\n\n\nFigure 4: Comparing the decompositions of a contractionary monetary policy shock on inflation across the two transmission matrices.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/dynare/index.html#footnotes",
    "href": "examples/matlab/dynare/index.html#footnotes",
    "title": "TCA in DSGEs using Dynare",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee Wegner et al. (2025) for the theoretical justification.↩︎",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in DSGEs"
    ]
  },
  {
    "objectID": "examples/matlab/svar/index.html",
    "href": "examples/matlab/svar/index.html",
    "title": "TCA in SVARs",
    "section": "",
    "text": "Section 5.1 of Wegner et al. (2025) splits the effects of monetary policy into contemporaneous and non-contemporanous effects, the latter of which are linked to forward guidance and other non-conventional policies. In this example, we do the same. Before we begin, download both the code and the replication data. Make sure to put the data and the code into the same folder.\nTo ensure a clean environment, we recommend starting a new Matlab session. Alternatively, run the following lines to clear the workspace and console:\nNext, add the TCA Toolbox to the Matlab path. You will likely have to adjust the file paths in the quotation marks:\nFinally, before coming to the analysis, load the replication data into a table:\nWegner et al. (2025) do the analysis for two internal instruments of monetary policy shocks: (1) the Gertler and Karadi (2015) instrument and (2) the Romer and Romer (2004) instrument. We split our analysis accordingly and start investigating the contemporanous and non-contemporaneous effects of monetary policy estimated using the Gertler and Karadi instrument.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in SVARs"
    ]
  },
  {
    "objectID": "examples/matlab/svar/index.html#gertler-karadi",
    "href": "examples/matlab/svar/index.html#gertler-karadi",
    "title": "TCA in SVARs",
    "section": "Gertler Karadi",
    "text": "Gertler Karadi\nGertler and Karadi (2015) derive an instrument for monetary policy shocks by extracting the surprise component of FOMC meetings from the change in Fed Funds Futures in a tight time window around these FOMC meetings. This instrument is contained in the data and named mp1_tc. Also contained in the data is the Romer and Romer (2004) instrument (rr_3) which we do not currently need.\nTo focus on the GK instrument, we filter the data for only the GK instrument, interest rates, output gap, commodity prices and inflation\nkeepCols = {'mp1_tc', 'ffr', 'ygap', 'infl', 'lpcom'};\ndataGK = data(:, keepCols);\nWith the data at hand, our transmission channel analysis follows the common six steps.\n\n1. Defining the model\nThe first step to any transmission channel analysis is to define the model. Here, we will go with a VAR model. We include the instrument in the VAR, thus effectively deciding that we identify the shock via an internal instrument.\nmodel = VAR(dataGK, 4, 'trendExponents', 0:1);\nmodel.fit();\n\n\n2. Obtaining IRFs\nNext, we obtain the total effects – the structural IRFs – by using the GK series as as internal instrument. We thus define our InternalInstrument identification method:\nmethod = InternalInstrument('ffr');\nStructural IRFs can then be obtained by using IRF and providing the identificationMethod.\nirfObj = model.IRF(40, 'identificationMethod', method);\nirfs = irfObj.getIrfArray();\nAlthough not strictly necessary, we normalise the shock’s size to 25bps. This can be achieved by mutiplying the structural IRFs, currently normalised to a 1pp increase, by 0.25.\nirfs = irfs(:, 1, :) * 0.25;\n\n\n3. Defining the transmission matrix\nThe third step to any transmission channel analysis is the definition of the transmission matrix. Wegner et al. (2025) order the Fed Funds rate first, followed by all other variables. The implementation of internal instruments is slightly different here, requiring us to order the internal instrument first, followed by the Fed Funds rate, and all other variables. The transmission matrix can then be defined in the following way:\ntransmissionOrder = {'mp1_tc', 'ffr', 'ygap', 'infl', 'lpcom'};\n\n\n\n\n\n\nTo be more general, the implementation of internal instruments, and specifically the computation of the Cholesky-orthogonalised IRFs needed for transmission channel analysis, is slightly different here than in Wegner et al. (2025). The final results will be qualitatively the same, although quantitatively slightly different.\n\n\n\n\n\n4. Defining transmission channels\nThe fourth step is to define the transmission channels. Wegner et al. (2025) focus on two channels that perfectly decompose the effect. They define the contemporanous channel of monetary policy as the effect of monetary policy going through a contemporanous adjustment in the federal funds rate. They then define the non-contemporaneous channel of monetary policy as the effect of monetary policy not going through a contemporanous adjustment in the federal funds rate – the complement of the contemporaneous channel. Note that according the Section 4.3 of Wegner et al. (2025) the effects through these channels are invariant to any re-ordering of inflation, commodity prices, and the output gap, as long as they are ordered after the Fed Funds rate.\nThe non-contemporanous channel can be defined in the following way:\nchannelNonContemp = model.notThrough('ffr', 0, transmissionOrder);\nThe contemporanous channel can be defined in a similar way:\nchannelContemp = model.through('ffr', 0', transmissionOrder);\n\n\n5. Computing transmission effects\nTransmission effects can now be computed using transmission. We must provide our InternalInstrument identificationMethod:\neffectsNonContemp = model.transmission(1, channelNonContemp, transmissionOrder, 40, 'identificationMethod', method);\neffectsContemp = model.transmission(1, channelContemp, transmissionOrder, 40, 'identificationMethod', method);\n% adjusting for shock size\neffectsNonContemp = effectsNonContemp * 0.25;\neffectsContemp = effectsContemp * 0.25;\nTo double check whether everything worked, we check whether the two channels perfectly decompose the total effect. Very minor differences might exist due to numerical rounding.\nmax(vec(irfs - effectsContemp - effectsNonContemp))\n\n\n6. Visualising decomposition\nLastly, we visualise the decomposition using plotDecomposition. We must first define the channel names:\nchannelNames = [\"Contemporaneous\", \"Non-Contemporaneous\"];\ncellChannelEffects = {effectsContemp, effectsNonContemp};\nThe decomposition for the effects of a monetary policy shock on the federal funds rate (the second variable in the data) can then be obtained in the following way:\nfig = plotDecomposition(2, irfs, cellChannelEffects, channelNames);\n\n\n\n\n\n\nFigure 1: Decomposition of the GK identified monetary policy shock on the federal funds rate.\n\n\n\nSimilarly, the decomposition for the effects of a monetary policy shock on inflation (the fourth variable in the data) can be obtained in the following way:\nfig = plotDecomposition(4, irfs, cellChannelEffects, channelNames);\n\n\n\n\n\n\nFigure 2: Decomposition of the GK identified monetary policy shock on inflation.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in SVARs"
    ]
  },
  {
    "objectID": "examples/matlab/svar/index.html#romer-and-romer",
    "href": "examples/matlab/svar/index.html#romer-and-romer",
    "title": "TCA in SVARs",
    "section": "Romer and Romer",
    "text": "Romer and Romer\nMost of the transmission channel analysis for the Romer and Romer (2004) instrument follows the same steps as for the Gertler and Karadi (2015) instrument. Below we highlight only the differences. For steps 2, 4, 5, 6, the same code as above can be used.\nBefore we start, we must first adjust the data and replace the GK with the RR instrument:\nkeepCols = {'rr_3', 'ffr', 'ygap', 'infl', 'lpcom'};\ndataRR = data(:, keepCols);\n\n1. Defining the model\nBecause the data has changed, our model definition changes slightly – the dataset name changes.\nmodel = VAR(dataRR, 4, 'trendExponents', 0:1);\nmodel.fit();\n\n\n3. Defining transmission matrix\nThe transmission matrix remains largely the same, but the name of the instrument changes.\ntransmissionOrder = {'rr_3', 'ffr', 'ygap', 'infl', 'lpcom'};\n\n\n6. Visualising effects\nWhile the code ramains the same, the graphs change.\n\n\n\n\n\n\nFigure 3: Decomposition of the RR identified monetary policy shock on the federal funds rate.\n\n\n\n\n\n\n\n\n\nFigure 4: Decomposition of the RR identified monetary policy shock on inflation.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMinor differences between the decompositions here and the ones in the paper are due to how we obtain the Cholesky-orthogonalised IRFs. In the paper we estimate orthogonal IRFs using a VAR excluding the internal instrument. Here we include the internal instrument.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in SVARs"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "faq/topics/systems-form.html",
    "href": "faq/topics/systems-form.html",
    "title": "What is the Systems Form?",
    "section": "",
    "text": "Fixing a finite horizon \\(h\\) and defining \\(\\mathbf{x}=(\\mathbf{y}_t^{*'}, \\dots, \\mathbf{y}_{t+h}^{*'})'\\) and \\(\\boldsymbol{\\varepsilon}=(\\boldsymbol{\\varepsilon}_t', \\dots, \\boldsymbol{\\varepsilon}_{t+h}')'\\), Wegner et al. (2025) show that the dynamic form can be written into the following systems form \\[\n\\mathbf{x}= \\mathbf{B}\\mathbf{x}+ \\boldsymbol{\\Omega}\\boldsymbol{\\varepsilon},\n\\] where \\(\\mathbf{B}\\) is lower-triangular with zeros on the diagonal, \\(\\boldsymbol{\\Omega}\\) is lower-block-triangular, and both are respectively given by1 \\[\n\\begin{array}{ccc}\n         \\mathbf{B}= \\begin{bmatrix}\n        \\mathbf{I}- \\mathbf{D}\\mathbf{L}& \\mathbf{O}& \\dots & \\mathbf{O}\\\\\n        \\mathbf{D}\\mathbf{Q}'\\mathbf{A}^*_1 & \\mathbf{I}-\\mathbf{D}\\mathbf{L}& \\dots & \\mathbf{O}\\\\\n        \\vdots & \\ddots & \\ddots & \\vdots \\\\\n        \\mathbf{D}\\mathbf{Q}'\\mathbf{A}^*_h & \\dots & \\mathbf{D}\\mathbf{Q}'\\mathbf{A}^*_1 & \\mathbf{I}- \\mathbf{D}\\mathbf{L}\n    \\end{bmatrix}, & \\quad &\n    \\boldsymbol{\\Omega}= \\begin{bmatrix}\n        \\mathbf{D}\\mathbf{Q}' & \\mathbf{O}& \\dots & \\mathbf{O}\\\\\n        \\mathbf{D}\\mathbf{Q}'\\boldsymbol{\\Psi}_1 & \\mathbf{D}\\mathbf{Q}' & \\dots & \\mathbf{O}\\\\\n        \\vdots & \\ddots & \\ddots & \\vdots \\\\\n        \\mathbf{D}\\mathbf{Q}'\\boldsymbol{\\Psi}_h & \\dots & \\mathbf{D}\\mathbf{Q}'\\boldsymbol{\\Psi}_1 & \\mathbf{D}\\mathbf{Q}'\n   \\end{bmatrix},\n\\end{array}\n\\]\nThis system form can either be used together with potential outcomes to define transmission channels, or can be used to build an associated graph in which transmission channels are much more intuitively defined.",
    "crumbs": [
      "Home",
      "Wiki",
      "What is the Systems Form?"
    ]
  },
  {
    "objectID": "faq/topics/systems-form.html#footnotes",
    "href": "faq/topics/systems-form.html#footnotes",
    "title": "What is the Systems Form?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor expositional ease we ommitted the dimension subscripts, letting \\(\\mathbf{I}= \\mathbf{I}_K\\) and \\(\\mathbf{O}= \\mathbf{O}_K\\)↩︎",
    "crumbs": [
      "Home",
      "Wiki",
      "What is the Systems Form?"
    ]
  },
  {
    "objectID": "faq/topics/graphical-form.html",
    "href": "faq/topics/graphical-form.html",
    "title": "What is the Associated Graph?",
    "section": "",
    "text": "While transmission channels could be defined using potential outcomes and the systems form, graphs are often much more intuitive. Wegner et al. (2025) therefore introduce the associated graph \\(\\mathcal{G}(\\mathbf{B}, \\boldsymbol{\\Omega})\\) to the systems form. As the notation hints at, the graph depends on the two matrices \\(\\mathbf{B}\\) and \\(\\boldsymbol{\\Omega}\\)1 which, in turn, depend on the dynamic form.\nThe associated graph \\(\\mathcal{G}(\\mathbf{B}, \\boldsymbol{\\Omega})\\) has three components:\nExample: VAR(1)\nSuppose the dynamic form corresponds to a Vector Autoregression of order 1 – a VAR(1). For \\(h=1\\), the associated graph then has the following form.\nExample: VARMA(1,1)\nNow suppose instead that the dynamic form corresponds to a VARMA(1, 1). For \\(h=1\\) the associated graph looks as follows. Note, compared to the VAR(1) graph, edges from shocks can skip time periods, which is indicated by the edges skipping one column of variable-nodes – each column corresponds to one time period.",
    "crumbs": [
      "Home",
      "Wiki",
      "What is the Associated Graph?"
    ]
  },
  {
    "objectID": "faq/topics/graphical-form.html#footnotes",
    "href": "faq/topics/graphical-form.html#footnotes",
    "title": "What is the Associated Graph?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nFor a refresher on these two matrices, check the systems form article or Section 3 of Wegner et al. (2025).↩︎",
    "crumbs": [
      "Home",
      "Wiki",
      "What is the Associated Graph?"
    ]
  },
  {
    "objectID": "faq/topics/dynamic-form.html",
    "href": "faq/topics/dynamic-form.html",
    "title": "What is the Dynamic Form?",
    "section": "",
    "text": "Wegner et al. (2025) refer to the following structural VARMA form as the dynamic form, \\[\n\\begin{equation}\n    \\mathbf{A}_0\\mathbf{y}_t = \\sum_{i=1}^{\\ell}\\mathbf{A}_i\\mathbf{y}_{t-i} + \\sum_{j=1}^{q}\\boldsymbol{\\Psi}_{j}\\boldsymbol{\\varepsilon}_{t-j} + \\boldsymbol{\\varepsilon}_t ,\n    \\label{eq:general-model}\n\\end{equation}\n\\] where \\(\\{\\mathbf{A}_i\\}_{i=1}^{\\ell}\\) and \\(\\{\\boldsymbol{\\Psi}_j\\}_{j=1}^{q}\\) are \\(K\\times K\\) coefficient matrices which are statistically identified using any common scheme such as the echelon form, \\(\\mathbf{A}_0\\) is a contemporaneous coefficient matrix assumed to be (partially) identified using some economic identification scheme, and \\(\\boldsymbol{\\varepsilon}_t\\) is a \\(K\\times 1\\) vector of white noise.\nAdditionally, two assumptions are made\n\n\n\n\n\n\nAssumption 1\n\n\n\nThe white noise vector \\(\\boldsymbol{\\varepsilon}_t\\) consists of \\(K\\) structural shocks satisfying \\(\\mathbb{E}[\\boldsymbol{\\varepsilon}_{t}]=\\mathbf{0}_K\\), \\(\\mathbb{E}[\\boldsymbol{\\varepsilon}_{t}\\boldsymbol{\\varepsilon}_{t}']=\\mathbf{I}_K\\) and \\(\\mathbb{E}[\\boldsymbol{\\varepsilon}_t\\boldsymbol{\\varepsilon}_{t-r}']=\\mathbf{O}_K\\) for all \\(r\\geq 1\\).\n\n\n\n\n\n\n\n\nAssumption 2\n\n\n\n\\(\\mathbf{A}_0\\) is non-singular.\n\n\nThe first step towards a definition of transmission channel is then the transformation of the dynamic form to the systems form.\n\n\n\n\n\n\nWhere can I find more information?\n\n\n\nMore information can be found in Section 3 of Wegner et al. (2025).\n\n\n\nRead the Paper\n\n\n\n\n\nReferences\n\nWegner, Enrico, Lenard Lieb, Stephan Smeekes, and Ines Wilms. 2025. “Transmission Channel Analysis in Dynamic Models.” 2025. https://doi.org/10.48550/arxiv.2405.18987.",
    "crumbs": [
      "Home",
      "Wiki",
      "What is the Dynamic Form?"
    ]
  },
  {
    "objectID": "faq/index.html",
    "href": "faq/index.html",
    "title": "Wiki",
    "section": "",
    "text": "What is Transmission Channel Analysis (TCA)?\n\n\nIn this article we describe (intuitively) what TCA is and what it does.\n\n\n\n\n\n\n\n\n\n\nHow can I implement TCA?\n\n\nIn this article we outline various ways to implement TCA, including software for Julia, Matlab, and Dynare.\n\n\n\n\n\n\n\n\n\n\nWhat is the Dynamic Form?\n\n\nTCA makes use of two forms (1) the dynamic form and (2) the systems form. In this article we describe what the dynamic form is.\n\n\n\n\n\n\n\n\n\n\nWhat is the Systems Form?\n\n\nTCA makes use of two forms (1) the dynamic form and (2) the systems form. In this article we describe what the systems form is.\n\n\n\n\n\n\n\n\n\n\nWhat is the Associated Graph?\n\n\nTransmission channels are best thought of as paths through the graph associted with the model. In this article we describe was the associated graph is.\n\n\n\n\n\n\n\n\n\n\nWhat are Boolean Conditions?\n\n\nTransmission conditions are most effectively stated using Boolean conditions about which variables should and should not lie on the transmission channels.\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "documentation/julia/all-functions/make_B.html",
    "href": "documentation/julia/all-functions/make_B.html",
    "title": "make_B",
    "section": "",
    "text": "make_B\n\n\n\n\n\nConstruct B of the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nNotes\n\nSee make_systems_form for further information.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_B"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/get_input_data.html",
    "href": "documentation/julia/all-functions/get_input_data.html",
    "title": "get_input_data",
    "section": "",
    "text": "get_input_data\n\n\n\n\n\nget_input_data(::Model)\nReturn the data used for the estimation.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "get_input_data"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/hqc.html",
    "href": "documentation/julia/all-functions/hqc.html",
    "title": "hqc",
    "section": "",
    "text": "hqc\n\n\n\n\n\naic(model::Union{VAR,SVAR}) -&gt; Real\naic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nbic(model::Union{VAR,SVAR}) -&gt; Real\nbic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nsic(model::Union{VAR,SVAR}) -&gt; Real\nsic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nhqc(model::Union{VAR,SVAR}) -&gt; Real\nhqc(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\nComputes information criteria for model selection in VARs.\nGiven a fitted VAR model or directly the covariance matrix Sigma_u, the number of estimated coefficients, and sample size T, each function returns the respective criterion value:\n\nAIC (Akaike Information Criterion):\n\n\\[\n\\text{AIC} = \\log\\det(\\Sigma_u) + \\frac{2k}{T}\n\\]\n\nSIC/BIC (Schwarz/Bayesian Information Criterion):\n\n\\[\n\\text{SIC} = \\log\\det(\\Sigma_u) + \\frac{\\log(T) k}{T}\n\\]\n\nHQC (Hannan-Quinn Criterion):\n\n\\[\n\\text{HQC} = \\log\\det(\\Sigma_u) + \\frac{2 \\log(\\log T) k}{T}\n\\]\nHere, \\(k\\) is the number of estimated parameters and \\(T\\) is the effective sample size.\n\nArguments\n\nmodel::VAR: A fitted VAR model\nSigma_u::Matrix{&lt;:Number}: Residual covariance matrix\nnum_coeffs::Int: Number of estimated coefficients\nT::Int: Number of observations used in estimation",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "hqc"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/AbstractIdentificationMethod.html",
    "href": "documentation/julia/all-functions/AbstractIdentificationMethod.html",
    "title": "AbstractIdentificationMethod",
    "section": "",
    "text": "AbstractIdentificationMethod\n\n\n\n\n\nAbstractIdentificationMethod\nAbstract supertype for all identification methods.\nNew identification methods must subtype AbstractIdentificationMethod. If the identification method can be used to estimate the structural model, i.e. identify the structural model’s coefficients, then functions fit! and fit_and_select! should be implemented. If the identification method can be used to identify structural IRFs from a reduced form model, e.g. structural IRFs from a VAR, then the method IRF should be implemented. For further details regarding the latter point, see the documentation for IRF.\nFor structural VARs (SVARs), developers may alternatively extend the internal methods _identify and _identify_irfs.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "AbstractIdentificationMethod"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/show_y.html",
    "href": "documentation/julia/all-functions/show_y.html",
    "title": "show_y",
    "section": "",
    "text": "show_y\n\n\n\n\n\nshow_y(q::Q, order::AbstractVector{&lt;:Int})\n@show_y(q, order)\nPretty print the condition q::Q using the variables of the dynamic system, i.e. y.\n\n\n\nq::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.\n\n\n\n\ns_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/show_y.html#arguments",
    "href": "documentation/julia/all-functions/show_y.html#arguments",
    "title": "show_y",
    "section": "",
    "text": "q::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/show_y.html#exajuliaes",
    "href": "documentation/julia/all-functions/show_y.html#exajuliaes",
    "title": "show_y",
    "section": "",
    "text": "s_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_condition.html",
    "href": "documentation/julia/all-functions/make_condition.html",
    "title": "make_condition",
    "section": "",
    "text": "make_condition\n\n\n\n\n\nmake_condition(s::String)\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int})\nMake a transmission condition, i.e. Q(b), out of a string.\nTransmission channels are described using Boolean statements involving the variables in the dynamic model. make_condition allows for specifying these Boolean conditions as a string which is then converted to an internal representation allowing the computation of transmission channels.\nTwo ways of specifying the Boolean conditions exist:\n\nmake_condition(s::String) takes the Boolean condition in the systems form of Wegner et al (2024), i.e. variables must start with x followed by a number. For example, given a three variable VAR(1), y_{1,t} -&gt; x_1, y_{2, t} -&gt; x_2, y_{3, t} -&gt; x_3, y_{1, t+1} -&gt; x_4, y_{2, t+1} -&gt; x_5, … Boolean statements then involve expressions in the x variables and define which paths can be taken. Each path involved in the transmission mechanism must satisfy the Boolean statement.\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int}) does the same as the first method, however the Boolean condition can be specified using the variables of the dynamic systems, i.e. y. Variables must then be specified using y_{i,t} where i is the variable number and t is the period. At all times t &gt;= 0 with 0 denoting the contemporaneous horizon.\n\n\n\n\ns::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.\n\n\n\n\n\nReturns a transmission condition. See also Q.\n\n\n\n\ns = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)\n\n\n\n\nBoolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_condition"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_condition.html#arguments",
    "href": "documentation/julia/all-functions/make_condition.html#arguments",
    "title": "make_condition",
    "section": "",
    "text": "s::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_condition"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_condition.html#returns",
    "href": "documentation/julia/all-functions/make_condition.html#returns",
    "title": "make_condition",
    "section": "",
    "text": "Returns a transmission condition. See also Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_condition"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_condition.html#exajuliaes",
    "href": "documentation/julia/all-functions/make_condition.html#exajuliaes",
    "title": "make_condition",
    "section": "",
    "text": "s = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_condition"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_condition.html#notes",
    "href": "documentation/julia/all-functions/make_condition.html#notes",
    "title": "make_condition",
    "section": "",
    "text": "Boolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_condition"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/@show_y.html",
    "href": "documentation/julia/all-functions/@show_y.html",
    "title": "@show_y",
    "section": "",
    "text": "@show_y\n\n\n\n\n\nshow_y(q::Q, order::AbstractVector{&lt;:Int})\n@show_y(q, order)\nPretty print the condition q::Q using the variables of the dynamic system, i.e. y.\n\n\n\nq::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.\n\n\n\n\ns_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "\\@show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/@show_y.html#arguments",
    "href": "documentation/julia/all-functions/@show_y.html#arguments",
    "title": "@show_y",
    "section": "",
    "text": "q::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "\\@show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/@show_y.html#exajuliaes",
    "href": "documentation/julia/all-functions/@show_y.html#exajuliaes",
    "title": "@show_y",
    "section": "",
    "text": "s_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "\\@show_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/fit_and_select!.html",
    "href": "documentation/julia/all-functions/fit_and_select!.html",
    "title": "fit_and_select!",
    "section": "",
    "text": "fit_and_select!\n\n\n\n\n\nfit_and_select!(::Model, args..., selection_function::Function)\nEstimates the model and selects among various models using selection_function. The best model has the smallest selection_function value, where selection_function must return a scalar.\n\n\n\n\n\n\n\n\n\n\n\nfit_and_select!\n\n\n\n\n\nfit_and_select!(model::Model, method::AbstractIdentificationMethod, selection_func::Function)\nFits the model model using the identification method method and selects the best specification based on the selection_func.\nThe selection function should return a scalar value, with lower values indicating better model fit. Examples include information criteria such as AIC.\n\n\n\n\n\n\n\n\n\n\n\nfit_and_select!\n\n\n\n\n\nfit_and_select!(model::VAR, ic_function::Function=aic) --&gt; (VAR, DataFrame)\nSelect and estimate a VAR model.\nThe best model is determined by the model with the smallest ic_function value among all models with p=1:model.p. Thus, the lag-length of the provided model determines the maximum lag length.\nAvailable choices for ic_function are aic, bic, sic, hqc, but user defined functions can be provided as long as they have the signature ic_function(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) where Sigma_u is the VAR error covariance matrix, num_coeffs is the number of estimated coefficients, and T is a number of effective observations.\nTo be correct, the error covariance matrix of all models is estimated over the same time period. Calling aic or other functions on manually estimated models with differing lag-lengths will not compare the models on the same time period – the model with higher p will have fewer effective number of observations`. It is thus recommended to do model comparison via this function.\n\nArguments\n\nmodel::VAR: VAR model, where the provided lag-length p determines the maximum lag-length.\nic_function::Function: Information criterion function. See the details above. Default is AIC, since it is generally recommended to go with more rather than fewer lags.\n\n\n\nReturns\nReturns a tuple (VAR, DataFrame) where the first element is the best model and the second element is a table with information regarding the ic_function value for each estimated model. Note that manually calling aic or similar functions on the returned model might not provide that same value, since the covariance will now be estimated over the full period rather than the common period.\n\n\n\n\n\n\n\n\n\n\n\n\nfit_and_select!\n\n\n\n\n\nfit_and_select!(model::SVAR, \n                identification_method::AbstractIdentificationMethod, \n                ic_function::Function=aic) --&gt; (SVAR, DataFrame)\nSelect and estimate a SVAR model by first selecting an estimating a VAR model and then identifying the SVAR from the VAR using identification_method.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "fit_and_select!"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/SVAR.html",
    "href": "documentation/julia/all-functions/SVAR.html",
    "title": "SVAR",
    "section": "",
    "text": "SVAR\n\n\n\n\n\nSVAR &lt;: Model\nStructural Vector Autoregressive (SVAR) model in matrix form.\nA SVAR of lag order p is specified as:\n\\[\n    A_0y_t = C e_t + A_1 y_{t-1} + ... + A_p y_{t-p} + \\varepsilon_t\n\\]\nwhere:\n\n\\(e_t\\) is a vector of deterministic components (constant, trends, etc)\n\\(C, A_i\\) are conformable matrices\n\\(\\varepsilon_t\\) are structural shocks\n\nThis can be rewritten compactly as:\n\\[\n    y_t'A0' = z_t' A_+' + u_t'\n\\]\nwhere:\n\n\\(z_t = [e_t; y_{t-1}; ...; y_{t-p}]\\) includes deterministic components and lagged values of all variables\n\\(A_+ = [C, A_1, ..., A_p]\\) is the coefficient matrix stacking trend and autoregressive terms\n\nAssuming \\(A0\\) is invertible, the reduced-form VAR can be obtained as\n\\[\ny_t' = z_t' A_+'(A_0')^{-1} + u_t'(A_0')^{-1}\n\\]\nwhich can be represented using a VAR object.\n\n\n\nA_plus::Matrix{&lt;:Number}: Coefficient matrix [C, A_1, ..., A_p]\nA_0::AbstractMatrix{&lt;:Number}: Contemporaneous relationships.\np::Int: Lag order of the (S)VAR\ntrend_exponents::Vector{&lt;:Number}: Time trend exponents (e.g., [0,1] implies constant and linear trend)\nvar::VAR: Reduced form representation of SVAR",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/SVAR.html#keyword-arguments",
    "href": "documentation/julia/all-functions/SVAR.html#keyword-arguments",
    "title": "SVAR",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_systems_form.html",
    "href": "documentation/julia/all-functions/make_systems_form.html",
    "title": "make_systems_form",
    "section": "",
    "text": "make_systems_form\n\n\n\n\n\nmake_systems_form(\n    Phi0::AbstractMatrix, \n    As::Vector{&lt;:AbstractMatrix}, \n    Psis::Vector{&lt;:AbstractMatrix}, \n    Sigma::AbstractMatrix{&lt;:Real}, \n    order::AbstractVector{&lt;:Int}, \n    max_horizon::Int\n) -&gt; Tuple{AbstractMatrix, AbstractMatrix}\nTransform an SVARMA dynamic model into the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nArguments\n\nPhi0::AbstractMatrix: The matrix of contemporaneous structural impulse responses.\nAs::Vector{&lt;:AbstractMatrix}: A vector of reduced-form autoregressive (AR). First entry corresponds to the AR matrix for the first lag, etc.\nPsis::Vector{&lt;:AbstractMatrix}: A vector of reduced-form moving average (MA) matrices. First index corresponds to the first lag, etc.\nSigma::AbstractMatrix{&lt;:Real}: The covariance matrix of reduced-form errors.\norder::AbstractVector{&lt;:Int}: The vector indicating the order of variables, typically determined by the transmission matrix.\nmax_horizon::Int: The maximum time horizon to consider for the systems model, with 0 representing the contemporaneous period.\n\n\n\nReturns\n\n(B, Omega) with the meaning being the same as in Wegner et al (2024).\n\n\n\nNotes\n\nUse make_B and make_Omega to construct the two matrices seperately.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_systems_form"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/get_variable_names.html",
    "href": "documentation/julia/all-functions/get_variable_names.html",
    "title": "get_variable_names",
    "section": "",
    "text": "get_variable_names\n\n\n\n\n\nget_variable_names(model::Model) --&gt; Vector{Symbol}\nObtain the variable names of the model’s input data.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "get_variable_names"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/map_y_to_x.html",
    "href": "documentation/julia/all-functions/map_y_to_x.html",
    "title": "map_y_to_x",
    "section": "",
    "text": "map_y_to_x\n\n\n\n\n\nmap_y_to_x(i::Int, t::Int, K::Int, order::AbstractVector{&lt;:Int}) -&gt; Int\nMaps a variable in the original transmission condition (using variables y) to its corresponding systems form (using variables x).\n\nArguments\n\ni::Int: Index of the variable in the original system.\nt::Int: Time index of the variable in the original system.\nK::Int: Total number of variables in the system.\norder::AbstractVector{&lt;:Int}: Vector defining the ordering of variables (defined by the transmission matrix).\n\n\n\nReturns\n\nAn integer representing the index of the corresponding x variable in the systems form.\n\n\n\nNotes\n\nThe contemporaneous period is denoted is period 0.\n\n\n\n\n\n\n\n\n\n\n\n\n\nmap_y_to_x\n\n\n\n\n\nmap_y_to_x(s_y::String, order::AbstractVector{&lt;:Int}) -&gt; String\nTransforms a string representing a transmission condition in terms of the original variables y to a string using the systems form variables x based on a specified ordering.\n\nArguments\n\ns_y::String: A string representing the transmission condition using original variables y, e.g. “y{1,0} & !y{2,0}”.\norder::AbstractVector{&lt;:Int}: Ordering defined in the transmission matrix.\n\n\n\nReturns\n\nA string representing the same transmission question but using variables of the systems form (x) rather than those of the dynamic (original) system (y).\n\n\n\nEx```{julia}le\norder = [3, 1, 2]\ns_y = \"y_{1, 2} & y_{3, 1}\"\nmap_y_to_x(s_y, order)  # Returns: \"x8 & x4\"",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "map_y_to_x"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/IRF.html",
    "href": "documentation/julia/all-functions/IRF.html",
    "title": "IRF",
    "section": "",
    "text": "IRF\n\n\n\n\n\nIRF(irfs::Array{&lt;:Number,3}, varnames::Vector{Symbol},\n    model::Model, ident_method::Union{Nothing, AbstractIdentificationMethod}=nothing)\nContainer for storing impulse response functions (IRFs) computed from a model.\nThis structure captures both reduced-form and structural IRFs. For IRFs identified from a reduced-form model using an identification method (e.g., recursive or external instruments), the ident_method should be explicitly provided.\nFor models that are already structural (e.g., identified SVARs) or for reduced-form IRFs (without identification), the ident_method should be left as nothing.\n\nFields\n\nirfs::Array{&lt;:Number,3}: The IRFs with shape (variables, shocks, horizons)\nvarnames::Vector{Symbol}: Variable names\nmodel::Model: The model object used to generate the IRFs\nident_method::Union{Nothing, AbstractIdentificationMethod}: The identification method used, if applicable (only for RF models)\n\n\n\nConstructors\n\nIRF(irfs, varnames, model) Creates an IRF object for a structural model or reduced-form IRFs\nIRF(irfs, varnames, model, ident_method) Use this when IRFs are structurally identified from a reduced-form model\n\n\n\n\n\n\n\n\n\n\n\n\n\nIRF\n\n\n\n\n\nIRF(model::Model, max_horizon::Int)\nReturns the impulse response functions (IRFs) from model up to horizon max_horizon.\n\n\n\n\n\n\n\n\n\n\n\nIRF\n\n\n\n\n\nIRF(model::Model, method::AbstractIdentificationMethod, max_horizon::Int)\nReturns the impulse response functions (IRFs) identified from model using the identification method method, up to the specified max_horizon.\nMust return an object of type IRF.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "IRF"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/map_x_to_y.html",
    "href": "documentation/julia/all-functions/map_x_to_y.html",
    "title": "map_x_to_y",
    "section": "",
    "text": "map_x_to_y\n\n\n\n\n\nmap_x_to_y(xi::Int, order::AbstractVector{&lt;:Int}) -&gt; Tuple{Int, Int}\nMaps a variable from the systems form (using variables x) back to its original transmission condition form (using variables y). This function is the reverse of map_y_to_x.\n\nArguments\n\nxi::Int: Index of the variable in the systems form.\norder::AbstractVector{&lt;:Int}: Ordering defined in the transmission matrix.\n\n\n\nReturns\n\nA tuple (i, t) where i is the index of the variable in the original system and t is its time index.\n\n\n\n\n\n\n\n\n\n\n\n\n\nmap_x_to_y\n\n\n\n\n\nmap_x_to_y(s_x::String, order::AbstractVector{&lt;:Int}) -&gt; String\nTransforms a string representing a transmission condition in terms of the systems form variables x back to a string using the original variables y. This function is the reverse of map_y_to_x.\n\nArguments\n\ns_x::String: A string representing the transmission condition using systems form variables x.\norder::AbstractVector{&lt;:Int}: Ordering defined by the transmission matrix.\n\n\n\nReturns\n\nA string representing the same transmission question but using variables of the dynamic (original) system (y) rather than those of the systems form (x).\n\n\n\nEx```{julia}le\norder = [3, 1, 2]\ns_x = \"x8 & x4\"\nmap_x_to_y(s_x, order)  # Returns: \"y_{1, 2} + y_{3, 1}\"",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "map_x_to_y"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/Recursive.html",
    "href": "documentation/julia/all-functions/Recursive.html",
    "title": "Recursive",
    "section": "",
    "text": "Recursive\n\n\n\n\n\nRecursive &lt;: AbstractIdentificationMethod\nGeneral-purpose identification method based on recursive, or conditional ignorability, assumptions.\nThis method assumes that, conditional on variables ordered before, a given variable (often interpreted as a treatment or shock) is as good as random. This enables causal interpretation of the identified shock as structural.\nIn macroeconomic applications, this is typically operationalized through a Cholesky decomposition in structural VARs (SVARs), but the method is not limited to this setting. It applies to any model in which recursive ordering (conditioning on other variables) can be used to justify identification.\nConditioning variables are those that are ordered before the treatment variable in the provided dataset.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "Recursive"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/aic.html",
    "href": "documentation/julia/all-functions/aic.html",
    "title": "aic",
    "section": "",
    "text": "aic\n\n\n\n\n\naic(model::Union{VAR,SVAR}) -&gt; Real\naic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nbic(model::Union{VAR,SVAR}) -&gt; Real\nbic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nsic(model::Union{VAR,SVAR}) -&gt; Real\nsic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nhqc(model::Union{VAR,SVAR}) -&gt; Real\nhqc(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\nComputes information criteria for model selection in VARs.\nGiven a fitted VAR model or directly the covariance matrix Sigma_u, the number of estimated coefficients, and sample size T, each function returns the respective criterion value:\n\nAIC (Akaike Information Criterion):\n\n\\[\n\\text{AIC} = \\log\\det(\\Sigma_u) + \\frac{2k}{T}\n\\]\n\nSIC/BIC (Schwarz/Bayesian Information Criterion):\n\n\\[\n\\text{SIC} = \\log\\det(\\Sigma_u) + \\frac{\\log(T) k}{T}\n\\]\n\nHQC (Hannan-Quinn Criterion):\n\n\\[\n\\text{HQC} = \\log\\det(\\Sigma_u) + \\frac{2 \\log(\\log T) k}{T}\n\\]\nHere, \\(k\\) is the number of estimated parameters and \\(T\\) is the effective sample size.\n\nArguments\n\nmodel::VAR: A fitted VAR model\nSigma_u::Matrix{&lt;:Number}: Residual covariance matrix\nnum_coeffs::Int: Number of estimated coefficients\nT::Int: Number of observations used in estimation",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "aic"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_Omega.html",
    "href": "documentation/julia/all-functions/make_Omega.html",
    "title": "make_Omega",
    "section": "",
    "text": "make_Omega\n\n\n\n\n\nConstruct Omega of the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nNotes\n\nSee make_systems_form for further information.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_Omega"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/Model.html",
    "href": "documentation/julia/all-functions/Model.html",
    "title": "Model",
    "section": "",
    "text": "Model\n\n\n\n\n\nNo documentation found for public symbol.\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\n\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\n\n\n\nabstract type TransmissionChannelAnalysis.Model\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\n\n\n\nSubtypes\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\n\n\n\nTransmissionChannelAnalysis.LP\nTransmissionChannelAnalysis.SVAR\nTransmissionChannelAnalysis.VAR",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/residuals.html",
    "href": "documentation/julia/all-functions/residuals.html",
    "title": "residuals",
    "section": "",
    "text": "residuals\n\n\n\n\n\nresiduals(::Model)\nReturns the residuals of the estimated model.\n\n\n\n\n\n\n\n\n\n\n\nresiduals\n\n\n\n\n\nresiduals(model::LP)\nReturns the residuals of the local projection in a three dimensional array, where the third dimension corresponds to the various horizons, and the second dimension corresponds to the various variables.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "residuals"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/make_companion_matrix.html",
    "href": "documentation/julia/all-functions/make_companion_matrix.html",
    "title": "make_companion_matrix",
    "section": "",
    "text": "make_companion_matrix\n\n\n\n\n\nmake_companion_matrix(B_plus::Matrix{&lt;:Number}) -&gt; Matrix{&lt;:Number}\nmake_companion_matrix(Bs::Vector{&lt;:Matrix{&lt;:Number}}, p::Int, n_exo::Int) -&gt; Matrix{&lt;:Number}\nConstructs the companion matrix of a VAR(p) model.\n\nArguments\n\nBs: a vector of lag matrices [B_1, B_2, ..., B_p], each k × k\nB_plus: a single matrix formed by horizontally concatenating \\([C B_1 B_2 ... B_p]\\) where \\(C\\) is the matrix of coefficients for deterministic (exogeneous) components.\np::Int: lag-length of the VAR.\nn_exo::Int: number of exogenous components, i.e. number of columns in \\(C\\).\n\n\n\nReturns\n\nMatrix{&lt;:Number}: The companion matrix of size (k*p × k*p)\n\n\n\nNotes\nThe companion matrix C has the block form:\n\\[\nC = \\begin{bmatrix}\n    B_+ \\\\\n    I_{(p-1)k} & 0\n\\end{bmatrix}\n\\]\nwhere \\(B_+\\) stacks the lag matrices, and \\(k\\) is the number of variables.\n\n\n\n\n\n\n\n\n\n\n\n\nmake_companion_matrix\n\n\n\n\n\nmake_companion_matrix(model::VAR) -&gt; Matrix{&lt;:Number}\nReturns the companion matrix of a VAR(p) model.\nThe companion matrix is a square matrix of size (k * p, k * p), where k is the number of variables in the system and p is the lag order.\n\\[\n    Z_t = A Z_{t-1} + \\varepsilon_t\n\\]\nwhere \\(Z_t\\) is a \\(k \\times p\\)-dimensional stacked vector of lagged variables.\nThe matrix has the following block form:\n\\[\nA = \\begin{bmatrix}\n    B_1 & B_2 & ... & B_p \\\\\n    I_k & 0   & ... & 0   \\\\\n    0   & I_k & ... & 0   \\\\\n    ... & ... & ... & ...\n\\end{bmatrix}\n\\]\nwhere \\(B_1, ..., B_p\\) are the VAR coefficient matrices, and \\(I_k\\) is the identity matrix of size k.\n\nArguments\n\nmodel::VAR: A fitted VAR model.\n\n\n\n\n\n\n\n\n\n\n\n\n\nmake_companion_matrix\n\n\n\n\n\nmake_companion_matrix(model::SVAR) --&gt; Matrix{&lt;:Number}\nReturns the companion matrix for the VAR representation of the SVAR.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "make_companion_matrix"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/bic.html",
    "href": "documentation/julia/all-functions/bic.html",
    "title": "bic",
    "section": "",
    "text": "bic\n\n\n\n\n\naic(model::Union{VAR,SVAR}) -&gt; Real\naic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nbic(model::Union{VAR,SVAR}) -&gt; Real\nbic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nsic(model::Union{VAR,SVAR}) -&gt; Real\nsic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nhqc(model::Union{VAR,SVAR}) -&gt; Real\nhqc(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\nComputes information criteria for model selection in VARs.\nGiven a fitted VAR model or directly the covariance matrix Sigma_u, the number of estimated coefficients, and sample size T, each function returns the respective criterion value:\n\nAIC (Akaike Information Criterion):\n\n\\[\n\\text{AIC} = \\log\\det(\\Sigma_u) + \\frac{2k}{T}\n\\]\n\nSIC/BIC (Schwarz/Bayesian Information Criterion):\n\n\\[\n\\text{SIC} = \\log\\det(\\Sigma_u) + \\frac{\\log(T) k}{T}\n\\]\n\nHQC (Hannan-Quinn Criterion):\n\n\\[\n\\text{HQC} = \\log\\det(\\Sigma_u) + \\frac{2 \\log(\\log T) k}{T}\n\\]\nHere, \\(k\\) is the number of estimated parameters and \\(T\\) is the effective sample size.\n\nArguments\n\nmodel::VAR: A fitted VAR model\nSigma_u::Matrix{&lt;:Number}: Residual covariance matrix\nnum_coeffs::Int: Number of estimated coefficients\nT::Int: Number of observations used in estimation",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "bic"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/cov.html",
    "href": "documentation/julia/all-functions/cov.html",
    "title": "cov",
    "section": "",
    "text": "cov\n\n\n\n\n\nNo documentation found for public symbol.\n\n\n\n\n\n\n\n\n\n\n\ncov\n\n\n\n\n\nTransmissionChannelAnalysis.cov is a Function.\n\n\n\n\n\n\n\n\n\n\n\ncov\n\n\n\n\n\n# 1 method for generic function \"cov\" from TransmissionChannelAnalysis:\n [1] cov(model::TransmissionChannelAnalysis.VAR)\n     @ ~/.julia/packages/TransmissionChannelAnalysis/ZQ5o4/src/models/var.jl:150",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "cov"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/fit!.html",
    "href": "documentation/julia/all-functions/fit!.html",
    "title": "fit!",
    "section": "",
    "text": "fit!\n\n\n\n\n\nfit!(::Model, args...; kwargs...)\nEstimates the model.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "fit!"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/fit!.html#argument",
    "href": "documentation/julia/all-functions/fit!.html#argument",
    "title": "fit!",
    "section": "Argument",
    "text": "Argument\n\nmodel::SVAR: A SVAR model to be estimated\nidentification_method::AbstractIdentificationMethod: Identification method used to identify SVAR from reduced-form VAR",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "fit!"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html",
    "href": "documentation/julia/internals.html",
    "title": "Internals",
    "section": "",
    "text": "The internals of TransmissionChannelAnalysis.jl all resolve around the type Q, which is the internal representation of a transmission condition using the variables of the systems form; thus \\(x_i\\) and not \\(y_{i,t}\\).\n\n\n\n\n\n\n\nQ\n\n\n\n\n\nQ(s::String)\nQ(s::String, m::Number)\nQ(s::Vector{String})\nQ(s::Vector{String}, m::Vector{Number})\nQ(i::Int)\nRepresents a transmission condition.\nWe denote with Q(b), where b is a Boolean statement, a transmission question.\nImportant: Each string in s: should be a Boolean statement involving variables x``followed by a number, i.e.x1,x2`, etc. Additionally, each Boolean statement should contain only AND (&) and NOT (!) statements.\nImportant: Users should only use the Q(i::Int) constructor. All other constructors are for internal use only. Misuse of the other constructors easily leads to mistakes.\n\n\n\nvars::Vector{String}: Contains the variables. These will be Boolean statements containing only AND and NOT.\nmultiplier::Vector{Number}: Multiplier in front of Q(b).\n\n\n\n\n\ns::Union{String, Vector{String}}: String representation of transmission condition.\nm::Union{Number, Vector{Number}}: Multipliers for transmission conditions.\ni::Int: Variable number.\n\n\n\n\n\n# Defining all variables in one go\nx = [Q(\"x$i\") for i = 1:10]\nq = (x[1] | x[2]) & !x[3]\n\n# Alternatively variables can be defined separaterly\nx1 = Q(\"x1\")\nx2 = Q(\"x2\")\nx3 = Q(\"x3\")\nq = (x1 | x2) & !x3\n\n# The following are also valid\nq = Q(\"x1 & !x3\", 1)\nq = Q([\"x1\", \"x2\", \"x1 & x2\"], [1, 1, -1])\n\n# The following is NOT valid but does not yet throw an error or warning\nq = Q(\"x1 | x2\")  # DO NOT DO THIS!\n\n\n\n\n\nThe basic idea is to start with a singleton statement, such as \\(x_i\\), \\(\\neg x_i\\) or sometimes even just \\(\\text{TRUE}\\). Each of these singleton – or atomic – statements refers to the simplest transmission channel in which \\(x_i\\) must be on the path, \\(x_i\\) cannot be on the path, or in which case the condition is always true. Such singleton statement can be created in the following way.\n\n# Q is not exported\n\n# x1 must be on the path\nx1 = TransmissionChannelAnalysis.Q(1)\n\n# x1 cannot be on the path\nnot_x2 = TransmissionChannelAnalysis.Q(\"!x2\")\n\n# TRUE\nT = TransmissionChannelAnalysis.Q(\"\")\n\nMore complex transmission conditions are then simply a combination of these singleton statements. More precisely, a transmission condition q1::Q can be combined with another transmission condition q2::Q using any of AND (&), OR (|) and NOT (!). Throughout, parentheses can be used to change the precedence. In the following we will describe how such combinations are internally implemented.\n\n\nSuppose we wanted to combine two conditions q1::Q and q2::Q using an AND. Thus, suppose we wanted to do\n\nq1 & q2\n\nThis is achieved by extending Base.&. However, key in the internal implementation is the following assumption.\n\n\n\n\n\n\nNote 1: Assumption 1\n\n\n\nThe transmission condition q::Q consists of only conjunctions (&) and negations (!).\n\n\nUnder Assumption 1 q1::Q and q2::Q both consists of only conjunctions and disjunctions. This immediately implies that their conjunction will also only consist of conjunctions and negations. We can thus simply “concatenate” the two conditions. This is basically what we internally do, with the caveat that the conditions are represented using String and that, for algorithimic purposes, we prefer the variables to be ordered in the statement.\nThe detailed internal implementation is given by\n\n\n\n\n\n\n\n&\n\n\n\n\n\nBase.&(q1::Q, q2::Q)\nCombine two transmission conditions using AND.\n\n\n\n\n\n\n\n\n\n\n\nstring_and\n\n\n\n\n\nstring_and(s1::String, s2::String)\nCombine two strings using “&”.\nMakes sure that only unique variables occur. Also sorts the string such that negated variables only come after all non-negated variables, and higher-variables come before lower variables.\n\n\ns1 = \"x1 & x2\"\ns2 = \"x1 & !x2\"\nstring_and(s1, s2)\n# output: \"x2 & x1 & !x2\"\n\n\n\n\n\nWhile concatenating the two conditions, we need to watch out that no contradictions are being introduced. Contradictions are any statements along the lines \\(x_i \\land \\neg x_i\\) which would always result in false. This is taken care of by the following functions.\n\n\n\n\n\n\n\ncheck_contradiction\n\n\n\n\n\ncheck_contradiction(var_and::Vector{Int}, var_not::Vector{Int})\ncheck_contradiction(var_and::Vector{Vector{Int}}, var_not::Vector{Vector{Int}})\nCheck whether there is a contradiction of the form x1 & !x1.\n\n\n\nvar_and::Union{Vector{Int}, Vector{Vector{Int}}}: AND variable numbers obtained from get_varnums_and_multiplier.\nvar_not::Union{Vector{Int}, Vector{Vector{Int}}}: NOT variable numbers obtained from get_varnums_and_multiplier\n\n\n\n\n\nBool indicating whether there are any contradictions.\nVector{Bool} indicating which elements yielded a contradiction.\n\n\n\n\n\nThis is used in remove_contradictions to remove contradicting terms. This speeds up simplification of terms, since the total number of terms can often be reduced.\n\n\n\n\n\n\n\n\n\n\n\n\n\nremove_contradictions\n\n\n\n\n\nremove_contradictions(q::Q)\nRemove contradicting terms.\nA terms is deemed contradicting if it includes some “xi & !xi”. This would result in the entire Boolean statement to be false, and thus in the effect of this terms to be zero.\n\n\n\nq::Q: A transmission condition. See also Q and make_condition.\n\n\n\n\n\nIf TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == false, then q will simply be returned again.\nIf TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == true, then\n\nIf all terms are contradicting, then Q(\"\", 0) will be retuned, which has a transmission effect of zero.\nIf some terms are non-contradicting, then a transmission condition consisting of only the non-contradicting terms will be returned.\n\n\n\n\n\nTransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] = true\nq = TransmissionChannelAnalysis.Q(\"x1\", 1)\nremove_contradictions(q)  # will return q again since no contradictions exist\n\nq = TransmissionChannelAnalysis.Q(\"x1 & !x1\", 1)\nremove_contradictions(q)  # Will return Q(\"\", 0)\n\nq = TransmissionChannelAnalysis.Q([\"x1 & !x1\", \"x1 & x2\"], [1, 1])\nremove_contradictions(q)  # Will return Q(\"x1 & x2\", 1)\n\n\n\n\n\nAs stated in the overview of the documentation, removal of contradictions is governed by REMOVE_CONTRADICTION and the utility function set_remove_contradictions. Not removing contradictions does not lead to a mistakes in the computation, but can result in longer computations. Contrary, removing contradictions can lead to longer compile times – it takes longer to compile the transmission conditions. Thus, a trade-off between compile and computing time exists.\n\n\n\nLet q1::Q and q2::Q be again two transmission conditions. Suppose their internal Boolean conditions are given by \\(b\\) and \\(b'\\) respectively, with both satisfying Assumption 1. The rules for manipulating transmission conditions then imply \\[\nQ(b \\lor b') = Q(b) + Q(b') - Q(b \\land b').\n\\] Implementation of OR (|) therefore simply uses AND and the ability for Q to represent multiple terms with different multipliers. The precise implementation of OR can be found in the following function.\n\n\n\n\n\n\n\n|\n\n\n\n\n\nBase.|(q1::Q, q2::Q)\nCombine two transmission conditions using OR.\n\n\n\n\n\n\n\nSuppose a transmission condition is given by q::Q which internally represents the Boolean condition \\(b\\). By the rules for manipulating transmission conditions we then know that \\[\nQ(\\neg b) = Q(T) - Q(b),\n\\] where \\(T\\) represents the Boolean condition that is always true. This can easily be represented using Q through its ability to represent multiple terms and multipliers. Specifically, we simply replace the original transmission condition with a new one that consists one one additional term, representing true, and switch the sign of all original terms of the condition. The following function implements this behaviour.\n\n\n\n\n\n\n\n!\n\n\n\n\n\nBase.!(q1::Q)\nReturn NOT the transmission condition if the condition involves more than one variables. If the condition only involves one variables, then “!x1” is returned where “1” is replaced by the respective variable number.\nNote: The decision not to simplify terms of the form “!x1” was made because calculations usign the second calculation method in Wegner et al (2024) are faster than having to simplify “!x1” type of terms and using the first calculation method.\n\n\n\n\n\n\n\nRather than letting the user create all variables manually via x1 = Q(1) etc., we provide the function make_condition. This function simply matches all variables in a string with the regex x\\d+, creates teh variables using the above way, and then evaluates the entire condition to create the final condition. Due to the operator overloading above, the final result will be a valid and correct transmission condtion. However, key to this correctness is that all variables math the provided regex pattern. Thus, all variables must be of the form x1, x2, etc.\nFor user friendliness, we also provide a version of make_condition that takes variables of the dynamic form, i.e. \\(y_{i,t}\\). However, all that this function does is to translate all variables into variables of the systems form and then calls the method explained above.\nIn any case, make_conditions should be seen as a utility function with the main funcionality being dependent on correct implementation of Q, &, |, and ! as explained above.\n\n\n\n\n\n\n\nmake_condition\n\n\n\n\n\nmake_condition(s::String)\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int})\nMake a transmission condition, i.e. Q(b), out of a string.\nTransmission channels are described using Boolean statements involving the variables in the dynamic model. make_condition allows for specifying these Boolean conditions as a string which is then converted to an internal representation allowing the computation of transmission channels.\nTwo ways of specifying the Boolean conditions exist:\n\nmake_condition(s::String) takes the Boolean condition in the systems form of Wegner et al (2024), i.e. variables must start with x followed by a number. For example, given a three variable VAR(1), y_{1,t} -&gt; x_1, y_{2, t} -&gt; x_2, y_{3, t} -&gt; x_3, y_{1, t+1} -&gt; x_4, y_{2, t+1} -&gt; x_5, … Boolean statements then involve expressions in the x variables and define which paths can be taken. Each path involved in the transmission mechanism must satisfy the Boolean statement.\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int}) does the same as the first method, however the Boolean condition can be specified using the variables of the dynamic systems, i.e. y. Variables must then be specified using y_{i,t} where i is the variable number and t is the period. At all times t &gt;= 0 with 0 denoting the contemporaneous horizon.\n\n\n\n\ns::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.\n\n\n\n\n\nReturns a transmission condition. See also Q.\n\n\n\n\ns = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)\n\n\n\n\nBoolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#fields",
    "href": "documentation/julia/internals.html#fields",
    "title": "Internals",
    "section": "",
    "text": "vars::Vector{String}: Contains the variables. These will be Boolean statements containing only AND and NOT.\nmultiplier::Vector{Number}: Multiplier in front of Q(b).",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#arguments",
    "href": "documentation/julia/internals.html#arguments",
    "title": "Internals",
    "section": "",
    "text": "s::Union{String, Vector{String}}: String representation of transmission condition.\nm::Union{Number, Vector{Number}}: Multipliers for transmission conditions.\ni::Int: Variable number.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#juliage",
    "href": "documentation/julia/internals.html#juliage",
    "title": "Internals",
    "section": "",
    "text": "# Defining all variables in one go\nx = [Q(\"x$i\") for i = 1:10]\nq = (x[1] | x[2]) & !x[3]\n\n# Alternatively variables can be defined separaterly\nx1 = Q(\"x1\")\nx2 = Q(\"x2\")\nx3 = Q(\"x3\")\nq = (x1 | x2) & !x3\n\n# The following are also valid\nq = Q(\"x1 & !x3\", 1)\nq = Q([\"x1\", \"x2\", \"x1 & x2\"], [1, 1, -1])\n\n# The following is NOT valid but does not yet throw an error or warning\nq = Q(\"x1 | x2\")  # DO NOT DO THIS!",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#combining-two-conditions-using-and",
    "href": "documentation/julia/internals.html#combining-two-conditions-using-and",
    "title": "Internals",
    "section": "",
    "text": "Suppose we wanted to combine two conditions q1::Q and q2::Q using an AND. Thus, suppose we wanted to do\n\nq1 & q2\n\nThis is achieved by extending Base.&. However, key in the internal implementation is the following assumption.\n\n\n\n\n\n\nNote 1: Assumption 1\n\n\n\nThe transmission condition q::Q consists of only conjunctions (&) and negations (!).\n\n\nUnder Assumption 1 q1::Q and q2::Q both consists of only conjunctions and disjunctions. This immediately implies that their conjunction will also only consist of conjunctions and negations. We can thus simply “concatenate” the two conditions. This is basically what we internally do, with the caveat that the conditions are represented using String and that, for algorithimic purposes, we prefer the variables to be ordered in the statement.\nThe detailed internal implementation is given by\n\n\n\n\n\n\n\n&\n\n\n\n\n\nBase.&(q1::Q, q2::Q)\nCombine two transmission conditions using AND.\n\n\n\n\n\n\n\n\n\n\n\nstring_and\n\n\n\n\n\nstring_and(s1::String, s2::String)\nCombine two strings using “&”.\nMakes sure that only unique variables occur. Also sorts the string such that negated variables only come after all non-negated variables, and higher-variables come before lower variables.\n\n\ns1 = \"x1 & x2\"\ns2 = \"x1 & !x2\"\nstring_and(s1, s2)\n# output: \"x2 & x1 & !x2\"\n\n\n\n\n\nWhile concatenating the two conditions, we need to watch out that no contradictions are being introduced. Contradictions are any statements along the lines \\(x_i \\land \\neg x_i\\) which would always result in false. This is taken care of by the following functions.\n\n\n\n\n\n\n\ncheck_contradiction\n\n\n\n\n\ncheck_contradiction(var_and::Vector{Int}, var_not::Vector{Int})\ncheck_contradiction(var_and::Vector{Vector{Int}}, var_not::Vector{Vector{Int}})\nCheck whether there is a contradiction of the form x1 & !x1.\n\n\n\nvar_and::Union{Vector{Int}, Vector{Vector{Int}}}: AND variable numbers obtained from get_varnums_and_multiplier.\nvar_not::Union{Vector{Int}, Vector{Vector{Int}}}: NOT variable numbers obtained from get_varnums_and_multiplier\n\n\n\n\n\nBool indicating whether there are any contradictions.\nVector{Bool} indicating which elements yielded a contradiction.\n\n\n\n\n\nThis is used in remove_contradictions to remove contradicting terms. This speeds up simplification of terms, since the total number of terms can often be reduced.\n\n\n\n\n\n\n\n\n\n\n\n\n\nremove_contradictions\n\n\n\n\n\nremove_contradictions(q::Q)\nRemove contradicting terms.\nA terms is deemed contradicting if it includes some “xi & !xi”. This would result in the entire Boolean statement to be false, and thus in the effect of this terms to be zero.\n\n\n\nq::Q: A transmission condition. See also Q and make_condition.\n\n\n\n\n\nIf TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == false, then q will simply be returned again.\nIf TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == true, then\n\nIf all terms are contradicting, then Q(\"\", 0) will be retuned, which has a transmission effect of zero.\nIf some terms are non-contradicting, then a transmission condition consisting of only the non-contradicting terms will be returned.\n\n\n\n\n\nTransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] = true\nq = TransmissionChannelAnalysis.Q(\"x1\", 1)\nremove_contradictions(q)  # will return q again since no contradictions exist\n\nq = TransmissionChannelAnalysis.Q(\"x1 & !x1\", 1)\nremove_contradictions(q)  # Will return Q(\"\", 0)\n\nq = TransmissionChannelAnalysis.Q([\"x1 & !x1\", \"x1 & x2\"], [1, 1])\nremove_contradictions(q)  # Will return Q(\"x1 & x2\", 1)\n\n\n\n\n\nAs stated in the overview of the documentation, removal of contradictions is governed by REMOVE_CONTRADICTION and the utility function set_remove_contradictions. Not removing contradictions does not lead to a mistakes in the computation, but can result in longer computations. Contrary, removing contradictions can lead to longer compile times – it takes longer to compile the transmission conditions. Thus, a trade-off between compile and computing time exists.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#exajuliaes",
    "href": "documentation/julia/internals.html#exajuliaes",
    "title": "Internals",
    "section": "",
    "text": "s1 = \"x1 & x2\"\ns2 = \"x1 & !x2\"\nstring_and(s1, s2)\n# output: \"x2 & x1 & !x2\"",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#arguments-1",
    "href": "documentation/julia/internals.html#arguments-1",
    "title": "Internals",
    "section": "",
    "text": "var_and::Union{Vector{Int}, Vector{Vector{Int}}}: AND variable numbers obtained from get_varnums_and_multiplier.\nvar_not::Union{Vector{Int}, Vector{Vector{Int}}}: NOT variable numbers obtained from get_varnums_and_multiplier",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#returns",
    "href": "documentation/julia/internals.html#returns",
    "title": "Internals",
    "section": "",
    "text": "Bool indicating whether there are any contradictions.\nVector{Bool} indicating which elements yielded a contradiction.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#notes",
    "href": "documentation/julia/internals.html#notes",
    "title": "Internals",
    "section": "",
    "text": "This is used in remove_contradictions to remove contradicting terms. This speeds up simplification of terms, since the total number of terms can often be reduced.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#arguments-2",
    "href": "documentation/julia/internals.html#arguments-2",
    "title": "Internals",
    "section": "",
    "text": "q::Q: A transmission condition. See also Q and make_condition.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#returns-1",
    "href": "documentation/julia/internals.html#returns-1",
    "title": "Internals",
    "section": "",
    "text": "If TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == false, then q will simply be returned again.\nIf TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] == true, then\n\nIf all terms are contradicting, then Q(\"\", 0) will be retuned, which has a transmission effect of zero.\nIf some terms are non-contradicting, then a transmission condition consisting of only the non-contradicting terms will be returned.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#exajuliaes-1",
    "href": "documentation/julia/internals.html#exajuliaes-1",
    "title": "Internals",
    "section": "",
    "text": "TransmissionChannelAnalysis.REMOVE_CONTRADICTIONS[] = true\nq = TransmissionChannelAnalysis.Q(\"x1\", 1)\nremove_contradictions(q)  # will return q again since no contradictions exist\n\nq = TransmissionChannelAnalysis.Q(\"x1 & !x1\", 1)\nremove_contradictions(q)  # Will return Q(\"\", 0)\n\nq = TransmissionChannelAnalysis.Q([\"x1 & !x1\", \"x1 & x2\"], [1, 1])\nremove_contradictions(q)  # Will return Q(\"x1 & x2\", 1)",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#combining-two-conditions-using-or",
    "href": "documentation/julia/internals.html#combining-two-conditions-using-or",
    "title": "Internals",
    "section": "",
    "text": "Let q1::Q and q2::Q be again two transmission conditions. Suppose their internal Boolean conditions are given by \\(b\\) and \\(b'\\) respectively, with both satisfying Assumption 1. The rules for manipulating transmission conditions then imply \\[\nQ(b \\lor b') = Q(b) + Q(b') - Q(b \\land b').\n\\] Implementation of OR (|) therefore simply uses AND and the ability for Q to represent multiple terms with different multipliers. The precise implementation of OR can be found in the following function.\n\n\n\n\n\n\n\n|\n\n\n\n\n\nBase.|(q1::Q, q2::Q)\nCombine two transmission conditions using OR.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#negating-a-condition-using-not",
    "href": "documentation/julia/internals.html#negating-a-condition-using-not",
    "title": "Internals",
    "section": "",
    "text": "Suppose a transmission condition is given by q::Q which internally represents the Boolean condition \\(b\\). By the rules for manipulating transmission conditions we then know that \\[\nQ(\\neg b) = Q(T) - Q(b),\n\\] where \\(T\\) represents the Boolean condition that is always true. This can easily be represented using Q through its ability to represent multiple terms and multipliers. Specifically, we simply replace the original transmission condition with a new one that consists one one additional term, representing true, and switch the sign of all original terms of the condition. The following function implements this behaviour.\n\n\n\n\n\n\n\n!\n\n\n\n\n\nBase.!(q1::Q)\nReturn NOT the transmission condition if the condition involves more than one variables. If the condition only involves one variables, then “!x1” is returned where “1” is replaced by the respective variable number.\nNote: The decision not to simplify terms of the form “!x1” was made because calculations usign the second calculation method in Wegner et al (2024) are faster than having to simplify “!x1” type of terms and using the first calculation method.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#parsing-transmission-conditions-using-make_condition",
    "href": "documentation/julia/internals.html#parsing-transmission-conditions-using-make_condition",
    "title": "Internals",
    "section": "",
    "text": "Rather than letting the user create all variables manually via x1 = Q(1) etc., we provide the function make_condition. This function simply matches all variables in a string with the regex x\\d+, creates teh variables using the above way, and then evaluates the entire condition to create the final condition. Due to the operator overloading above, the final result will be a valid and correct transmission condtion. However, key to this correctness is that all variables math the provided regex pattern. Thus, all variables must be of the form x1, x2, etc.\nFor user friendliness, we also provide a version of make_condition that takes variables of the dynamic form, i.e. \\(y_{i,t}\\). However, all that this function does is to translate all variables into variables of the systems form and then calls the method explained above.\nIn any case, make_conditions should be seen as a utility function with the main funcionality being dependent on correct implementation of Q, &, |, and ! as explained above.\n\n\n\n\n\n\n\nmake_condition\n\n\n\n\n\nmake_condition(s::String)\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int})\nMake a transmission condition, i.e. Q(b), out of a string.\nTransmission channels are described using Boolean statements involving the variables in the dynamic model. make_condition allows for specifying these Boolean conditions as a string which is then converted to an internal representation allowing the computation of transmission channels.\nTwo ways of specifying the Boolean conditions exist:\n\nmake_condition(s::String) takes the Boolean condition in the systems form of Wegner et al (2024), i.e. variables must start with x followed by a number. For example, given a three variable VAR(1), y_{1,t} -&gt; x_1, y_{2, t} -&gt; x_2, y_{3, t} -&gt; x_3, y_{1, t+1} -&gt; x_4, y_{2, t+1} -&gt; x_5, … Boolean statements then involve expressions in the x variables and define which paths can be taken. Each path involved in the transmission mechanism must satisfy the Boolean statement.\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int}) does the same as the first method, however the Boolean condition can be specified using the variables of the dynamic systems, i.e. y. Variables must then be specified using y_{i,t} where i is the variable number and t is the period. At all times t &gt;= 0 with 0 denoting the contemporaneous horizon.\n\n\n\n\ns::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.\n\n\n\n\n\nReturns a transmission condition. See also Q.\n\n\n\n\ns = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)\n\n\n\n\nBoolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#arguments-3",
    "href": "documentation/julia/internals.html#arguments-3",
    "title": "Internals",
    "section": "",
    "text": "s::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#returns-2",
    "href": "documentation/julia/internals.html#returns-2",
    "title": "Internals",
    "section": "",
    "text": "Returns a transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#exajuliaes-2",
    "href": "documentation/julia/internals.html#exajuliaes-2",
    "title": "Internals",
    "section": "",
    "text": "s = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/julia/internals.html#notes-1",
    "href": "documentation/julia/internals.html#notes-1",
    "title": "Internals",
    "section": "",
    "text": "Boolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Home",
      "Julia",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeConditionY.html",
    "href": "documentation/matlab/all-functions/makeConditionY.html",
    "title": "makeConditionY",
    "section": "",
    "text": "makeConditionY\n\n\n\n\n\nmakeConditionY Create a transmission condition from a Boolean string using dyanmic form variables.\nq = makeConditionY(strY, order) constructs a transmission condition \\(Q(b)\\) from a Boolean statement specified in terms of dynamic system variables (i.e., y_{i,t} notation).\n\n\n\nstrY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.\n\n\n\n\n\nq (Q): A transmission condition object.\n\n\n\n\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeConditionY"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeConditionY.html#arguments",
    "href": "documentation/matlab/all-functions/makeConditionY.html#arguments",
    "title": "makeConditionY",
    "section": "",
    "text": "strY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeConditionY"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeConditionY.html#returns",
    "href": "documentation/matlab/all-functions/makeConditionY.html#returns",
    "title": "makeConditionY",
    "section": "",
    "text": "q (Q): A transmission condition object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeConditionY"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeConditionY.html#example",
    "href": "documentation/matlab/all-functions/makeConditionY.html#example",
    "title": "makeConditionY",
    "section": "",
    "text": "s_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeConditionY"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeConditionY.html#notes",
    "href": "documentation/matlab/all-functions/makeConditionY.html#notes",
    "title": "makeConditionY",
    "section": "",
    "text": "Boolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeConditionY"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/InternalInstrument.html",
    "href": "documentation/matlab/all-functions/InternalInstrument.html",
    "title": "InternalInstrument",
    "section": "",
    "text": "InternalInstrument\n\n\n\n\n\nInternalInstrument Identify IRFs using internal instruments.\nThis class identifies impulse responses in (S)VARs using the internal instruments method proposed by Plagborg-Moller and Wolf (2021).\n\n\n\nIRFs are computed from Cholesky-orthogonalized shocks with respect to the selected instrument.\nShocks are normalized by the response of the normalisingVariable at normalisingHorizon.\nThe instrument can be specified as an integer (index) or character (variable name).\nDefaults:\ninstrument = 1 (first variable)\nnormalisingHorizon = 0\n\n\n\n\n\nPlagborg-Moller, M., & Wolf, C. K. (2021). “Local Projections and VARs Estimate the Same Impulse Responses.” Econometrica, 89(2), 955-980. [https://doi.org/10.3982/ecta17813]\n\nSee also IdentificationMethod, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "InternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/InternalInstrument.html#notes",
    "href": "documentation/matlab/all-functions/InternalInstrument.html#notes",
    "title": "InternalInstrument",
    "section": "",
    "text": "IRFs are computed from Cholesky-orthogonalized shocks with respect to the selected instrument.\nShocks are normalized by the response of the normalisingVariable at normalisingHorizon.\nThe instrument can be specified as an integer (index) or character (variable name).\nDefaults:\ninstrument = 1 (first variable)\nnormalisingHorizon = 0",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "InternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/InternalInstrument.html#reference",
    "href": "documentation/matlab/all-functions/InternalInstrument.html#reference",
    "title": "InternalInstrument",
    "section": "",
    "text": "Plagborg-Moller, M., & Wolf, C. K. (2021). “Local Projections and VARs Estimate the Same Impulse Responses.” Econometrica, 89(2), 955-980. [https://doi.org/10.3982/ecta17813]\n\nSee also IdentificationMethod, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "InternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionIrfs.html",
    "href": "documentation/matlab/all-functions/transmissionIrfs.html",
    "title": "transmissionIrfs",
    "section": "",
    "text": "transmissionIrfs\n\n\n\n\n\ntransmissionIrfs Compute the transmission effect using the IRF method.\neffects = transmissionIrfs(from, irfs, irfsOrtho, varAnd, varNot, multiplier) calculates the transmission effect using impulse response functions (IRFs).\nArguments: - from (integer): Index of the shock. - irfs (matrix): Structural impulse responses (only the one of the from shock is needed). Must be a matrix which can be obtained from toTransmissionIrfs. - irfsOrtho (matrix): Cholesky IRFs that must use the ordering defined in the transmission matrix. Must be a matrix which can be obtained from toTransmissionIrfs. - varAnd (vector of integers): Indices of variables that must be included (AND conditions). Can be obtained from getVarNumsAndMultiplier. - varNot (vector of integers): Indices of variables that must be excluded (NOT conditions). Can be obtained from getVarNumsAndMultiplier. - multiplier (number): Multiplier associated with each term. Can be obtained from getVarNumsAndMultiplier.\n\n\n\neffects (vector): A vector where entry i corresponds to the transmission effect on variable x_i.\n\n\n\n\nk = 6;\nh = 3;\ns = \"x1\";\ncond = makeCondition(s);\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionIrfs(1, irfs, irfsOrtho, varAnd{1}, varNot{1}, multiplier);\n\n\n\nInternal function. Should not be called by users directly.\nSee also transmission, getVarNumsAndMultiplier, makeCondition, through, notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionIrfs.html#returns",
    "href": "documentation/matlab/all-functions/transmissionIrfs.html#returns",
    "title": "transmissionIrfs",
    "section": "",
    "text": "effects (vector): A vector where entry i corresponds to the transmission effect on variable x_i.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionIrfs.html#example",
    "href": "documentation/matlab/all-functions/transmissionIrfs.html#example",
    "title": "transmissionIrfs",
    "section": "",
    "text": "k = 6;\nh = 3;\ns = \"x1\";\ncond = makeCondition(s);\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionIrfs(1, irfs, irfsOrtho, varAnd{1}, varNot{1}, multiplier);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionIrfs.html#warning",
    "href": "documentation/matlab/all-functions/transmissionIrfs.html#warning",
    "title": "transmissionIrfs",
    "section": "",
    "text": "Internal function. Should not be called by users directly.\nSee also transmission, getVarNumsAndMultiplier, makeCondition, through, notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/calculateQAndOnly.html",
    "href": "documentation/matlab/all-functions/calculateQAndOnly.html",
    "title": "calculateQAndOnly",
    "section": "",
    "text": "calculateQAndOnly\n\n\n\n\n\ncalculateQAndOnly Compute the transmission effect of a condition with only ANDs.\nresult = calculateQAndOnly(from, irfs, irfsOrtho, vars, multiplier) calculates the transmission effect of a transmission condition/query that involves only AND operations.\n\n\n\nfrom (integer): Index of the shock.\nirfs (matrix): IRFs in transmission form. See also toTransmissionIrfs.\nirfsOrtho (matrix): Orthogonalized / Cholesky IRFs in transmission form. See also toTransmissionIrfs.\nvars (vector of integers): Indices of variables involved in the condition.\nmultiplier (number): Multiplier.\n\n\n\n\n\nresult (vector): A vector where entry i corresponds to the transmission effect on variable x_i.\n\n\n\n\n\nThis function is intended for internal use only.\n\nSee also toTransmissionIrfs",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "calculateQAndOnly"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/calculateQAndOnly.html#arguments",
    "href": "documentation/matlab/all-functions/calculateQAndOnly.html#arguments",
    "title": "calculateQAndOnly",
    "section": "",
    "text": "from (integer): Index of the shock.\nirfs (matrix): IRFs in transmission form. See also toTransmissionIrfs.\nirfsOrtho (matrix): Orthogonalized / Cholesky IRFs in transmission form. See also toTransmissionIrfs.\nvars (vector of integers): Indices of variables involved in the condition.\nmultiplier (number): Multiplier.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "calculateQAndOnly"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/calculateQAndOnly.html#returns",
    "href": "documentation/matlab/all-functions/calculateQAndOnly.html#returns",
    "title": "calculateQAndOnly",
    "section": "",
    "text": "result (vector): A vector where entry i corresponds to the transmission effect on variable x_i.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "calculateQAndOnly"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/calculateQAndOnly.html#notes",
    "href": "documentation/matlab/all-functions/calculateQAndOnly.html#notes",
    "title": "calculateQAndOnly",
    "section": "",
    "text": "This function is intended for internal use only.\n\nSee also toTransmissionIrfs",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "calculateQAndOnly"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html",
    "href": "documentation/matlab/all-functions/Q.html",
    "title": "Q",
    "section": "",
    "text": "Q\n\n\n\n\n\nQ Represents a transmission condition.\nThe Q class is used to define transmission conditions based on Boolean statements. A transmission condition is denoted as \\(Q(b)\\), where \\(b\\) is a Boolean statement involving variables x&lt;num&gt;, such as x1, x2, etc. Boolean statements should only contain AND (&) and NOT (!) operations.\n\n\n\nvars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.\n\n\n\n\n\nQ: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.\n\n\n\n\n% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);\n\n\n\n\nThe recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#properties",
    "href": "documentation/matlab/all-functions/Q.html#properties",
    "title": "Q",
    "section": "",
    "text": "vars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#methods",
    "href": "documentation/matlab/all-functions/Q.html#methods",
    "title": "Q",
    "section": "",
    "text": "Q: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#usage",
    "href": "documentation/matlab/all-functions/Q.html#usage",
    "title": "Q",
    "section": "",
    "text": "% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#notes",
    "href": "documentation/matlab/all-functions/Q.html#notes",
    "title": "Q",
    "section": "",
    "text": "The recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#arguments",
    "href": "documentation/matlab/all-functions/Q.html#arguments",
    "title": "Q",
    "section": "Arguments",
    "text": "Arguments\n\nvars (string, cell array of strings, or integer): The variable(s) in the Boolean condition. Must be formatted as x&lt;num&gt;.\nmultiplier (number or vector): Multiplier(s) associated with each term.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#returns",
    "href": "documentation/matlab/all-functions/Q.html#returns",
    "title": "Q",
    "section": "Returns",
    "text": "Returns\n\nobj (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#example",
    "href": "documentation/matlab/all-functions/Q.html#example",
    "title": "Q",
    "section": "Example",
    "text": "Example\nq = Q('x1');            % Single variable\nq = Q({'x1', 'x2'}, [1, -1]);  % Multiple variables with multipliers",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#notes-1",
    "href": "documentation/matlab/all-functions/Q.html#notes-1",
    "title": "Q",
    "section": "Notes",
    "text": "Notes\n\nThe recommended way to define a variable is using Q(i), where i is an integer representing a variable index.\nUsers should not directly specify OR (|) inside the variable strings.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#arguments-1",
    "href": "documentation/matlab/all-functions/Q.html#arguments-1",
    "title": "Q",
    "section": "Arguments",
    "text": "Arguments\n\nobj1 (Q): First transmission condition.\nobj2 (Q): Second transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#returns-1",
    "href": "documentation/matlab/all-functions/Q.html#returns-1",
    "title": "Q",
    "section": "Returns",
    "text": "Returns\n\nresult (Q): The combined transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#example-1",
    "href": "documentation/matlab/all-functions/Q.html#example-1",
    "title": "Q",
    "section": "Example",
    "text": "Example\nq1 = Q(1);\nq2 = Q(2);\nq = q1 | q2;\nSee also and (&), not (~)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#arguments-2",
    "href": "documentation/matlab/all-functions/Q.html#arguments-2",
    "title": "Q",
    "section": "Arguments",
    "text": "Arguments\n\nobj (Q): A transmission condition to negate.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#returns-2",
    "href": "documentation/matlab/all-functions/Q.html#returns-2",
    "title": "Q",
    "section": "Returns",
    "text": "Returns\n\nresult (Q): The negated transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#example-2",
    "href": "documentation/matlab/all-functions/Q.html#example-2",
    "title": "Q",
    "section": "Example",
    "text": "Example\nq1 = Q(1);\nq = ~q1;",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#notes-2",
    "href": "documentation/matlab/all-functions/Q.html#notes-2",
    "title": "Q",
    "section": "Notes",
    "text": "Notes\n\nIf the condition consists of a single variable, it is simply negated.\nIf the condition is more complex, an auxiliary \"T\" (true) condition is used and the returned condition is equivalent to \\(Q(T) - Q(b)\\) where \\(b\\) is the origional Boolean condition.\n\nSee also and (&), or (|)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#arguments-3",
    "href": "documentation/matlab/all-functions/Q.html#arguments-3",
    "title": "Q",
    "section": "Arguments",
    "text": "Arguments\n\nobj1 (Q): First transmission condition.\nobj2(Q): Second transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#returns-3",
    "href": "documentation/matlab/all-functions/Q.html#returns-3",
    "title": "Q",
    "section": "Returns",
    "text": "Returns\n\nresult(Q): The combined transmission condition.\n\nExample:\nq1 = Q(1);\nq2 = Q(2);\nq = q1 & q2;  % Returns Q(\"x2 & x1\")\nSee also or (|), not (~)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#arguments-4",
    "href": "documentation/matlab/all-functions/Q.html#arguments-4",
    "title": "Q",
    "section": "Arguments",
    "text": "Arguments\n\nq (Q): A transmission condition.\norder (vector of integers, optional): The variable ordering defined by the transmission matrix. If provided, the condition is displayed using the dynamic form notation.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Q.html#example-3",
    "href": "documentation/matlab/all-functions/Q.html#example-3",
    "title": "Q",
    "section": "Example",
    "text": "Example\nq = makeCondition(\"x1 | x2\");\n\ndisp(q); % Displays condition in systems form.\n\norder = [3, 1, 2];\ndisp(q, order); % Displays condition in dynamic form.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Q"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyNotToB.html",
    "href": "documentation/matlab/all-functions/applyNotToB.html",
    "title": "applyNotToB",
    "section": "",
    "text": "applyNotToB\n\n\n\n\n\napplyNotToB Manipulate B and Omega to ensure var lies on no paths.\napplyNotToB(B, Omega, from, var) modifies the matrices B and Omega such that the variable indexed by var is absent from all paths. This is achieved by: - Zeroing out the edge from the shock (indexed by from) to var. - Zeroing out all edges from variables ordered before var to var.\n\n\n\nB (matrix): Part of the systems form.\nOmega (matrix): Part of the systems form.\nfrom (integer): The shock index.\nvar (integer): The variable index that cannot lie on any paths.\n\n\n\n\n\nThis function is intended for internal use only.\n\nSee also applyAndToB, makeB, makeOmega, and makeSystemsForms.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyNotToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyNotToB.html#arguments",
    "href": "documentation/matlab/all-functions/applyNotToB.html#arguments",
    "title": "applyNotToB",
    "section": "",
    "text": "B (matrix): Part of the systems form.\nOmega (matrix): Part of the systems form.\nfrom (integer): The shock index.\nvar (integer): The variable index that cannot lie on any paths.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyNotToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyNotToB.html#notes",
    "href": "documentation/matlab/all-functions/applyNotToB.html#notes",
    "title": "applyNotToB",
    "section": "",
    "text": "This function is intended for internal use only.\n\nSee also applyAndToB, makeB, makeOmega, and makeSystemsForms.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyNotToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/combinations.html",
    "href": "documentation/matlab/all-functions/combinations.html",
    "title": "combinations",
    "section": "",
    "text": "combinations\n\n\n\n\n\ncombinations Generate all possible subsets of an array.\ncombs = combinations(arr) returns all possible combinations of elements in arr, for subset lengths ranging from 1 to K, where K is the length of arr.\n\n\n\narr (vector): Input array of elements.\n\n\n\n\n\ncombs (cell array): A cell array where each element is a subset of arr with varying lengths (from 1 to length(arr)).\n\n\n\n\narr = [1, 2, 3];\ncombs = combinations(arr);\n% Output:\n%   { [1], [2], [3], [1 2], [1 3], [2 3], [1 2 3] }",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "combinations"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/combinations.html#arguments",
    "href": "documentation/matlab/all-functions/combinations.html#arguments",
    "title": "combinations",
    "section": "",
    "text": "arr (vector): Input array of elements.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "combinations"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/combinations.html#returns",
    "href": "documentation/matlab/all-functions/combinations.html#returns",
    "title": "combinations",
    "section": "",
    "text": "combs (cell array): A cell array where each element is a subset of arr with varying lengths (from 1 to length(arr)).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "combinations"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/combinations.html#example",
    "href": "documentation/matlab/all-functions/combinations.html#example",
    "title": "combinations",
    "section": "",
    "text": "arr = [1, 2, 3];\ncombs = combinations(arr);\n% Output:\n%   { [1], [2], [3], [1 2], [1 3], [2 3], [1 2 3] }",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "combinations"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/through.html",
    "href": "documentation/matlab/all-functions/through.html",
    "title": "through",
    "section": "",
    "text": "through\n\n\n\n\n\nthrough Construct a transmission condition enforcing paths through specific variables.\nq = through(idx, horizons, order) creates a transmission condition Q where paths must pass through the variables specified in idx. The variable indices refer to their positions in the original dynamic system (e.g., in the SVARMA model), before applying the transmission matrix.\n\n\nFor a single variable:\n\nidx (integer): Index of the variable that paths must go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths must pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths must go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\n\n\n\n\nq (Q): A transmission condition.\n\n\n\n\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.\n\n\n\n\n% Contemporaneous channel (Section 5.1 in Wegner)\ncontemporaneous_channel = through(1, [0], 1:4);\n\n% Effect through the federal funds rate in the first two periods\nq = through(1, [0, 1], 1:4);\n\n% Effect through both the federal funds rate and output gap\nq = through([1, 2], {[0, 1], [0, 1]}, 1:4);\n\n% Adjusting for a re-ordered system where the output gap comes first\nq = through([1, 2], {[0, 1], [0, 1]}, [2, 1, 3, 4]);\nSee also notThrough, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/through.html#arguments",
    "href": "documentation/matlab/all-functions/through.html#arguments",
    "title": "through",
    "section": "",
    "text": "For a single variable:\n\nidx (integer): Index of the variable that paths must go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths must pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths must go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/through.html#returns",
    "href": "documentation/matlab/all-functions/through.html#returns",
    "title": "through",
    "section": "",
    "text": "q (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/through.html#notes",
    "href": "documentation/matlab/all-functions/through.html#notes",
    "title": "through",
    "section": "",
    "text": "The resulting transmission condition can be used in transmission to compute the transmission effect.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/through.html#example",
    "href": "documentation/matlab/all-functions/through.html#example",
    "title": "through",
    "section": "",
    "text": "% Contemporaneous channel (Section 5.1 in Wegner)\ncontemporaneous_channel = through(1, [0], 1:4);\n\n% Effect through the federal funds rate in the first two periods\nq = through(1, [0, 1], 1:4);\n\n% Effect through both the federal funds rate and output gap\nq = through([1, 2], {[0, 1], [0, 1]}, 1:4);\n\n% Adjusting for a re-ordered system where the output gap comes first\nq = through([1, 2], {[0, 1], [0, 1]}, [2, 1, 3, 4]);\nSee also notThrough, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html",
    "href": "documentation/matlab/all-functions/LP.html",
    "title": "LP",
    "section": "",
    "text": "LP\n\n\n\n\n\nLP Local Projection (LP) model for estimating IRFs.\nLocal Projection (LP) model for estimating impulse response functions (IRFs) in a flexible and semi-parametric manner.\nEach LP regression estimates the dynamic response of an outcome variable at future horizon h to a one-period change in a treatment variable at time t, controlling for contemporaneous and lagged covariates.\nThe regression model is specified as:\nw_{i,t+h} = \\mu_{i,h} + \\theta_{i,h} x_t + \\gamma_{i,h}' r_t +\n\\sum_{l=1}^p \\delta_{i,h,l} w_{t-l} + \\xi_{i,h,t}\nwhere w_t = (r_t', x_t, q_t') and: - x_t is the treatment variable - r_t contains contemporaneous controls (all variables before x_t) - p is the number of lags included - \\theta_{i,h} is the relative IRF of x_t on the i-th variable at horizon h.\nThe treatment variable may be endogenous. Structural interpretation of IRFs can be achieved using valid instruments—see ExternalInstrument for one such method. If the treatment satisfies a conditional ignorability assumption (a recursive assumption in macro), then the coefficient has a structural interpretation even without the use of instruments. For this to hold, x_t - E(x_t|r_t, w_{t-1}, ..., w_{t-p}) must be equal to the structural shock.\n\n\n\ndata (table or matrix): Input time series dataset.\ntreatment (char or integer): Treatment variable.\np (integer): Number of lags.\nhorizons (vector): Forecast horizons for projections.\nincludeConstant (logical): Whether to include an intercept.\nB (array): Coefficient estimates per horizon.\nY (array): Dependent variables per horizon.\nX (matrix): Common regressor matrix.\nU (array): Residuals per horizon.\nYhat (array): Fitted values per horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#properties",
    "href": "documentation/matlab/all-functions/LP.html#properties",
    "title": "LP",
    "section": "",
    "text": "data (table or matrix): Input time series dataset.\ntreatment (char or integer): Treatment variable.\np (integer): Number of lags.\nhorizons (vector): Forecast horizons for projections.\nincludeConstant (logical): Whether to include an intercept.\nB (array): Coefficient estimates per horizon.\nY (array): Dependent variables per horizon.\nX (matrix): Common regressor matrix.\nU (array): Residuals per horizon.\nYhat (array): Fitted values per horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments",
    "href": "documentation/matlab/all-functions/LP.html#arguments",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\ndata (matrix or table): Input time series dataset.\ntreatment (char or int): Treatment variable.\np (int): Lag length.\nhorizons (vector): Forecast horizons.\nvarargin: Name-value pairs for options:\nincludeConstant (logical): Include constant column in X (Default is true).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns",
    "href": "documentation/matlab/all-functions/LP.html#returns",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nX (matrix): Common regressor matrix for all horizons.\nY (3D array): Outcome variables stacked over horizons (along the third dimension).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#notes",
    "href": "documentation/matlab/all-functions/LP.html#notes",
    "title": "LP",
    "section": "Notes",
    "text": "Notes\n\nX is structured as [deterministic contemporaneous treatment lagged]\nY stacks future outcomes across selected horizons along the third dimension.\nShape of Y: (observations, variables, horizons).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#details",
    "href": "documentation/matlab/all-functions/LP.html#details",
    "title": "LP",
    "section": "Details",
    "text": "Details\n\nAll variables ordered before the treatment in data are included as contemporaneous controls.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-1",
    "href": "documentation/matlab/all-functions/LP.html#arguments-1",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-1",
    "href": "documentation/matlab/all-functions/LP.html#returns-1",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nYhat (3D array): Fitted values with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also residuals, coeffs, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-2",
    "href": "documentation/matlab/all-functions/LP.html#arguments-2",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\ndata (matrix or table): Input time series dataset.\ntreatment (char or int): Treatment variable.\np (integer): Lag length.\nhorizons (vector): Forecast horizons.\nvarargin: Name-value pairs for options:\nincludeConstant (logical): Include constant in regressors (Defaults to true).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-3",
    "href": "documentation/matlab/all-functions/LP.html#arguments-3",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-2",
    "href": "documentation/matlab/all-functions/LP.html#returns-2",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Selected shock.\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#notes-1",
    "href": "documentation/matlab/all-functions/LP.html#notes-1",
    "title": "LP",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, the LP model is refitted.\n\nSee also LP.through, LP.notThrough, LP.IRF",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-4",
    "href": "documentation/matlab/all-functions/LP.html#arguments-4",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nidentificationMethod (object, optional): Identification method. Must be of type IdentificationMethod. Defaults to Recursive.\n\nSee also coeffs, fitted, residuals, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-5",
    "href": "documentation/matlab/all-functions/LP.html#arguments-5",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nexcludeDeterministic (logical, optional): If true, excludes constant terms from the coefficients. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-3",
    "href": "documentation/matlab/all-functions/LP.html#returns-3",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nB (3D array): Coefficients array with dimensions:\nFirst dimension: Outcome variable.\nSecond dimension: Regressors.\nThird dimension: Horizon.\n\nSee also fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-6",
    "href": "documentation/matlab/all-functions/LP.html#arguments-6",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-4",
    "href": "documentation/matlab/all-functions/LP.html#returns-4",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nU (3D array): Residuals with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also fitted, coeffs, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-7",
    "href": "documentation/matlab/all-functions/LP.html#arguments-7",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nidentificationMethod (IdentificationMethod, optional): Identification method. Defaults to Recursive.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-5",
    "href": "documentation/matlab/all-functions/LP.html#returns-5",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (LP): Best fitting LP model.\nicTable (table): Table of lag lengths and IC values.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#notes-2",
    "href": "documentation/matlab/all-functions/LP.html#notes-2",
    "title": "LP",
    "section": "Notes",
    "text": "Notes\n\nMaximum lag length considered is the lag length of obj.\n\nSee also fit, VAR.fitAndSelect, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#arguments-8",
    "href": "documentation/matlab/all-functions/LP.html#arguments-8",
    "title": "LP",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nmaxHorizon (integer): Maximum forecast horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#returns-6",
    "href": "documentation/matlab/all-functions/LP.html#returns-6",
    "title": "LP",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/LP.html#notes-3",
    "href": "documentation/matlab/all-functions/LP.html#notes-3",
    "title": "LP",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, LP is refitted first.\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Shocks.\nThird dimension: Horizon.\n\nSee also fit, IRFContainer",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/IRFContainer.html",
    "href": "documentation/matlab/all-functions/IRFContainer.html",
    "title": "IRFContainer",
    "section": "",
    "text": "IRFContainer\n\n\n\n\n\nIRFContainer Container for storing impulse response functions.\nThis class holds IRFs, variable names, the originating model, and the identification method used (if any).\n\n\n\nirfs (3D array): IRFs with dimensions:\nFirst: Response variable.\nSecond: Shock.\nThird: Horizon.\nvarnames (cell array): Names of response variables.\nmodel (Model): Model used to compute the IRFs.\nidentificationMethod (IdentificationMethod):\nIdentification method if the model is reduced form.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "IRFContainer"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/IRFContainer.html#properties",
    "href": "documentation/matlab/all-functions/IRFContainer.html#properties",
    "title": "IRFContainer",
    "section": "",
    "text": "irfs (3D array): IRFs with dimensions:\nFirst: Response variable.\nSecond: Shock.\nThird: Horizon.\nvarnames (cell array): Names of response variables.\nmodel (Model): Model used to compute the IRFs.\nidentificationMethod (IdentificationMethod):\nIdentification method if the model is reduced form.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "IRFContainer"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Recursive.html",
    "href": "documentation/matlab/all-functions/Recursive.html",
    "title": "Recursive",
    "section": "",
    "text": "Recursive\n\n\n\n\n\nRecursive Identify reduced-form models using recursivity.\nThis class implements identification under a recursive (Cholesky) structure, assuming conditional ignorability.\n\n\n\nFor SVARs, this corresponds to Cholesky identification.\nFor LPs, it assumes conditioning on prior ordered variables.\nCommonly used in macroeconomics when contemporaneous shocks are assumed to have a lower triangular impact.\n\nSee also IdentificationMethod, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Recursive"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Recursive.html#notes",
    "href": "documentation/matlab/all-functions/Recursive.html#notes",
    "title": "Recursive",
    "section": "",
    "text": "For SVARs, this corresponds to Cholesky identification.\nFor LPs, it assumes conditioning on prior ordered variables.\nCommonly used in macroeconomics when contemporaneous shocks are assumed to have a lower triangular impact.\n\nSee also IdentificationMethod, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Recursive"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html",
    "href": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html",
    "title": "getVarNumsAndMultiplier",
    "section": "",
    "text": "getVarNumsAndMultiplier\n\n\n\n\n\ngetVarNumsAndMultiplier Extract AND and NOT expressions from a transmission condition.\n[andNums, andNotNums, multiplier] = getVarNumsAndMultiplier(q) extracts the AND and NOT expressions from a transmission condition and returns the corresponding variable numbers. It also returns the multiplier for each term.\nA valid transmission condition consists of terms that involve only AND and NOT expressions. For each term, the AND and NOT expressions are collected, and vectors of the respective variable numbers are returned.\n\n\n\nq (Q): A transmission condition. See also Q.\n\n\n\n\n\nandNums (cell array of vectors): Each cell contains a vector of variable numbers included via AND in the term.\nandNotNums (cell array of vectors): Each cell contains a vector of variable numbers included via NOT in the term.\nmultiplier (vector of numbers): Contains the multiplier for each term.\n\n##Example\nq = Q({\"x1\", \"!x2\", \"x1 & !x2\"}, [1, 2, 3]);\n[andNums, andNotNums, multiplier] = getVarNumsAndMultiplier(q);\n% Output:\n% andNums = { [1], [], [1] }\n% andNotNums = { [], [2], [2] }\n% multiplier = [1, 2, 3]\nSee also Q",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "getVarNumsAndMultiplier"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html#arguments",
    "href": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html#arguments",
    "title": "getVarNumsAndMultiplier",
    "section": "",
    "text": "q (Q): A transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "getVarNumsAndMultiplier"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html#returns",
    "href": "documentation/matlab/all-functions/getVarNumsAndMultiplier.html#returns",
    "title": "getVarNumsAndMultiplier",
    "section": "",
    "text": "andNums (cell array of vectors): Each cell contains a vector of variable numbers included via AND in the term.\nandNotNums (cell array of vectors): Each cell contains a vector of variable numbers included via NOT in the term.\nmultiplier (vector of numbers): Contains the multiplier for each term.\n\n##Example\nq = Q({\"x1\", \"!x2\", \"x1 & !x2\"}, [1, 2, 3]);\n[andNums, andNotNums, multiplier] = getVarNumsAndMultiplier(q);\n% Output:\n% andNums = { [1], [], [1] }\n% andNotNums = { [], [2], [2] }\n% multiplier = [1, 2, 3]\nSee also Q",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "getVarNumsAndMultiplier"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/removeContradictions.html",
    "href": "documentation/matlab/all-functions/removeContradictions.html",
    "title": "removeContradictions",
    "section": "",
    "text": "removeContradictions\n\n\n\n\n\nremoveContradictions Remove contradicting terms from a transmission condition.\nq = removeContradictions(q) removes terms that contain contradictions of the form x_i & !x_i, which always evaluate to false and contribute zero to the transmission effect. Behaviour of the function can be changed by setting REMOVECONTRADICTIONS=false locally.\nArguments: - q (Q): A transmission condition. See also Q and makeCondition.\nReturns: - If REMOVECONTRADICTIONS is set to false, the input q is returned unchanged. - If REMOVECONTRADICTIONS is true or not set: 1. If all terms are contradicting, Q(\"T\", 0) is returned, which represents a transmission effect of zero. 2. If some terms are non-contradicting, only the non-contradicting terms are retained in the output.\n\n\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.\n\n\n\n\nIf REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "removeContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/removeContradictions.html#example",
    "href": "documentation/matlab/all-functions/removeContradictions.html#example",
    "title": "removeContradictions",
    "section": "",
    "text": "setRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "removeContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/removeContradictions.html#notes",
    "href": "documentation/matlab/all-functions/removeContradictions.html#notes",
    "title": "removeContradictions",
    "section": "",
    "text": "If REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "removeContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/ExternalInstrument.html",
    "href": "documentation/matlab/all-functions/ExternalInstrument.html",
    "title": "ExternalInstrument",
    "section": "",
    "text": "ExternalInstrument\n\n\n\n\n\nExternalInstrument Identify IRFs using external instruments.\nThis class identifies structural IRFs from (S)VARs using the external instrument approach proposed by Stock and Watson (2018).\n\n\n\nIRFs are computed relative to the reaction of the treatment variable at normalisingHorizon.\ninstruments must be a matrix or table spanning the same period as the model data.\nDefaults:\nnormalisingHorizon = 0\n\n\n\n\n\nStock, J. H., & Watson, M. W. (2018). “Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments.” The Economic Journal, 128(610), 917-948. [https://doi.org/10.1111/ecoj.12593]\n\nSee also IdentificationMethod, Recursive, InternalInstrument",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/ExternalInstrument.html#notes",
    "href": "documentation/matlab/all-functions/ExternalInstrument.html#notes",
    "title": "ExternalInstrument",
    "section": "",
    "text": "IRFs are computed relative to the reaction of the treatment variable at normalisingHorizon.\ninstruments must be a matrix or table spanning the same period as the model data.\nDefaults:\nnormalisingHorizon = 0",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/ExternalInstrument.html#reference",
    "href": "documentation/matlab/all-functions/ExternalInstrument.html#reference",
    "title": "ExternalInstrument",
    "section": "",
    "text": "Stock, J. H., & Watson, M. W. (2018). “Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments.” The Economic Journal, 128(610), 917-948. [https://doi.org/10.1111/ecoj.12593]\n\nSee also IdentificationMethod, Recursive, InternalInstrument",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html",
    "href": "documentation/matlab/all-functions/Model.html",
    "title": "Model",
    "section": "",
    "text": "Model\n\n\n\n\n\nAbstract Model Class",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#arguments",
    "href": "documentation/matlab/all-functions/Model.html#arguments",
    "title": "Model",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): Model object that must implement getVariableNames.\nvars (integer, char, or cell array of char): Variables specified either by their indices or names.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#returns",
    "href": "documentation/matlab/all-functions/Model.html#returns",
    "title": "Model",
    "section": "Returns",
    "text": "Returns\n\nvarsIdx (integer array): Column indices corresponding to the requested variables.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#notes",
    "href": "documentation/matlab/all-functions/Model.html#notes",
    "title": "Model",
    "section": "Notes",
    "text": "Notes\n\nThis function is intended for internal use only.\nIf a variable name does not exist, an error is thrown.\n\nSee also getVariableNames.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#arguments-1",
    "href": "documentation/matlab/all-functions/Model.html#arguments-1",
    "title": "Model",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): Model object that implements vars2idx_.\norder (cell array of char): Ordered list of variable names.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#returns-1",
    "href": "documentation/matlab/all-functions/Model.html#returns-1",
    "title": "Model",
    "section": "Returns",
    "text": "Returns\n\norderIdx (integer array): Ordered indices corresponding to the variable names.\n\nSee also vars2idx_, getVariableNames.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#arguments-2",
    "href": "documentation/matlab/all-functions/Model.html#arguments-2",
    "title": "Model",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): Model object that should have a method isFitted.\n\nSee also isFitted.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#arguments-3",
    "href": "documentation/matlab/all-functions/Model.html#arguments-3",
    "title": "Model",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths cannot go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths cannot pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#returns-2",
    "href": "documentation/matlab/all-functions/Model.html#returns-2",
    "title": "Model",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also through, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#arguments-4",
    "href": "documentation/matlab/all-functions/Model.html#arguments-4",
    "title": "Model",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths must go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths must pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/Model.html#returns-3",
    "href": "documentation/matlab/all-functions/Model.html#returns-3",
    "title": "Model",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also notThrough, transmission.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "Model"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/collectTerms.html",
    "href": "documentation/matlab/all-functions/collectTerms.html",
    "title": "collectTerms",
    "section": "",
    "text": "collectTerms\n\n\n\n\n\ncollectTerms Collect and sum multipliers for identical Boolean terms.\nqOut = collectTerms(q) collects all terms \\(Q(b)\\) where the Boolean statement \\(b\\) is the same and sums their multipliers. The result is a transmission condition where each term appears only once, but with possibly different multipliers (not restricted to ±1).\n\n\n\nq (Q): A transmission condition. See also Q.\n\n\n\n\n\nqOut (Q): A new transmission condition where identical terms have been combined with summed multipliers.\n\n\n\n\nq = Q({\"x1\", \"x1\"}, [1, 1]);\ncollectTerms(q)\n% Output: Q({\"x1\"}, 2)\n\nq = Q({\"x1\", \"T\", \"x1\"}, [1, 1, -1]);\ncollectTerms(q)\n% Output: Q({\"T\"}, 1)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "collectTerms"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/collectTerms.html#arguments",
    "href": "documentation/matlab/all-functions/collectTerms.html#arguments",
    "title": "collectTerms",
    "section": "",
    "text": "q (Q): A transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "collectTerms"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/collectTerms.html#returns",
    "href": "documentation/matlab/all-functions/collectTerms.html#returns",
    "title": "collectTerms",
    "section": "",
    "text": "qOut (Q): A new transmission condition where identical terms have been combined with summed multipliers.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "collectTerms"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/collectTerms.html#example",
    "href": "documentation/matlab/all-functions/collectTerms.html#example",
    "title": "collectTerms",
    "section": "",
    "text": "q = Q({\"x1\", \"x1\"}, [1, 1]);\ncollectTerms(q)\n% Output: Q({\"x1\"}, 2)\n\nq = Q({\"x1\", \"T\", \"x1\"}, [1, 1, -1]);\ncollectTerms(q)\n% Output: Q({\"T\"}, 1)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "collectTerms"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html",
    "href": "documentation/matlab/all-functions/DSGE.html",
    "title": "DSGE",
    "section": "",
    "text": "DSGE\n\n\n\n\n\nDSGE Dynamic Stochastic General Equilibrium (DSGE) model.\nThis class specifies a DSGE model structure. The model must be previously computed using Dynare. It provides access to the Dynare output structures.\n\n\n\nM_ (struct): Model structure returned by Dynare.\noptions_ (struct): Options structure from Dynare.\noo_ (struct): Output structure with results from Dynare.\n\n\n\n\n\nThe model must have already been solved in Dynare.\nThis class serves as a wrapper to interface with Dynare output.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#properties",
    "href": "documentation/matlab/all-functions/DSGE.html#properties",
    "title": "DSGE",
    "section": "",
    "text": "M_ (struct): Model structure returned by Dynare.\noptions_ (struct): Options structure from Dynare.\noo_ (struct): Output structure with results from Dynare.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#notes",
    "href": "documentation/matlab/all-functions/DSGE.html#notes",
    "title": "DSGE",
    "section": "",
    "text": "The model must have already been solved in Dynare.\nThis class serves as a wrapper to interface with Dynare output.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nshockName (string): The name of the shock whose size and index are required.\nM_ (struct): Returned by Dynare.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns",
    "href": "documentation/matlab/all-functions/DSGE.html#returns",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nshockSize (double): The standard deviation of the specified shock.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-1",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-1",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nshock (char or int): Shock name or index.\ncondition (Q): Transmission condition object.\norder (cell array or vector): Variable ordering.\nmaxHorizon (integer): Maximum forecast horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-1",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-1",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables.\nSecond dimension: Selected shock.\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#notes-1",
    "href": "documentation/matlab/all-functions/DSGE.html#notes-1",
    "title": "DSGE",
    "section": "Notes",
    "text": "Notes\n\nshock and order can be provided by name or index.\n\nSee also DSGE.through, DSGE.notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#model-specification",
    "href": "documentation/matlab/all-functions/DSGE.html#model-specification",
    "title": "DSGE",
    "section": "Model Specification",
    "text": "Model Specification\nThe VARMA model is defined as: \\[\ny_t = \\sum_{i=1}^{p} A_i y_{t-i} + \\sum_{j=1}^{q} \\Psi_j u_{t-j} + u_t,\n\\] where: - \\(u_t = \\Phi_0 \\varepsilon_t\\), with \\(\\varepsilon_t\\) being structural shocks.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-2",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-2",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nPhi0 (matrix): Impact matrix linking structural shocks to reduced-form errors.\nAs (cell array): AR coefficient matrices {A_1, A_2, ..., A_p}.\nPsis (cell array): MA coefficient matrices {Psi_1, Psi_2, ..., Psi_q}.\nhorizon (integer): Number of periods for which IRFs are computed. horizon=0 means only contemporaneous impulses are computed which are the same as Phi0.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-2",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-2",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nirfs (3D array): Structural IRFs of size (n, m, horizon+1), where n is the number of endogenous variables, m is the number of shocks, assumed to satisfy m=n. The IRFs capture the dynamic response of each variable to a unit shock over the specified horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-3",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-3",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nvars (vector): A list of observed variable names.\noptions_ (struct): Options structure returned by Dynare.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-3",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-3",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\norder (vector): Indices of vars in the original observed variable list.\n\nSee also transmission, through, notThrough, makeSystemsForm.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-4",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-4",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nshockname (char): Name of the structural shock.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-4",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-4",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nshockSize (number): Standard deviation of the shock.\n\nSee also getVariableIdx, getShockIdx",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-5",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-5",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nvarname (char): Name of the observed variable.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-5",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-5",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nidx (integer): Index of the observed variable.\n\nSee also getShockIdx, getShockSize",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-6",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-6",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nM_ (struct): Model structure returned by Dynare.\noo_ (struct): Output structure returned by Dynare.\noptions_ (struct): Options structure returned by Dynare.\nmaxKappa (integer, optional): Tuning parameter related to maximum AR order via maxArOrder = maxKappa + 1. Defaults to 20.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-6",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-6",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nPhi0 (matrix): Impact matrix linking shocks to reduced-form errors.\nAs (cell array): AR coefficient matrices {A_1, ..., A_p}.\nPsis (cell array): MA coefficient matrices {Psi_1, ..., Psi_q}.\np (integer): Determined autoregressive order.\nq (integer): Determined moving average order.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#methodology",
    "href": "documentation/matlab/all-functions/DSGE.html#methodology",
    "title": "DSGE",
    "section": "Methodology",
    "text": "Methodology\nThe function follows the approach outlined in Morris (2016) and returns a VARMA of the form: \\[\ny_t = \\sum_{i=1}^{p} A_i y_{t-i} + \\sum_{j=1}^{q} \\Psi_j u_{t-j} + u_t,\n\\] where: - \\(u_t = \\Phi_0 \\varepsilon_t\\), with \\(\\varepsilon_t\\) being structural shocks.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#reference",
    "href": "documentation/matlab/all-functions/DSGE.html#reference",
    "title": "DSGE",
    "section": "Reference",
    "text": "Reference\n\nMorris, S. D. (2016). “VARMA representation of DSGE models.” Economics Letters, 138, 30–33. https://doi.org/10.1016/j.econlet.2015.11.027\n\nSee also getABCD_, varmaIrfs_.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-7",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-7",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nshockname (char): Name of the structural shock.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-7",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-7",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nidx (integer): Index of the structural shock.\n\nSee also getVariableIdx, getShockSize",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-8",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-8",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nPhi0 (matrix): Contemporaneous impact effects of structural shocks.\nAs (cell array): Reduced-form AR coefficient matrices.\nPsis (cell array): Reduced-form MA coefficient matrices.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#notes-2",
    "href": "documentation/matlab/all-functions/DSGE.html#notes-2",
    "title": "DSGE",
    "section": "Notes",
    "text": "Notes\n\nInternally calls dynareToVarma_ to extract VARMA form.\nThe method follows Morris (2016) for VARMA approximation.\n\nSee also DSGE.dynareToVarma_",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-8",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-8",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nM_ (struct): Returned by Dynare.\noo_ (struct): Returned by Dynare.\noptions_ (struct): Returned by Dynare.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-9",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-9",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nA (matrix): State transition matrix. See above equation.\nB (matrix): Control input matrix capturing exogenous shocks. See above equation.\nC (matrix): Observation matrix mapping state variables to observed variables. See above equation.\nD (matrix): Observation noise matrix. See above equation.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#notes-3",
    "href": "documentation/matlab/all-functions/DSGE.html#notes-3",
    "title": "DSGE",
    "section": "Notes",
    "text": "Notes\n\nRequires MATLAB’s Control System Toolbox.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#arguments-9",
    "href": "documentation/matlab/all-functions/DSGE.html#arguments-9",
    "title": "DSGE",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nmaxHorizon (integer): Maximum forecast horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#returns-10",
    "href": "documentation/matlab/all-functions/DSGE.html#returns-10",
    "title": "DSGE",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/DSGE.html#notes-4",
    "href": "documentation/matlab/all-functions/DSGE.html#notes-4",
    "title": "DSGE",
    "section": "Notes",
    "text": "Notes\n\nUses VARMA representation for IRF computation.\n\nSee also coeffs, dynareToVarma_, varmaIrfs_",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "DSGE"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/toTransmissionIrfs.html",
    "href": "documentation/matlab/all-functions/toTransmissionIrfs.html",
    "title": "toTransmissionIrfs",
    "section": "",
    "text": "toTransmissionIrfs\n\n\n\n\n\ntoTransmissionIrfs Transform a standard 3D IRF array into a 2D IRF matrix.\nirfs = toTransmissionIrfs(irfs) converts an impulse response function (IRF) array of dimensions (n_variables × n_shocks × n_horizons) into a 2D matrix. The first horizon in the input corresponds to horizon 0.\nArguments: - irfs (3D array): An IRF array of size (n_variables × n_shocks × n_horizons), where: - n_variables is the number of variables, - n_shocks is the number of shocks, - n_horizons is the number of forecast horizons.\n\n\n\nirfs (2D matrix): A transformed IRF matrix of size (n_variables * n_horizons) × (n_variables * n_horizons). This is equivalent to computing \\((I - B)^{-1}Q\\) using the systems form.\n\n\n\n\nirfs3D = rand(4, 2, 10); % Example 3D IRF array with 4 variables, 2 shocks, and 10 horizons\nirfs2D = toTransmissionIrfs(irfs3D);\n\n\n\n\nThe first n_shocks column of the returned matrix are simply the standard slices of the IRF 3D-array stacked vertically. The next n_shocks columns follow the same principle, but with the first n_variables columns being zero because the shocks are time t shocks which cannot affect time t-1 variables.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "toTransmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/toTransmissionIrfs.html#returns",
    "href": "documentation/matlab/all-functions/toTransmissionIrfs.html#returns",
    "title": "toTransmissionIrfs",
    "section": "",
    "text": "irfs (2D matrix): A transformed IRF matrix of size (n_variables * n_horizons) × (n_variables * n_horizons). This is equivalent to computing \\((I - B)^{-1}Q\\) using the systems form.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "toTransmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/toTransmissionIrfs.html#example",
    "href": "documentation/matlab/all-functions/toTransmissionIrfs.html#example",
    "title": "toTransmissionIrfs",
    "section": "",
    "text": "irfs3D = rand(4, 2, 10); % Example 3D IRF array with 4 variables, 2 shocks, and 10 horizons\nirfs2D = toTransmissionIrfs(irfs3D);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "toTransmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/toTransmissionIrfs.html#notes",
    "href": "documentation/matlab/all-functions/toTransmissionIrfs.html#notes",
    "title": "toTransmissionIrfs",
    "section": "",
    "text": "The first n_shocks column of the returned matrix are simply the standard slices of the IRF 3D-array stacked vertically. The next n_shocks columns follow the same principle, but with the first n_variables columns being zero because the shocks are time t shocks which cannot affect time t-1 variables.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "toTransmissionIrfs"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html",
    "href": "documentation/matlab/advanced.html",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "",
    "text": "The Matlab Toolbox for Transmission Channel Analysis provides functions for TCA in Matlab. It is as general as the Julia version and can thus, equally well, handle all kinds of transmission channels. In developing the two packages, we tried to keep the naming conventions as close as possible, with names only being brought into their respective coding styles (Camel Case for Matlab, Snake Case for Julia). Thus, users should find it hopefully easy to use examples and help that are not originally written for Matlab and still be able to apply it in Matlab. Nonetheless, the examples section provides detailed examples using the Matlab toolbox.\nThe rest of this documentation gives an overview of the key functions in the toolbox. We start with simple transmission channels, how they can be defined, and how they can be computed. We then become more and more general and introduce the more advanced methods within the toolbox. These advanced methods allow for the computation of any possible transmission channel.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#defining-simple-transmission-channels",
    "href": "documentation/matlab/advanced.html#defining-simple-transmission-channels",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Defining Simple Transmission Channels",
    "text": "Defining Simple Transmission Channels\nTwo helper functions are provided that allow for the definition of transmission channels without having to use the more advanced methods. These are through and notThrough. As the names hint at, through is used to define a channel that must go through certain variables in certain periods, while notThrough is used to define a transmission channel that cannot go through certain variables in all defined periods.\n\n\n\n\n\n\n\nthrough\n\n\n\n\n\nthrough Construct a transmission condition enforcing paths through specific variables.\nq = through(idx, horizons, order) creates a transmission condition Q where paths must pass through the variables specified in idx. The variable indices refer to their positions in the original dynamic system (e.g., in the SVARMA model), before applying the transmission matrix.\n\nArguments\nFor a single variable:\n\nidx (integer): Index of the variable that paths must go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths must pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths must go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\n\n\nReturns\n\nq (Q): A transmission condition.\n\n\n\nNotes\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.\n\n\n\nExample\n% Contemporaneous channel (Section 5.1 in Wegner)\ncontemporaneous_channel = through(1, [0], 1:4);\n\n% Effect through the federal funds rate in the first two periods\nq = through(1, [0, 1], 1:4);\n\n% Effect through both the federal funds rate and output gap\nq = through([1, 2], {[0, 1], [0, 1]}, 1:4);\n\n% Adjusting for a re-ordered system where the output gap comes first\nq = through([1, 2], {[0, 1], [0, 1]}, [2, 1, 3, 4]);\nSee also notThrough, transmission\n\n\n\n\n\n\n\n\n\n\n\n\nnotThrough\n\n\n\n\n\nnotThrough Construct a transmission condition excluding specific variables from the channel.\nq = notThrough(idx, horizons, order) creates a transmission condition Q where paths cannot pass through specified variables at given time horizons. The variable indices refer to their positions in the original dynamic system (e.g., in the SVARMA model), before applying the transmission matrix.\n\nArguments\nFor a single variable:\n\nidx (integer): Index of the variable that paths cannot go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths cannot pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths cannot go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\n\n\nReturns\n\nq (Q): A transmission condition.\n\n\n\nNotes\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.\n\n\n\nExample\n% Non-contemporaneous monetary policy channel (Section 5.1 in Wegner etal 2024)\nq = notThrough(1, [0], 1:4);\n\n% Anticipation channel of government defense spending (Section 5.2 in Wegner etal 2024)\nq = notThrough(2, 0:20, 1:4);\nSee also through, transmission\n\n\n\n\n\nBoth through and notThrough return a transmission condition Q, which is simply an internal representation of the provided transmission channel (represented as Boolean statements). To double check whether the condition represents the desired channel, simply display the resulting transmission condition using disp. The displayed version uses the systems form and thus uses the variable notation \\(x\\). Alternatively, disp can be called with an additional agrguments, defining the ordering of the transmission matrix. If two arguments are provided, disp will display the transmission condition using the dynamic form – using the variable notation y_{i,t} with i being the variable index before applying the transmission matrix, and t is the time period with t=0 corresponding to the contemporaneous period.\n\n\n\n\n\n\n\nQ.disp\n\n\n\n\n\ndisp Display a transmission condition in either systems form or dynamic form.\ndisp(q) displays the transmission condition using the systems form notation.\ndisp(q, order) displays the transmission condition using the dynamic form notation, where order is the variable ordering defined by the transmission matrix.\n\nArguments\n\nq (Q): A transmission condition.\norder (vector of integers, optional): The variable ordering defined by the transmission matrix. If provided, the condition is displayed using the dynamic form notation.\n\n\n\nExample\nq = makeCondition(\"x1 | x2\");\n\ndisp(q); % Displays condition in systems form.\n\norder = [3, 1, 2];\ndisp(q, order); % Displays condition in dynamic form.\n\n\n\n\n\n\nAdvanced Usage of through and notThrough\nConditions created using through and notThrough can be combined using AND (&), OR (|) and NOT (~)1. Every new combination will return a new condition that combines the previous conditions. The returned conditions can again be combined using AND, OR, and NOT. For example, if q1, q2 and q3 are conditions obtained using through or notThrough, then the following works.\nq1AndQ2 = q1 & q2;\nq1AndNotQ3 = q1 & ~q3;\nq4 = (q1 | q2) & ~q3;\nq5 = q4 | q1;\nThis functionality allows definitions of transmission channels that are not easily defined using through and notThrough. For example, if we were interested in the transmission channel that goes through \\(y_{1,0}\\) OR through \\(y_{1,1}\\), then neither of the helper functions can be used, since neither can handle OR statements. However, we can use Boolean logic and the rules for the manipulation of transmission conditions to define this transmission channel using our helper functions.\nIn most cases, the easiest step is to negate the original condition. The above condition can be succinctly be represented as \\[\ny_{1,0} \\lor y_{1,1}.\n\\] The negated statement is thus \\[\n\\neg y_{1,0} \\land \\neg y_{1,1}.\n\\] This can be defined using notThrough in the following way\nq = notThrough(1, [0,1], 1:n);\nwhere we assumed that the transmission matrix is the identity matrix, implying an ordering 1:n.\nTo obtain the original transmission channel, we can simply negate this condition.\noriginalCondition = ~q;",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments",
    "href": "documentation/matlab/advanced.html#arguments",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\nFor a single variable:\n\nidx (integer): Index of the variable that paths must go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths must pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths must go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns",
    "href": "documentation/matlab/advanced.html#returns",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes",
    "href": "documentation/matlab/advanced.html#notes",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example",
    "href": "documentation/matlab/advanced.html#example",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\n% Contemporaneous channel (Section 5.1 in Wegner)\ncontemporaneous_channel = through(1, [0], 1:4);\n\n% Effect through the federal funds rate in the first two periods\nq = through(1, [0, 1], 1:4);\n\n% Effect through both the federal funds rate and output gap\nq = through([1, 2], {[0, 1], [0, 1]}, 1:4);\n\n% Adjusting for a re-ordered system where the output gap comes first\nq = through([1, 2], {[0, 1], [0, 1]}, [2, 1, 3, 4]);\nSee also notThrough, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-1",
    "href": "documentation/matlab/advanced.html#arguments-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\nFor a single variable:\n\nidx (integer): Index of the variable that paths cannot go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths cannot pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths cannot go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-1",
    "href": "documentation/matlab/advanced.html#returns-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-1",
    "href": "documentation/matlab/advanced.html#notes-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-1",
    "href": "documentation/matlab/advanced.html#example-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\n% Non-contemporaneous monetary policy channel (Section 5.1 in Wegner etal 2024)\nq = notThrough(1, [0], 1:4);\n\n% Anticipation channel of government defense spending (Section 5.2 in Wegner etal 2024)\nq = notThrough(2, 0:20, 1:4);\nSee also through, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-2",
    "href": "documentation/matlab/advanced.html#arguments-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nq (Q): A transmission condition.\norder (vector of integers, optional): The variable ordering defined by the transmission matrix. If provided, the condition is displayed using the dynamic form notation.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-2",
    "href": "documentation/matlab/advanced.html#example-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\nq = makeCondition(\"x1 | x2\");\n\ndisp(q); % Displays condition in systems form.\n\norder = [3, 1, 2];\ndisp(q, order); % Displays condition in dynamic form.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#defining-complex-transmission-channels",
    "href": "documentation/matlab/advanced.html#defining-complex-transmission-channels",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Defining Complex Transmission Channels",
    "text": "Defining Complex Transmission Channels\nAlthough through and notThrough are sufficient for many situations, it is still sometimes more convenient to directly define the transmission channel as a Boolean condition withough having to refer back to through and notThrough.\nSay, for example, we are again interested in the transmission channel going through y_{1,0} OR y_{1,1}. Instead of using the approach of first negating the statement, then using notThrough, just to negate this statement again, we may as well just define the condition directly using the more advanced functionality of the toolbox.\nThe advanced functionality simply takes a String that defines the transmission channel as a Boolean condition. The string can either be defined using the variables of the dynamic form \\(y\\) or the variables using the systems form \\(x\\). In the former case, the ordering defined by the transmission matrix must also be defined. makeConditionY and makeCondition handle these two cases respectively.\n\n\n\n\n\n\n\nmakeConditionY\n\n\n\n\n\nmakeConditionY Create a transmission condition from a Boolean string using dyanmic form variables.\nq = makeConditionY(strY, order) constructs a transmission condition \\(Q(b)\\) from a Boolean statement specified in terms of dynamic system variables (i.e., y_{i,t} notation).\n\nArguments\n\nstrY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.\n\n\n\nReturns\n\nq (Q): A transmission condition object.\n\n\n\nExample\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);\n\n\nNotes\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition\n\n\n\n\n\n\n\n\n\n\n\n\nmakeCondition\n\n\n\n\n\nmakeCondition Create a transmission condition from a Boolean string.\nq = makeCondition(s) constructs a transmission condition \\(Q(b)\\) from a Boolean statement given as a string. The Boolean expression should use variables of the systems form x&lt;num&gt;, where &lt;num&gt; represents a variable index.\n\nArguments\n\ns (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.\n\n\n\nReturns\n\nq (Q): A transmission condition.\n\n\n\nExample\ns = \"x2 & !x3\";\ncond = makeCondition(s);\n\n\nNotes\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY\n\n\n\n\n\nSo, to define the transmission channel that goes through \\(y_{1,0}\\) OR through \\(y_{1,1}\\) with an identity transmission matrix, we can do either of the following.\n% Note, we assume 4 variables in the system. \nq = makeConditionY(\"y_{1,0} | y_{1,1}\", 1:4);\n% With an identity transmission matrix, y_{1,0} -&gt; x1\n% and y_{1,1} -&gt; x5.\nq = makeCondition(\"x1 | x5\");",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-3",
    "href": "documentation/matlab/advanced.html#arguments-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nstrY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-2",
    "href": "documentation/matlab/advanced.html#returns-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-3",
    "href": "documentation/matlab/advanced.html#example-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-2",
    "href": "documentation/matlab/advanced.html#notes-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-4",
    "href": "documentation/matlab/advanced.html#arguments-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\ns (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-3",
    "href": "documentation/matlab/advanced.html#returns-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-4",
    "href": "documentation/matlab/advanced.html#example-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\ns = \"x2 & !x3\";\ncond = makeCondition(s);",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-3",
    "href": "documentation/matlab/advanced.html#notes-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#computing-transmission-effects",
    "href": "documentation/matlab/advanced.html#computing-transmission-effects",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Computing Transmission Effects",
    "text": "Computing Transmission Effects\nTransmission effects, i.e. the effect through the transmission channel, can be computed in one of two ways. The first way is to use the systems form to compute the transmission effect. The second way exploits the sufficiency of impulse response functions (IRFs)2 and uses these to compute the effects. The following sections describe both methods.\n\nPreparing the Systems Form\nThe systems form can be used whenever a SVAR(MA) was estimated and the AR and MA coefficients are available. The first step then consists of transforming the dynamic form of the SVAR(MA) into the systems form. We provide the utility function makeSystemsForm for this purpose.\n\n\n\n\n\n\n\nmakeSystemsForm\n\n\n\n\n\nmakeSystemsForm Transform an SVARMA dynamic model into the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\nArguments\n\nPhi0 (matrix): The matrix of contemporaneous structural impulse responses.\nAs (cell array of matrices): A vector of reduced-form autoregressive (AR) matrices, where the first entry corresponds to the AR matrix for the first lag, etc.\nPsis (cell array of matrices): A vector of reduced-form moving average (MA) matrices, where the first entry corresponds to the MA matrix for the first lag, etc.\norder (vector): The vector of intergers indicating the order of variables, typically determined by the transmission matrix.\nmaxHorizon (integer): The maximum time horizon to consider for the systems form, with 0 representing the contemporaneous period.\n\n\n\nReturns\n\nB (matrix)\nOmega (matrix)\n\nSee also makeB, makeOmega.\n\n\n\n\n\nThe returned systems form can then be used in transmission to compute the trasnmission effect.\nBesides makeSystemsForm we also offer the two separate functions makeB and makeOmega which respectively create \\(B\\) and \\(\\Omega\\) of the systems form. Use of these two functions should most of the time not be required. However, for users that might want to extend TCA, having access to these two methods seperately can be helpful.\n\n\n\n\n\n\n\nmakeB\n\n\n\n\n\nmakeB Construct the matrix B in the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\nArguments\n\nAs (cell array of matrices): Autoregressive coefficient matrices.\nSigma (matrix): Covariance matrix of the shocks.\norder (vector): Ordering of variables given by the transmission matrix.\nmaxHorizon (integer): Maximum IRF horizon.\n\n\n\nReturns\n\nB (matrix): Part of the sytems representation.\n\nSee also makeOmega, makeSystemsForm\n\n\n\n\n\n\n\n\n\n\n\n\nmakeOmega\n\n\n\n\n\nmakeOmega Construct the Omega matrix in the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\nArguments\n\nPhi0 (matrix): Impact matrix for the shocks.\nPsis (cell array of matrices): MA terms for the dynamic model.\norder (vector): Ordering of variables.\nmaxHorizon (integer): Maximum IRF horizon.\n\n\n\nReturns\n\nOmega (matrix): Part of the systems form.\n\nSee also makeB, makeSystemsForm\n\n\n\n\n\n\n\nPreparing the IRFs\nEstimating the transmission effects using IRFs requires Cholesky / orthogonalised IRFs for all variables, as well as the structural shock’s impulse response functions. In either case, the toolbox works internally with a matrix representation of IRFs. Since many software solutions for SVAR(MA) return IRFs in the form of three-dimensional arrays, we provide the utility function toTransmissionIrfs that transforms the three-dimensional arrays into a matrix of IRFs.\n\n\n\n\n\n\n\ntoTransmissionIrfs\n\n\n\n\n\ntoTransmissionIrfs Transform a standard 3D IRF array into a 2D IRF matrix.\nirfs = toTransmissionIrfs(irfs) converts an impulse response function (IRF) array of dimensions (n_variables × n_shocks × n_horizons) into a 2D matrix. The first horizon in the input corresponds to horizon 0.\nArguments: - irfs (3D array): An IRF array of size (n_variables × n_shocks × n_horizons), where: - n_variables is the number of variables, - n_shocks is the number of shocks, - n_horizons is the number of forecast horizons.\n\nReturns\n\nirfs (2D matrix): A transformed IRF matrix of size (n_variables * n_horizons) × (n_variables * n_horizons). This is equivalent to computing \\((I - B)^{-1}Q\\) using the systems form.\n\n\n\nExample\nirfs3D = rand(4, 2, 10); % Example 3D IRF array with 4 variables, 2 shocks, and 10 horizons\nirfs2D = toTransmissionIrfs(irfs3D);\n\n\nNotes\n\nThe first n_shocks column of the returned matrix are simply the standard slices of the IRF 3D-array stacked vertically. The next n_shocks columns follow the same principle, but with the first n_variables columns being zero because the shocks are time t shocks which cannot affect time t-1 variables.\n\n\n\n\n\n\ntoTransmissionIrfs should be applied to both the Cholesky / orthogonalised and the structural IRFs. The resulting IRFs can then be used in transmission to compute the transmission effects.\n\n\nComputing\nWith either the IRFs or the systems form prepared, transmission effects can be computed using any of the following versions of the transmission function. In either case, the fourth argument to transmission must be a transmission condition that can be obtained in any of the ways described above.\nTo compute transmission effects using the systems form, method should be set equal to \"BOmega\". Similarly, to use IRFs, method should be set equal to \"irfs\".\n\n\n\n\n\n\n\ntransmission\n\n\n\n\n\ntransmission Compute the transmission effect given a transmission condition.\neffects = transmission(from, arr1, arr2, q, method) calculates the transmission effect for a given transmission condition q using either the BOmega method or the irf method. If BOmega is used, then transmission effects will be calculated using the systems form \\(x = Bx + \\Omega\\varepsilon\\)\n\nArguments\n\nfrom (integer): Index of the shock.\narr1 (matrix):\nIf method = \"BOmega\", this must be B from the systems form.\nIf method = \"irf\", this must be structural irfs (technically only those of the shock that is being investigates (from)). Has to be a IRF matrix. See toTransmissionIrfs for more information.\narr2 (matrix):\nIf method = \"BOmega\", this must be Omega from the systems form.\nIf method = \"irf\", this must be irfsOrtho (Cholesky IRFs) following the ordering of the transmission matrix.\nq (Q): A transmission condition. See also Q.\nmethod (string): Specifies the calculation method:\n\"BOmega\" uses the systems form.\n\"irf\" uses only IRFs and can thus be used with local projections.\norder (vector, optional): variable ordering as defined by the transmission matrix.\n\n\n\nReturns:\n\neffects (vector): A vector where entry i corresponds to the transmission effect on variable x_i. If x_k is the variable in the transmission condition with the highest index, all entries in the returned vector with index less than k are NaN, since interpretation of those results is nonsensical.\n\n\n\nExample:\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\neffect = transmission(1, B, Omega, cond, \"BOmega\");\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\neffect = transmission(1, irfs, irfsOrtho, cond, \"irf\");\n\n\nNotes:\n\nIf method = \"BOmega\", the function applies transmissionBOmega.\nIf method = \"irf\", the function applies transmissionIrfs.\nIf order is provided, the returned effects will be a 3D array of dimension (nVariables, 1, horizons) where the variables are in the original ordering (before applying the transmission matrix).\nIf order is not provided, the returned effects will be a (nVariable*horizons, 1) dimensional vector following the ordering after applying the transmission matrix. This is similar to the matrix obtained via \\((I - B)^{-1}\\Omega\\) using the matrices from the systems form.\n\nSee also transmissionBOmega, transmissionIrfs, makeCondition, through, notThrough\n\n\n\n\n\nIt may occur that a transmission condition contains a contradiction, i.e. a part of the boolean conditions says \\(x_i \\land \\neg x_i\\). These are usually automatically removed internally. However, this automatic removal can sometimes lengthen the time it takes for the condition to compile. We therefore offer the possibility not to remove contradictions. To set this alternative option, use setRemoveContradiction. Even if contradictions are not removed, the resulting transmission effect will be correct, but the computation may take a bit longer. Thus, there is a trade-off between longer compile times (if contradictions are being removed) and longer computing time (if contradictions are not removed).\n\n\n\n\n\n\n\nsetRemoveContradictions\n\n\n\n\n\nsetRemoveContradictions Set the global flag for removing contradictions in transmission conditions.\nsetRemoveContradictions(bool) controls whether contradictions in transmission conditions are removed when calling setRemoveContradictions.\n\nArguments\n\nbool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.\n\n\n\nExample\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions\n\n\n\n\n\n\n\n\n\n\n\n\nremoveContradictions\n\n\n\n\n\nremoveContradictions Remove contradicting terms from a transmission condition.\nq = removeContradictions(q) removes terms that contain contradictions of the form x_i & !x_i, which always evaluate to false and contribute zero to the transmission effect. Behaviour of the function can be changed by setting REMOVECONTRADICTIONS=false locally.\nArguments: - q (Q): A transmission condition. See also Q and makeCondition.\nReturns: - If REMOVECONTRADICTIONS is set to false, the input q is returned unchanged. - If REMOVECONTRADICTIONS is true or not set: 1. If all terms are contradicting, Q(\"T\", 0) is returned, which represents a transmission effect of zero. 2. If some terms are non-contradicting, only the non-contradicting terms are retained in the output.\n\nExample\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.\n\n\nNotes\n\nIf REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-5",
    "href": "documentation/matlab/advanced.html#arguments-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nPhi0 (matrix): The matrix of contemporaneous structural impulse responses.\nAs (cell array of matrices): A vector of reduced-form autoregressive (AR) matrices, where the first entry corresponds to the AR matrix for the first lag, etc.\nPsis (cell array of matrices): A vector of reduced-form moving average (MA) matrices, where the first entry corresponds to the MA matrix for the first lag, etc.\norder (vector): The vector of intergers indicating the order of variables, typically determined by the transmission matrix.\nmaxHorizon (integer): The maximum time horizon to consider for the systems form, with 0 representing the contemporaneous period.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-4",
    "href": "documentation/matlab/advanced.html#returns-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nB (matrix)\nOmega (matrix)\n\nSee also makeB, makeOmega.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-6",
    "href": "documentation/matlab/advanced.html#arguments-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nAs (cell array of matrices): Autoregressive coefficient matrices.\nSigma (matrix): Covariance matrix of the shocks.\norder (vector): Ordering of variables given by the transmission matrix.\nmaxHorizon (integer): Maximum IRF horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-5",
    "href": "documentation/matlab/advanced.html#returns-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nB (matrix): Part of the sytems representation.\n\nSee also makeOmega, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-7",
    "href": "documentation/matlab/advanced.html#arguments-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nPhi0 (matrix): Impact matrix for the shocks.\nPsis (cell array of matrices): MA terms for the dynamic model.\norder (vector): Ordering of variables.\nmaxHorizon (integer): Maximum IRF horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-6",
    "href": "documentation/matlab/advanced.html#returns-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nOmega (matrix): Part of the systems form.\n\nSee also makeB, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-7",
    "href": "documentation/matlab/advanced.html#returns-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns",
    "text": "Returns\n\nirfs (2D matrix): A transformed IRF matrix of size (n_variables * n_horizons) × (n_variables * n_horizons). This is equivalent to computing \\((I - B)^{-1}Q\\) using the systems form.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-5",
    "href": "documentation/matlab/advanced.html#example-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\nirfs3D = rand(4, 2, 10); % Example 3D IRF array with 4 variables, 2 shocks, and 10 horizons\nirfs2D = toTransmissionIrfs(irfs3D);",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-4",
    "href": "documentation/matlab/advanced.html#notes-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nThe first n_shocks column of the returned matrix are simply the standard slices of the IRF 3D-array stacked vertically. The next n_shocks columns follow the same principle, but with the first n_variables columns being zero because the shocks are time t shocks which cannot affect time t-1 variables.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-8",
    "href": "documentation/matlab/advanced.html#arguments-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nfrom (integer): Index of the shock.\narr1 (matrix):\nIf method = \"BOmega\", this must be B from the systems form.\nIf method = \"irf\", this must be structural irfs (technically only those of the shock that is being investigates (from)). Has to be a IRF matrix. See toTransmissionIrfs for more information.\narr2 (matrix):\nIf method = \"BOmega\", this must be Omega from the systems form.\nIf method = \"irf\", this must be irfsOrtho (Cholesky IRFs) following the ordering of the transmission matrix.\nq (Q): A transmission condition. See also Q.\nmethod (string): Specifies the calculation method:\n\"BOmega\" uses the systems form.\n\"irf\" uses only IRFs and can thus be used with local projections.\norder (vector, optional): variable ordering as defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#returns-8",
    "href": "documentation/matlab/advanced.html#returns-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Returns:",
    "text": "Returns:\n\neffects (vector): A vector where entry i corresponds to the transmission effect on variable x_i. If x_k is the variable in the transmission condition with the highest index, all entries in the returned vector with index less than k are NaN, since interpretation of those results is nonsensical.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-6",
    "href": "documentation/matlab/advanced.html#example-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example:",
    "text": "Example:\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\neffect = transmission(1, B, Omega, cond, \"BOmega\");\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\neffect = transmission(1, irfs, irfsOrtho, cond, \"irf\");",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-5",
    "href": "documentation/matlab/advanced.html#notes-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes:",
    "text": "Notes:\n\nIf method = \"BOmega\", the function applies transmissionBOmega.\nIf method = \"irf\", the function applies transmissionIrfs.\nIf order is provided, the returned effects will be a 3D array of dimension (nVariables, 1, horizons) where the variables are in the original ordering (before applying the transmission matrix).\nIf order is not provided, the returned effects will be a (nVariable*horizons, 1) dimensional vector following the ordering after applying the transmission matrix. This is similar to the matrix obtained via \\((I - B)^{-1}\\Omega\\) using the matrices from the systems form.\n\nSee also transmissionBOmega, transmissionIrfs, makeCondition, through, notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#arguments-9",
    "href": "documentation/matlab/advanced.html#arguments-9",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Arguments",
    "text": "Arguments\n\nbool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-7",
    "href": "documentation/matlab/advanced.html#example-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#example-8",
    "href": "documentation/matlab/advanced.html#example-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Example",
    "text": "Example\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#notes-6",
    "href": "documentation/matlab/advanced.html#notes-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Notes",
    "text": "Notes\n\nIf REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/advanced.html#footnotes",
    "href": "documentation/matlab/advanced.html#footnotes",
    "title": "Matlab Toolbox for Transmission Channel Analysis – Advanced",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that ~ and ! are both notation for NOT. Matlab uses ~, however we will use these interchangably. If makeCondition use used, either will work. However, if two condition are being combined, only ~ will work, since ! is not defined in Matlab.↩︎\nSee Section 4 in Wegner et al. (2025).↩︎",
    "crumbs": [
      "Home",
      "Matlab",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html",
    "href": "documentation/matlab/index.html",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "",
    "text": "Get the Toolbox\nThe MATLAB Toolbox for Transmission Channel Analysis provides a suite of functions for conducting transmission channel analysis (TCA) in MATLAB. It includes both standard methods—which are sufficient for most users—and more advanced, customisable techniques.\nThis overview focuses on the standard methods. Advanced options are described in the Advanced Section, and implementation details can be found in the Internals Section. For practical demonstrations, see the Examples.\nBefore performing any transmission analysis, add the TCA toolbox to MATLAB’s search path. Update the paths below to match the location of the toolbox on your system:\nA typical transmission channel analysis workflow consists of the following steps:\nThe sections that follow document the functions available for each of these steps.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#defining-and-estimating-a-model.",
    "href": "documentation/matlab/index.html#defining-and-estimating-a-model.",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "1. Defining and estimating a model.",
    "text": "1. Defining and estimating a model.\nThe first step in transmission channel analysis is to define a model. This model will be used to derive total dynamic causal effects (impulse response functions) and to decompose these effects into effects along transmission channels. The TCA toolbox currently supports the following model types:\n\nVector Autoregressions (VARs) for baseline dynamic modelling, estimated via OLS without structural identification.\nStructural VARs (SVARs) with recursive and internal identification schemes.\nLocal projections with recursive and external instrument identification schemes.\nDSGE models computed via Dynare.\n\nEach model class extends the abstract type Model. Detailed descriptions of each model follow.\n\nVector Autoregressions (VARs)\nA VAR model can be defined using the VAR class and its constructor as shown below:\n\n\n\n\n\n\n\nVAR\n\n\n\n\n\nVAR Vector Autoregressive (VAR) model in matrix form.\nA VAR of lag order p is specified as:\ny_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\nwhere: - e_t is a vector of deterministic components (constant, trends, etc). - C, B_i are conformable coefficient matrices. - u_t is vector white noise.\nCompac```{.matlab}orm:\ny_t' = z_t' B_+' + u_t'\nwith: - z_t = [e_t; y_{t-1}; ...; y_{t-p}] - B_+ = [C, B_1, ..., B_p]\nStacking from ```{.matlab} p+1 to T:\nY = X B_+' + U\n\nProperties\n\nB (matrix): Coefficient matrix `[C B_1 … B_p].\nSigmaU (matrix): Covariance matrix of the error term.\np (integer): Lag order of the VAR.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1] implies constant and linear trend).\ninputData (table or matrix): Original data used to estimate the VAR.\nY (matrix): Left-hand side outcomes y_t, size (T-p) x k.\nX (matrix): Right-hand side regressors z_t, size (T-p) x (k*p + m) where m is the number of deterministic domponents.\nU (matrix): Residuals u_t, size (T-p) x k.\nYhat (matrix): Fitted values X * B_+', size (T-p) x k.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.VAR\n\n\n\n\n\nVAR Construct a VAR(p) model.\nobj = VAR(data, p, varargin) creates a VAR with lag length p based on the provided dataset.\n\nArguments\n\ndata (table or matrix): Input dataset for the VAR model.\np (integer): Lag order of the VAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nB (matrix): Coefficient matrix. Default is empty (must be estimated).\nSigmaU (matrix): Covariance matrix of residuals. Default is empty (must be estimated).\n\n\n\nReturns\n\nobj (VAR): A VAR model.\n\nSee also fit, simulate\n\n\n\n\n\nThe constructor requires a dataset in matrix or table form, with each column representing a variable and each row an observation, ordered from earliest to latest. For example:\n% data is some dataset in matrix or table form\np = 2  % lag length\nmode = VAR(data, p)\nYou can include deterministic trends by specifying the trendExponents option:\np = 2  % lag length\nmode = VAR(data, p, 'trendExponents', 0:1)\nHere, 0:1 indicates a constant (\\(t^0\\)) and a linear trend (\\(t^1\\)). For constant, linear, and quadratic trends use 0:2, or [0,2] to skip the linear term.\nTo estimate the VAR via OLS, call fit:\n\n\n\n\n\n\n\nVAR.fit\n\n\n\n\n\nfit Estimate the VAR model using ordinary least squares (OLS).\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\n\n\n\n% if model is a VAR \nmodel.fit()\nRetrieve estimates with:\n\n\n\n\n\n\n\nVAR.coeffs\n\n\n\n\n\ncoeffs Return the VAR coefficient matrix.\nB = coeffs(obj, excludeDeterministic) returns the VAR coefficient matrix [C, B_1, ..., B_p]. If excludeDeterministic is true, returns [B_1, ..., B_p] instead, excluding deterministic components.\n\nArguments\n\nobj (VAR): VAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components. Defaults to false.\n\n\n\nReturns\n\nB (matrix): VAR coefficient matrix.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.fitted\n\n\n\n\n\nfitted Return the fitted values of the VAR model.\nYhat = fitted(obj) returns the matrix of fitted values with size (T-p) x k, where T is the number of observations and k is the number of variables.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nYhat (matrix): Matrix of fitted values.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.residuals\n\n\n\n\n\nresiduals Return the residuals of the VAR model.\nU = residuals(obj) returns the matrix of VAR residuals with size (T-p) x k, where T is the number of observations and k is the number of variables.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nU (matrix): Matrix of residuals.\n\n\n\n\n\n\n% All coefficients\nmodel.coeffs()  \n% Excluding constants/trends\nmodel.coeffs(true)\n% Fitted values\nmodel.fitted()\n% Residuals\nmodel.residuals()\nTo select the optimal lag length automatically, use fitAndSelect. This method fits VAR models for every lag length from 0 up to the specified maximum, evaluates each using the chosen information criterion (AIC by default), and returns the model with the lowest criterion value along with a table of lag lengths and their corresponding scores:\n\n\n\n\n\n\n\nVAR.fitAndSelect\n\n\n\n\n\nfitAndSelect Estimate and select the best VAR model by IC.\n[modelBest, icTable] = fitAndSelect(obj, icFunction) fits the VAR model for different lag lengths and selects the one minimizing the information criterion. Maximum lag length is given by the lag length of the provided model.\n\nArguments\n\nobj (VAR): VAR model object.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.\n\n\n\nReturns\n\nmodelBest (VAR): Best fitting model.\nicTable (table): Table of lag lengths and IC values.\n\nSee also fit, aic, bic, hqc, sic\n\n\n\n\n\n% Choosing a maximum of 20 lags\nmodel = VAR(data, 20);\n[modelBest, icTable] = model.fitAndSelect();\nfitAndSelect supports the following information criteria. Note the underscore suffix (_) on these functions.\n\n\n\n\n\n\n\nVAR.aic_\n\n\n\n\n\naic_ Compute Akaike Information Criterion (AIC).\nval = aic_(SigmaU, nCoeffs, T) returns the AIC value given the residual covariance matrix, number of coefficients, and sample size.\n\nArguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.\n\n\n\nReturns\n\nval (number): Computed AIC value.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.bic_\n\n\n\n\n\nbic_ Compute Bayesian Information Criterion (SIC/BIC).\nval = sic_(SigmaU, nCoeffs, T) returns the BIC value given the residual covariance matrix, number of coefficients, and sample size.\n\nArguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.\n\n\n\nReturns\n\nval (number): Computed BIC value.\n\n\n\nNotes\n\nBIC is the same as SIC.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.sic_\n\n\n\n\n\nsic_ Compute Schwarz Information Criterion (SIC/BIC).\nval = sic_(SigmaU, nCoeffs, T) returns the SIC value given the residual covariance matrix, number of coefficients, and sample size.\n\nArguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.\n\n\n\nReturns\n\nval (number): Computed SIC value.\n\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.hqc_\n\n\n\n\n\nhqc_ Compute Hannan-Quinn Information Criterion (HQC).\nval = hqc_(SigmaU, nCoeffs, T) returns the HQC value given the residual covariance matrix, number of coefficients, and sample size.\n\nArguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.\n\n\n\nReturns\n\nval (number): Computed HQC value.\n\n\n\n\n\n\nFor example, to use the Bayesian Information Criteria, call:\nmodel = VAR(data, 20);\n[modelBest, icTable] = model.fitAndSelect(@VAR.bic_);\nTo compute information criteria for an already estimated model over its own sample, use methods without the trailing underscore. Note these values may differ from those returned by fitAndSelect, which evaluates ICs over a common sample across all models:\n\n\n\n\n\n\n\nVAR.aic\n\n\n\n\n\naic Compute Akaike Information Criterion (AIC) for VAR model.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nval (number): AIC value.\n\nSee also hqc, sic, bic, fit\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.bic\n\n\n\n\n\nbic Compute Bayesian Information Criterion (BIC) for VAR model.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nval (number): BIC value.\n\nSee also aic, hqc, sic, fit\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.sic\n\n\n\n\n\nsic Compute Schwarz Information Criterion (SIC) for VAR model.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nval (number): SIC value.\n\nSee also aic, hqc, bic, fit\n\n\n\n\n\n\n\n\n\n\n\n\nVAR.hqc\n\n\n\n\n\nhqc Compute Hannan-Quinn Criterion (HQC) for VAR model.\n\nArguments\n\nobj (VAR): VAR model object.\n\n\n\nReturns\n\nval (number): HQC value.\n\nSee also aic, sic, bic, fit\n\n\n\n\n\n# Get the HQC value for an estimated model\nmodel.hqc()\n\n\nStructural Vector Autoregressions (SVARs)\nAn SVAR can be defined using the SVAR class and its constructor as documented below:\n\n\n\n\n\n\n\nSVAR\n\n\n\n\n\nSVAR Structural Vector Autoregressive (SVAR) model.\nAn SVAR of lag order p is specified as:\nA0 y_t = C e_t + A1 y_{t-1} + ... + Ap y_{t-p} + \\varepsilon_t\nwhere: - e_t is a vector of deterministic components (constant, trends). - C, A0, Ai are conformable matrices. - \\varepsilon_t are structural shocks.\nAssuming A0 is invertible, the model can be rewritten as a reduced-fo```{.matlab}VAR:\ny_t'A0' = z_t' A_+' + u_t'\nwhere: - z_t = [e_t; y_{t-1}; ...; y_{t-p}] - A_+ = [C, A_1, ..., A_p]\nAssuming A0 is invertible, the reduced-form VAR ca```{.matlab}e obtained as\ny_t' = z_t' A_+'(A_0')^{-1} + u_t'(A_0')^{-1}\nwhich can be represented using a VAR object.\n\nProperties\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [C A1 ... Ap].\np (integer): Lag order of the (S)VAR model.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1]).\nVARModel (VAR): Reduced-form VAR representation.\n\nSee also VAR\n\n\n\n\n\n\n\n\n\n\n\n\nSVAR.SVAR\n\n\n\n\n\nSVAR Construct a Structural VAR (SVAR) model object.\nobj = SVAR(data, p, varargin) creates an SVAR object with lag length p, based on the provided dataset and structural specification.\n\nArguments\n\ndata (table or matrix): Input dataset for the SVAR model.\np (integer): Lag order of the SVAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [A1, ..., Ap].\nVARModel (VAR): Precomputed reduced-form VAR model.\n\n\n\nReturns\n\nobj (SVAR): Constructed SVAR model object.\n\n\n\nNotes\n\nIf VARModel, A0, APlus are not provided, they are estimated from the data.\n\nSee also VAR\n\n\n\n\n\nThe constructor requires a dataset in matrix or table form, with each column representing a variable and each row an observation, ordered from earliest to latest. For example, to specify a lag order of four (p = 4):\np = 4  % lag length\nmodel = SVAR(data, p)\nYou may include deterministic trends as for the VAR case, using the trendExponents option:\np = 4  % lag length\nmodel = SVAR(data, p, 'trendExponents', 0:1)\nTo estimate the structural model, an identification method must be provided. Only recursive identification (Recursive) is supported for full structural identification. Note that InternalInstrument methods can be used to identify impulse responses to a single shock; these are documented in a later section. Fit the model as follows:\n\n\n\n\n\n\n\nSVAR.fit\n\n\n\n\n\nfit Estimate the SVAR model using an identification method.\nfit(obj, identificationMethod) first fits the reduced-form VAR model using ordinary least squares (OLS), then identifies the structural matrices using the provided identification method.\n\nArguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (object): An object of type IdentificationMethod used to identify A0 and APlus.\n\n\n\nNotes\n\nidentificationMethod must implement an identify method taking a VAR object and returning A0 and APlus.\n\nSee also VAR.fit, IdentificationMethod\n\n\n\n\n\nmodel.fit(Recursive())\nAfter fitting, extract coefficients, fitted values, and residuals:\n\n\n\n\n\n\n\nSVAR.coeffs\n\n\n\n\n\ncoeffs Return the SVAR coefficient matrices.\n[A0, APlus] = coeffs(obj, excludeDeterministic) returns the contemporaneous matrix A0 and the lag coefficient matrix APlus for the SVAR model.\n\nArguments\n\nobj (SVAR): SVAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components from APlus. Defaults to false.\n\n\n\nReturns\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Coefficient matrix. If excludeDeterministic is true, returns only lag matrices [A1 ... Ap]. Otherwise APlus = [C A_1 ... A_p] is returned.\n\n\n\n\n\n\n\n\n\n\n\n\n\nSVAR.fitted\n\n\n\n\n\nfitted Return the fitted values of the SVAR model.\nYhat = fitted(obj) returns the fitted values from the reduced-form VAR model associated with the SVAR.\n\nArguments\n\nobj (SVAR): SVAR model object.\n\n\n\nReturns\n\nYhat (matrix): Matrix of fitted values (T-p) x k.\n\n\n\n\n\n\n\n\n\n\n\n\n\nSVAR.residuals\n\n\n\n\n\nresiduals Return the residuals of the SVAR model.\nU = residuals(obj) returns the residuals from the reduced-form VAR model associated with the SVAR.\n\nArguments\n\nobj (SVAR): SVAR model object.\n\n\n\nReturns\n\nU (matrix): Matrix of residuals (T-p) x k.\n\n\n\n\n\n\n% Structural coefficient matrices A0 and APlus\n[A0, APlus] = model.coeffs()\n% Excluding constants and time trends\n[A0, APlus] = model.coeffs(true)\n% Fitted values\nmodel.fitted()\n% Residuals\nmodel.residuals()\nYou can select the lag length automatically via fitAndSelect, which first determines the best reduced‑form VAR up to the maximum lag and then applies the chosen identification method:\n\n\n\n\n\n\n\nSVAR.fitAndSelect\n\n\n\n\n\nfitAndSelect Estimate and select the best SVAR model by IC.\n[modelBest, icTable] = fitAndSelect(obj, identificationMethod, icFunction) fits the SVAR model for different lag lengths and selects the one minimizing the information criterion. The maximuml lag length is determined by the lag length of the given model.\n\nArguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (IdentificationMethod): Identification method for SVAR.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.\n\n\n\nReturns\n\nmodelBest (SVAR): Best fitting SVAR model.\nicTable (table): Table of lag lengths and IC values.\n\n\n\nNotes\n\nMaximum lag length is given by the lag length of the provided model.\n\nSee also SVAr.fit, aic, bic, hqc, sic, VAR.fitAndSelect\n\n\n\n\n\nUsing AIC (default) with a maximum of twenty lags:\nmodel = SVAR(data, 20);\n[modelBest, icTable] = model.fitAndSelect(Recursive())\nOr using HQC for model selection:\nmodel = SVAR(data, 20);\n[modelBest, icTable] = model.fitAndSelect(Recursive(), @VAR.hqc_)\nAll VAR information‑criterion functions (with underscore) may be supplied to choose the optimal SVAR.\n\n\nLocal Projections\nA local projection model can be specified using the LP class and its constructor:\n\n\n\n\n\n\n\nLP\n\n\n\n\n\nLP Local Projection (LP) model for estimating IRFs.\nLocal Projection (LP) model for estimating impulse response functions (IRFs) in a flexible and semi-parametric manner.\nEach LP regression estimates the dynamic response of an outcome variable at future horizon h to a one-period change in a treatment variable at time t, controlling for contemporaneous and lagged covariates.\nThe regression model is specified as:\nw_{i,t+h} = \\mu_{i,h} + \\theta_{i,h} x_t + \\gamma_{i,h}' r_t +\n\\sum_{l=1}^p \\delta_{i,h,l} w_{t-l} + \\xi_{i,h,t}\nwhere w_t = (r_t', x_t, q_t') and: - x_t is the treatment variable - r_t contains contemporaneous controls (all variables before x_t) - p is the number of lags included - \\theta_{i,h} is the relative IRF of x_t on the i-th variable at horizon h.\nThe treatment variable may be endogenous. Structural interpretation of IRFs can be achieved using valid instruments—see ExternalInstrument for one such method. If the treatment satisfies a conditional ignorability assumption (a recursive assumption in macro), then the coefficient has a structural interpretation even without the use of instruments. For this to hold, x_t - E(x_t|r_t, w_{t-1}, ..., w_{t-p}) must be equal to the structural shock.\n\nProperties\n\ndata (table or matrix): Input time series dataset.\ntreatment (char or integer): Treatment variable.\np (integer): Number of lags.\nhorizons (vector): Forecast horizons for projections.\nincludeConstant (logical): Whether to include an intercept.\nB (array): Coefficient estimates per horizon.\nY (array): Dependent variables per horizon.\nX (matrix): Common regressor matrix.\nU (array): Residuals per horizon.\nYhat (array): Fitted values per horizon.\n\n\n\n\n\n\n\n\n\n\n\n\n\nLP.LP\n\n\n\n\n\nLP Construct a Local Projection (LP) model object.\nobj = LP(data, treatment, p, horizons, varargin) initializes an LP object for estimating impulse response functions.\n\nArguments\n\ndata (matrix or table): Input time series dataset.\ntreatment (char or int): Treatment variable.\np (integer): Lag length.\nhorizons (vector): Forecast horizons.\nvarargin: Name-value pairs for options:\nincludeConstant (logical): Include constant in regressors (Defaults to true).\n\n\n\n\n\n\nThe constructor requires:\n\nA dataset in matrix or table form\nA treatment variable (either the shock itself or the instrumented variable)\nThe number of lags (p)\nA vector of horizons (horizons)\n\nFor example, to estimate horizons \\(0\\)–\\(20\\) with 4 lags for treatment variable Y1:\nmodel = LP(data, 'Y1', 4, 0:20)\nBy default, each regression includes a constant term. To omit the constant, set the includeConstant flag to false:\nmodel = LP(data, 'Y1', 4, 0:20, 'includeConstant', false)\nUse the fit method to estimate the projections:\n\n\n\n\n\n\n\nLP.fit\n\n\n\n\n\nfit Estimate the LP model with an identification method.\nfit(obj, identificationMethod) estimates the LP model, identifying causal effects with respect to the treatment.\n\nArguments\n\nobj (LP): LP model object.\nidentificationMethod (object, optional): Identification method. Must be of type IdentificationMethod. Defaults to Recursive.\n\nSee also coeffs, fitted, residuals, Recursive\n\n\n\n\n\n% Uses Recursive by default\nmodel.fit()\nBy default, fit applies a recursive (conditional ignorability) assumption. These estimates are structural only if the true shock satisfies this assumption; otherwise, they should be treated as reduced‐form.\nAvailable identification schemes:\n\nRecursive (default)\nExternalInstrument (for external‐instrument IV)\n\n\n\n\n\n\n\n\nExternalInstrument\n\n\n\n\n\nExternalInstrument Identify IRFs using external instruments.\nThis class identifies structural IRFs from (S)VARs using the external instrument approach proposed by Stock and Watson (2018).\n\nNotes\n\nIRFs are computed relative to the reaction of the treatment variable at normalisingHorizon.\ninstruments must be a matrix or table spanning the same period as the model data.\nDefaults:\nnormalisingHorizon = 0\n\n\n\nReference\n\nStock, J. H., & Watson, M. W. (2018). “Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments.” The Economic Journal, 128(610), 917-948. [https://doi.org/10.1111/ecoj.12593]\n\nSee also IdentificationMethod, Recursive, InternalInstrument\n\n\n\n\n\nTo use an external instrument, first instantiate ExternalInstrument with the treatment name and an instrument dataset, then supply it to fit:\nmethod = ExternalInstrument('Y1', data_instruments);\n% Estimate the local projection using external instruments\nmodel.fit(method);\nAfter estimation, extract the results (note the differing dimensions) via:\n\ncoeffs: (response variable × regressors × horizons)\nfitted, residuals: (observations × variables × horizons)\n\n\n\n\n\n\n\n\nLP.coeffs\n\n\n\n\n\ncoeffs Return coefficient estimates from LP model.\nB = coeffs(obj, excludeDeterministic) returns the estimated coefficients from the fitted LP model.\n\nArguments\n\nobj (LP): LP model object.\nexcludeDeterministic (logical, optional): If true, excludes constant terms from the coefficients. Defaults to false.\n\n\n\nReturns\n\nB (3D array): Coefficients array with dimensions:\nFirst dimension: Outcome variable.\nSecond dimension: Regressors.\nThird dimension: Horizon.\n\nSee also fit\n\n\n\n\n\n\n\n\n\n\n\n\nLP.fitted\n\n\n\n\n\nfitted Return the fitted values from the LP model.\nYhat = fitted(obj) returns the fitted values obtained from the local projection regressions.\n\nArguments\n\nobj (LP): LP model object.\n\n\n\nReturns\n\nYhat (3D array): Fitted values with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also residuals, coeffs, fit\n\n\n\n\n\n\n\n\n\n\n\n\nLP.residuals\n\n\n\n\n\nresiduals Return residuals from the LP model.\nU = residuals(obj) returns the residuals from the local projection regressions.\n\nArguments\n\nobj (LP): LP model object.\n\n\n\nReturns\n\nU (3D array): Residuals with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also fitted, coeffs, fit\n\n\n\n\n\n# Coefficients\nmodel.coeffs()\n# Excluding the constant \nmodel.coeffs(true)\n# Fitted values\nmodel.fitted()\n# Residuals\nmodel.residuals()\nTo select the lag order automatically, use fitAndSelect, which fits VARs internally to choose the optimal p:\n\n\n\n\n\n\n\nLP.fitAndSelect\n\n\n\n\n\nfitAndSelect Select optimal lag length for LP model.\n[modelBest, icTable] = fitAndSelect(obj, identificationMethod, icFunction) selects the optimal lag length based on an equivalent VAR model.\n\nArguments\n\nobj (LP): LP model object.\nidentificationMethod (IdentificationMethod, optional): Identification method. Defaults to Recursive.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.\n\n\n\nReturns\n\nmodelBest (LP): Best fitting LP model.\nicTable (table): Table of lag lengths and IC values.\n\n\n\nNotes\n\nMaximum lag length considered is the lag length of obj.\n\nSee also fit, VAR.fitAndSelect, Recursive\n\n\n\n\n\nAll VAR underscore‑suffixed information‑criterion functions (e.g., aic_, bic_, sic_, hqc_) may be used for LP lag selection. For example, using BIC:\nmodel = LP(data, 'Y1', 20, 0:20);\n[modelBest, icTable] = model.fitAndSelect(Recursive(), @VAR.bic_);\n\n\nDSGE\nA DSGE model can be specified using the DSGE class. Before defining the model, you must compute its first‐order approximation in Dynare. Refer to Dynare’s manual for details.\n\n\n\n\n\n\n\nDSGE\n\n\n\n\n\nDSGE Dynamic Stochastic General Equilibrium (DSGE) model.\nThis class specifies a DSGE model structure. The model must be previously computed using Dynare. It provides access to the Dynare output structures.\n\nProperties\n\nM_ (struct): Model structure returned by Dynare.\noptions_ (struct): Options structure from Dynare.\noo_ (struct): Output structure with results from Dynare.\n\n\n\nNotes\n\nThe model must have already been solved in Dynare.\nThis class serves as a wrapper to interface with Dynare output.\n\n\n\n\n\n\nOnce Dynare has run, the workspace should contain the structures M_, oo_, and options_. Use these to define your DSGE model:\nmodel = DSGE(M_, options_, oo_)\nThe TCA toolbox represents the DSGE as a VARMA model, whereas Dynare uses a state‐space form. For the VARMA representation to exist, the number of observed variables (varobs) must equal the number of structural shocks, and these observed variables must span the shock space. If this condition is not met, calling any method on the DSGE model will return an error.\nTo inspect the observed variables and structural shocks, use:\n% Observed variables in the varobs block\nvarNames = model.getVariableNames();\n% Structural shock names\nshockNames = model.getShockNames();",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties",
    "href": "documentation/matlab/index.html#properties",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\nB (matrix): Coefficient matrix `[C B_1 … B_p].\nSigmaU (matrix): Covariance matrix of the error term.\np (integer): Lag order of the VAR.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1] implies constant and linear trend).\ninputData (table or matrix): Original data used to estimate the VAR.\nY (matrix): Left-hand side outcomes y_t, size (T-p) x k.\nX (matrix): Right-hand side regressors z_t, size (T-p) x (k*p + m) where m is the number of deterministic domponents.\nU (matrix): Residuals u_t, size (T-p) x k.\nYhat (matrix): Fitted values X * B_+', size (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments",
    "href": "documentation/matlab/index.html#arguments",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\ndata (table or matrix): Input dataset for the VAR model.\np (integer): Lag order of the VAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nB (matrix): Coefficient matrix. Default is empty (must be estimated).\nSigmaU (matrix): Covariance matrix of residuals. Default is empty (must be estimated).",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns",
    "href": "documentation/matlab/index.html#returns",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nobj (VAR): A VAR model.\n\nSee also fit, simulate",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-1",
    "href": "documentation/matlab/index.html#arguments-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-2",
    "href": "documentation/matlab/index.html#arguments-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-1",
    "href": "documentation/matlab/index.html#returns-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nB (matrix): VAR coefficient matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-3",
    "href": "documentation/matlab/index.html#arguments-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-2",
    "href": "documentation/matlab/index.html#returns-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nYhat (matrix): Matrix of fitted values.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-4",
    "href": "documentation/matlab/index.html#arguments-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-3",
    "href": "documentation/matlab/index.html#returns-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nU (matrix): Matrix of residuals.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-5",
    "href": "documentation/matlab/index.html#arguments-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-4",
    "href": "documentation/matlab/index.html#returns-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (VAR): Best fitting model.\nicTable (table): Table of lag lengths and IC values.\n\nSee also fit, aic, bic, hqc, sic",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-6",
    "href": "documentation/matlab/index.html#arguments-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-5",
    "href": "documentation/matlab/index.html#returns-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed AIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-7",
    "href": "documentation/matlab/index.html#arguments-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-6",
    "href": "documentation/matlab/index.html#returns-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed BIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes",
    "href": "documentation/matlab/index.html#notes",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nBIC is the same as SIC.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-8",
    "href": "documentation/matlab/index.html#arguments-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-7",
    "href": "documentation/matlab/index.html#returns-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed SIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-9",
    "href": "documentation/matlab/index.html#arguments-9",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-8",
    "href": "documentation/matlab/index.html#returns-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed HQC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-10",
    "href": "documentation/matlab/index.html#arguments-10",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-9",
    "href": "documentation/matlab/index.html#returns-9",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): AIC value.\n\nSee also hqc, sic, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-11",
    "href": "documentation/matlab/index.html#arguments-11",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-10",
    "href": "documentation/matlab/index.html#returns-10",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): BIC value.\n\nSee also aic, hqc, sic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-12",
    "href": "documentation/matlab/index.html#arguments-12",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-11",
    "href": "documentation/matlab/index.html#returns-11",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): SIC value.\n\nSee also aic, hqc, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-13",
    "href": "documentation/matlab/index.html#arguments-13",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-12",
    "href": "documentation/matlab/index.html#returns-12",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nval (number): HQC value.\n\nSee also aic, sic, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties-1",
    "href": "documentation/matlab/index.html#properties-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [C A1 ... Ap].\np (integer): Lag order of the (S)VAR model.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1]).\nVARModel (VAR): Reduced-form VAR representation.\n\nSee also VAR",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-14",
    "href": "documentation/matlab/index.html#arguments-14",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\ndata (table or matrix): Input dataset for the SVAR model.\np (integer): Lag order of the SVAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [A1, ..., Ap].\nVARModel (VAR): Precomputed reduced-form VAR model.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-13",
    "href": "documentation/matlab/index.html#returns-13",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nobj (SVAR): Constructed SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-1",
    "href": "documentation/matlab/index.html#notes-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIf VARModel, A0, APlus are not provided, they are estimated from the data.\n\nSee also VAR",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-15",
    "href": "documentation/matlab/index.html#arguments-15",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (object): An object of type IdentificationMethod used to identify A0 and APlus.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-2",
    "href": "documentation/matlab/index.html#notes-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nidentificationMethod must implement an identify method taking a VAR object and returning A0 and APlus.\n\nSee also VAR.fit, IdentificationMethod",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-16",
    "href": "documentation/matlab/index.html#arguments-16",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components from APlus. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-14",
    "href": "documentation/matlab/index.html#returns-14",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Coefficient matrix. If excludeDeterministic is true, returns only lag matrices [A1 ... Ap]. Otherwise APlus = [C A_1 ... A_p] is returned.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-17",
    "href": "documentation/matlab/index.html#arguments-17",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-15",
    "href": "documentation/matlab/index.html#returns-15",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nYhat (matrix): Matrix of fitted values (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-18",
    "href": "documentation/matlab/index.html#arguments-18",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-16",
    "href": "documentation/matlab/index.html#returns-16",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nU (matrix): Matrix of residuals (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-19",
    "href": "documentation/matlab/index.html#arguments-19",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (IdentificationMethod): Identification method for SVAR.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-17",
    "href": "documentation/matlab/index.html#returns-17",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (SVAR): Best fitting SVAR model.\nicTable (table): Table of lag lengths and IC values.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-3",
    "href": "documentation/matlab/index.html#notes-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nMaximum lag length is given by the lag length of the provided model.\n\nSee also SVAr.fit, aic, bic, hqc, sic, VAR.fitAndSelect",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties-2",
    "href": "documentation/matlab/index.html#properties-2",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\ndata (table or matrix): Input time series dataset.\ntreatment (char or integer): Treatment variable.\np (integer): Number of lags.\nhorizons (vector): Forecast horizons for projections.\nincludeConstant (logical): Whether to include an intercept.\nB (array): Coefficient estimates per horizon.\nY (array): Dependent variables per horizon.\nX (matrix): Common regressor matrix.\nU (array): Residuals per horizon.\nYhat (array): Fitted values per horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-20",
    "href": "documentation/matlab/index.html#arguments-20",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\ndata (matrix or table): Input time series dataset.\ntreatment (char or int): Treatment variable.\np (integer): Lag length.\nhorizons (vector): Forecast horizons.\nvarargin: Name-value pairs for options:\nincludeConstant (logical): Include constant in regressors (Defaults to true).",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-21",
    "href": "documentation/matlab/index.html#arguments-21",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nidentificationMethod (object, optional): Identification method. Must be of type IdentificationMethod. Defaults to Recursive.\n\nSee also coeffs, fitted, residuals, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-4",
    "href": "documentation/matlab/index.html#notes-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIRFs are computed relative to the reaction of the treatment variable at normalisingHorizon.\ninstruments must be a matrix or table spanning the same period as the model data.\nDefaults:\nnormalisingHorizon = 0",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#reference",
    "href": "documentation/matlab/index.html#reference",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Reference",
    "text": "Reference\n\nStock, J. H., & Watson, M. W. (2018). “Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments.” The Economic Journal, 128(610), 917-948. [https://doi.org/10.1111/ecoj.12593]\n\nSee also IdentificationMethod, Recursive, InternalInstrument",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-22",
    "href": "documentation/matlab/index.html#arguments-22",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nexcludeDeterministic (logical, optional): If true, excludes constant terms from the coefficients. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-18",
    "href": "documentation/matlab/index.html#returns-18",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nB (3D array): Coefficients array with dimensions:\nFirst dimension: Outcome variable.\nSecond dimension: Regressors.\nThird dimension: Horizon.\n\nSee also fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-23",
    "href": "documentation/matlab/index.html#arguments-23",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-19",
    "href": "documentation/matlab/index.html#returns-19",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nYhat (3D array): Fitted values with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also residuals, coeffs, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-24",
    "href": "documentation/matlab/index.html#arguments-24",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-20",
    "href": "documentation/matlab/index.html#returns-20",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nU (3D array): Residuals with dimensions:\nFirst dimension: Time.\nSecond dimension: Outcome variable.\nThird dimension: Horizon.\n\nSee also fitted, coeffs, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-25",
    "href": "documentation/matlab/index.html#arguments-25",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nidentificationMethod (IdentificationMethod, optional): Identification method. Defaults to Recursive.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-21",
    "href": "documentation/matlab/index.html#returns-21",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (LP): Best fitting LP model.\nicTable (table): Table of lag lengths and IC values.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-5",
    "href": "documentation/matlab/index.html#notes-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nMaximum lag length considered is the lag length of obj.\n\nSee also fit, VAR.fitAndSelect, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties-3",
    "href": "documentation/matlab/index.html#properties-3",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\nM_ (struct): Model structure returned by Dynare.\noptions_ (struct): Options structure from Dynare.\noo_ (struct): Output structure with results from Dynare.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-6",
    "href": "documentation/matlab/index.html#notes-6",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nThe model must have already been solved in Dynare.\nThis class serves as a wrapper to interface with Dynare output.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#obtaining-the-effects-structural-irfs",
    "href": "documentation/matlab/index.html#obtaining-the-effects-structural-irfs",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "2. Obtaining the effects – structural IRFs",
    "text": "2. Obtaining the effects – structural IRFs\nOnce a model is defined, you can compute total dynamic causal effects—impulse response functions (IRFs)—using the IRF method. The IRF function always requires a maximum horizon (maxHorizon) for computation. For reduced‐form models, you may also supply an IdentificationMethod to derive structural IRFs.\nDetails on IRF computation for all models are provided below.\n\nVARs\nObtain reduced‐form IRFs from a VAR model by specifying the maximal horizon:\n\n\n\n\n\n\n\nVAR.IRF\n\n\n\n\n\nIRF Compute impulse response functions for the VAR model.\nirfObj = IRF(obj, maxHorizon, varargin) computes IRFs up to horizon maxHorizon. If an identificationMethod is provided, structural IRFs are computed.\n\nArguments\n\nobj (VAR): VAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.\nvarargin: Name-value pairs for options:\nidentificationMethod (an IdentificationMethod): Optional method to compute structural IRFs.\n\n\n\nReturns\n\nirfObj (IRFContainer): Object containing computed IRFs.\n\n\n\nNotes\n\nWithout an identification method, reduced-form IRFs are computed.\nWith an identification method, structural IRFs are computed.\n\nSee also IRF_, IRFContainer, fit, IdentificationMethod\n\n\n\n\n\nmaxHorizon = 20;\nirfObj = model.IRF(maxHorizon);\nHere, irfObj is an IRFContainer holding both the IRF array and related metadata:\n\n\n\n\n\n\n\nIRFContainer\n\n\n\n\n\nIRFContainer Container for storing impulse response functions.\nThis class holds IRFs, variable names, the originating model, and the identification method used (if any).\n\nProperties\n\nirfs (3D array): IRFs with dimensions:\nFirst: Response variable.\nSecond: Shock.\nThird: Horizon.\nvarnames (cell array): Names of response variables.\nmodel (Model): Model used to compute the IRFs.\nidentificationMethod (IdentificationMethod):\nIdentification method if the model is reduced form.\n\n\n\n\n\n\nPrinting irfObj displays a 3D array with dimensions:\n\nResponse variable\nShock\nHorizon (starting at 0 for contemporaneous effect)\n\nTo retrieve the raw IRF array, call:\nirfObj.getIrfArray()\nTo compute structural IRFs, supply an IdentificationMethod. Supported methods include recursive and internal‐instrument schemes:\n\n\n\n\n\n\n\nIdentificationMethod\n\n\n\n\n\nIdentificationMethod Abstract class for structural identification.\nThis abstract class specifies the interface for identification methods that recover structural models and IRFs from reduced-form models.\n\nRequired Methods\n\nirfs = identifyIrfs(obj, model, maxHorizon)\n\n\nIdentifies IRFs from the reduced form model.\nReturns a 3D array with dimensions: (response variable, shock, horizon).\nIRFs should be computed up to maxHorizon.\n\n\n[varargout] = identify(obj, model)\n\n\nIdentifies the structural form of a reduced form model.\nFor SVARs from VARs:\nvarargout{1} = A0 (contemporaneous matrix)\nvarargout{2} = APlus (lag polynomial matrix)\nFor LPs:\nvarargout{1} = coefficient estimates per horizon.\n\n\n\nNotes\n\nSee the Recursive class for an example implementation.\n\nSee also Recursive, SVAR, LP\n\n\n\n\n\n\n\n\n\n\n\n\nRecursive\n\n\n\n\n\nRecursive Identify reduced-form models using recursivity.\nThis class implements identification under a recursive (Cholesky) structure, assuming conditional ignorability.\n\nNotes\n\nFor SVARs, this corresponds to Cholesky identification.\nFor LPs, it assumes conditioning on prior ordered variables.\nCommonly used in macroeconomics when contemporaneous shocks are assumed to have a lower triangular impact.\n\nSee also IdentificationMethod, SVAR, LP\n\n\n\n\n\n\n\n\n\n\n\n\nInternalInstrument\n\n\n\n\n\nInternalInstrument Identify IRFs using internal instruments.\nThis class identifies impulse responses in (S)VARs using the internal instruments method proposed by Plagborg-Moller and Wolf (2021).\n\nNotes\n\nIRFs are computed from Cholesky-orthogonalized shocks with respect to the selected instrument.\nShocks are normalized by the response of the normalisingVariable at normalisingHorizon.\nThe instrument can be specified as an integer (index) or character (variable name).\nDefaults:\ninstrument = 1 (first variable)\nnormalisingHorizon = 0\n\n\n\nReference\n\nPlagborg-Moller, M., & Wolf, C. K. (2021). “Local Projections and VARs Estimate the Same Impulse Responses.” Econometrica, 89(2), 955-980. [https://doi.org/10.3982/ecta17813]\n\nSee also IdentificationMethod, Recursive\n\n\n\n\n\n\n\n\n\n\n\n\nInternalInstrument.InternalInstrument\n\n\n\n\n\n\n\n\n\n\nFor a recursive identification:\nirfObj = model.IRF(maxHorizon, 'IdentificationMethod', Recursive())\nTo use an internal instrument, specify a normalisingVariable, then optionally override the instrument (default: first variable) or the normalisingHorizon (default: 0 for contemporaneous effect):\nnormalisingVariable = 'Y2'\nmethod = InternalInstrument(normalisingVariable)\nirfObj = model.IRF(maxHorizon, 'IdentificationMethod', method)\n% Changing the instrument to be Y2 and the normalisingVariable to be Y3\nmethod = InternalInstrument('Y3', 'instrument', 'Y2')\n% Changing the normalisingHorizon to be period 1\nmethod = InternalInstrument('Y3', 'instrument', 'Y2', 'normalisingHorizon', 1)\n\n\nSVARs\nImpulse response functions can be obtained from an SVAR using the IRF function, analogous to the VAR case. Since an SVAR is already structurally identified, IRF returns structural IRFs directly:\n\n\n\n\n\n\n\nSVAR.IRF\n\n\n\n\n\nIRF Compute structural impulse response functions for SVAR.\nirfObj = IRF(obj, maxHorizon) computes structural IRFs up to horizon maxHorizon from an estimated SVAR model.\n\nArguments\n\nobj (SVAR): SVAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.\n\n\n\nReturns\n\nirfObj (IRFContainer): Container with computed IRFs.\n\n\n\nNotes\n\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Structural shocks.\nThird dimension: Horizons.\n\nSee also VAR.IRF, ~IRFContainer`\n\n\n\n\n\n\n\n\n\n\n\nUsing SVARs and Internal Instruments\n\n\n\nThe SVAR.IRF method requires a fully identified SVAR. Internal instruments (via InternalInstrument) cannot be applied to an SVAR directly. To use internal instruments for IRF identification, first define a reduced‐form VAR, apply the instrument there, and then compute IRFs:\nmodel = VAR(data, p);\nnormalisingVariable = 'Y2';\nmethod = InternalInstrument(normalisingVariable);\nirfObj = model.IRF(maxHorizon, 'identificationMethod', method);\n\n\n\n\nLocal Projections\nImpulse response functions can be obtained from an estimated LP model using IRF. These IRFs are structural whenever the LP model was estimated structurally.\n\n\n\n\n\n\n\nLP.IRF\n\n\n\n\n\nIRF Compute impulse response functions from LP model.\nirfObj = IRF(obj, maxHorizon, varargin) computes IRFs up to maxHorizon based on the LP model.\n\nArguments\n\nobj (LP): LP model object.\nmaxHorizon (integer): Maximum forecast horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.\n\n\n\nReturns\n\nirfObj (IRFContainer): Container with computed IRFs.\n\n\n\nNotes\n\nIf identificationMethod is provided, LP is refitted first.\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Shocks.\nThird dimension: Horizon.\n\nSee also fit, IRFContainer\n\n\n\n\n\nirfObj = model.IRF(maxHorizon)\nOptionally, supply an identification method (Recursive or ExternalInstrument) to re-estimate the local projection and compute IRFs under that scheme:\n% USing recursive identification\nirfObj = model.IRF(maxHorizon, 'identificationMethod', Recursive())\n% Using external instruments\nmethod = ExternalInstrument('Y1', data_instruments);\nirfObj = model.IRF(maxHorizon, 'identificationMethod', method);\n\n\nDSGE\nIf a VARMA representation of the DSGE model exists, compute IRFs for the varobs variables via IRF:\n\n\n\n\n\n\n\nDSGE.IRF\n\n\n\n\n\nIRF Compute impulse response functions for DSGE model.\nirfObj = IRF(obj, maxHorizon) computes IRFs of the DSGE model up to horizon maxHorizon.\n\nArguments\n\nobj (DSGE): DSGE model object.\nmaxHorizon (integer): Maximum forecast horizon.\n\n\n\nReturns\n\nirfObj (IRFContainer): Container with computed IRFs.\n\n\n\nNotes\n\nUses VARMA representation for IRF computation.\n\nSee also coeffs, dynareToVarma_, varmaIrfs_\n\n\n\n\n\nmaxHorizon = 20;\nirfObj = model.IRF(maxHorizon);",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-26",
    "href": "documentation/matlab/index.html#arguments-26",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.\nvarargin: Name-value pairs for options:\nidentificationMethod (an IdentificationMethod): Optional method to compute structural IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-22",
    "href": "documentation/matlab/index.html#returns-22",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Object containing computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-7",
    "href": "documentation/matlab/index.html#notes-7",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nWithout an identification method, reduced-form IRFs are computed.\nWith an identification method, structural IRFs are computed.\n\nSee also IRF_, IRFContainer, fit, IdentificationMethod",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties-4",
    "href": "documentation/matlab/index.html#properties-4",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\nirfs (3D array): IRFs with dimensions:\nFirst: Response variable.\nSecond: Shock.\nThird: Horizon.\nvarnames (cell array): Names of response variables.\nmodel (Model): Model used to compute the IRFs.\nidentificationMethod (IdentificationMethod):\nIdentification method if the model is reduced form.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#required-methods",
    "href": "documentation/matlab/index.html#required-methods",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Required Methods",
    "text": "Required Methods\n\nirfs = identifyIrfs(obj, model, maxHorizon)\n\n\nIdentifies IRFs from the reduced form model.\nReturns a 3D array with dimensions: (response variable, shock, horizon).\nIRFs should be computed up to maxHorizon.\n\n\n[varargout] = identify(obj, model)\n\n\nIdentifies the structural form of a reduced form model.\nFor SVARs from VARs:\nvarargout{1} = A0 (contemporaneous matrix)\nvarargout{2} = APlus (lag polynomial matrix)\nFor LPs:\nvarargout{1} = coefficient estimates per horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-8",
    "href": "documentation/matlab/index.html#notes-8",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nSee the Recursive class for an example implementation.\n\nSee also Recursive, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-9",
    "href": "documentation/matlab/index.html#notes-9",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nFor SVARs, this corresponds to Cholesky identification.\nFor LPs, it assumes conditioning on prior ordered variables.\nCommonly used in macroeconomics when contemporaneous shocks are assumed to have a lower triangular impact.\n\nSee also IdentificationMethod, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-10",
    "href": "documentation/matlab/index.html#notes-10",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIRFs are computed from Cholesky-orthogonalized shocks with respect to the selected instrument.\nShocks are normalized by the response of the normalisingVariable at normalisingHorizon.\nThe instrument can be specified as an integer (index) or character (variable name).\nDefaults:\ninstrument = 1 (first variable)\nnormalisingHorizon = 0",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#reference-1",
    "href": "documentation/matlab/index.html#reference-1",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Reference",
    "text": "Reference\n\nPlagborg-Moller, M., & Wolf, C. K. (2021). “Local Projections and VARs Estimate the Same Impulse Responses.” Econometrica, 89(2), 955-980. [https://doi.org/10.3982/ecta17813]\n\nSee also IdentificationMethod, Recursive",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-27",
    "href": "documentation/matlab/index.html#arguments-27",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-23",
    "href": "documentation/matlab/index.html#returns-23",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-11",
    "href": "documentation/matlab/index.html#notes-11",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Structural shocks.\nThird dimension: Horizons.\n\nSee also VAR.IRF, ~IRFContainer`",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-28",
    "href": "documentation/matlab/index.html#arguments-28",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nmaxHorizon (integer): Maximum forecast horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-24",
    "href": "documentation/matlab/index.html#returns-24",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-12",
    "href": "documentation/matlab/index.html#notes-12",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, LP is refitted first.\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Shocks.\nThird dimension: Horizon.\n\nSee also fit, IRFContainer",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-29",
    "href": "documentation/matlab/index.html#arguments-29",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nmaxHorizon (integer): Maximum forecast horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-25",
    "href": "documentation/matlab/index.html#returns-25",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-13",
    "href": "documentation/matlab/index.html#notes-13",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nUses VARMA representation for IRF computation.\n\nSee also coeffs, dynareToVarma_, varmaIrfs_",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#defining-a-transmission-matrix.",
    "href": "documentation/matlab/index.html#defining-a-transmission-matrix.",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "3. Defining a transmission matrix.",
    "text": "3. Defining a transmission matrix.\nThe next step in a transmission channel analysis is to define the transmission matrix, which specifies the ceteris paribus ordering of variables in the chosen equilibrium representation. The simplest way is to list the variables in the desired order as a cell array of char. For example, if your data contains Y1, Y2, Y3, and Y4, and you wish to order them as Y4, Y2, Y1, Y3, define:\ntransmissionOrdering = {'Y4', 'Y2', 'Y1', 'Y3'};\n\n\n\n\n\n\nNote: The ordering must be a cell array of character vectors (not string arrays).\n\n\n\nAdvanced methods for constructing transmission matrices are covered in the Advanced Methods Section.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#definining-transmission-channels.",
    "href": "documentation/matlab/index.html#definining-transmission-channels.",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "4. Definining transmission channels.",
    "text": "4. Definining transmission channels.\nWith the transmission matrix in place, you can specify transmission channels of interest via the helper functions through and notThrough. These functions return a transmission condition Q that you can combine to define complex transmission channels. More advanced methods for defining transmission channels are documented in the Advanced Methods Section.\n\n\n\n\n\n\n\nQ\n\n\n\n\n\nQ Represents a transmission condition.\nThe Q class is used to define transmission conditions based on Boolean statements. A transmission condition is denoted as \\(Q(b)\\), where \\(b\\) is a Boolean statement involving variables x&lt;num&gt;, such as x1, x2, etc. Boolean statements should only contain AND (&) and NOT (!) operations.\n\nProperties\n\nvars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.\n\n\n\nMethods\n\nQ: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.\n\n\n\nUsage\n% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);\n\n\nNotes\n\nThe recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.\n\n\n\n\n\n\nthrough\nUse through to define channels that pass through specified variables at given horizons:\n\n\n\n\n\n\n\nModel.through\n\n\n\n\n\nthrough Create a transmission condition enforcing paths through specific variables.\nq = through(obj, vars, horizons, order) constructs a transmission condition q where paths must pass through specified variables at given time horizons.\n\nArguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths must go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths must pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transmission matrix.\n\n\n\nReturns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also notThrough, transmission.\n\n\n\n\n\nExamples (for any model — VAR, SVAR, LP, or DSGE — with transmissionOrder or a transmission matrix as described above):\n\nChannel through Y1 at horizons 0-3:\n\nq = model.through('Y1', 0:3, transmissionOrder);\n\nChannel through Y1 and Y2 contemporaneously:\n\nq = model.through({'Y1', 'Y2'}, 0, transmissionOrder);\n\nChannel through Y1 at horizon 0 and Y2 at horizons 0–1:\n\nq = model.through({'Y1', 'Y2'}, {0:0, 0:1}, transmissionOrder);\nnotThrough\nUse notThrough to define channels that do not go through specified variables at given horizons:\n\n\n\n\n\n\n\nModel.notThrough\n\n\n\n\n\nnotThrough Create a transmission condition excluding specific variables from the channel.\nq = notThrough(obj, vars, horizons, order) constructs a transmission condition q where paths cannot pass through specified variables at given time horizons.\n\nArguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths cannot go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths cannot pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transission matrix.\n\n\n\nReturns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also through, transmission\n\n\n\n\n\nExamples (for any model — VAR, SVAR, LP, or DSGE — with transmissionOrder or a transmission matrix as described above):\n\nChannel not through Y1 at horizons 0-20:\n\nq = model.notThrough('Y1', 0:20, transmissionOrder);\n\nChannel not through Y1 and not through Y2 at horizons 0-20:\n\nq = model.notThrough({'Y1', 'Y2'}, 0:20, transmissionOrder);\n\nChannel not through Y1 contemporaneously and not through Y2 at horizon 1:\n\nq = model.notThrough({'Y1', 'Y2'}, {0:0, 1:1}, transmissionOrder);\nCombining through and notThrough\nBoth through and notThrough return a transmission condition Q, which can be combined using logical operators:\n\nAND (&): both conditions must be satisfied.\nOR (|): at least one condition must be satisfied.\nNOT (~): negates a condition.\n\nExamples:\n\nChannel through Y1 contemporaneously but not through Y2 contemporaneously:\n\nq1 = model.through('Y1', 0, transmissionOrder);\nq2 = model.notThrough('Y2', 0, transmissionOrder);\nq = q1 & q2;\n\nChannel through Y1 contemporaneously or not through Y2 contemporaneously:\n\nq1 = model.through('Y1', 0, transmissionOrder);\nq2 = model.notThrough('Y2', 0, transmissionOrder);\nq = q1 | q2;\n\nChannel not through Y1 contemporaneously (both ways are equivalent):\n\nq1 = model.through('Y1', 0, transmissionOrder);\nq = ~q1;  # not through Y1 contemporaneously\nq = model.notThrough('Y1', 0, transmissionOrder);\n\nChannel through Y1 in at least one period between horizons 0-20:\n\nq = model.notThrough('Y1', 0:20, transmissionOrder);\nq = ~q;\nBy combining through and notThrough with logical operators, you can flexibly construct any complex transmission channel you require.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#properties-5",
    "href": "documentation/matlab/index.html#properties-5",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Properties",
    "text": "Properties\n\nvars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#methods",
    "href": "documentation/matlab/index.html#methods",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Methods",
    "text": "Methods\n\nQ: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#usage",
    "href": "documentation/matlab/index.html#usage",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Usage",
    "text": "Usage\n% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-14",
    "href": "documentation/matlab/index.html#notes-14",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nThe recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-30",
    "href": "documentation/matlab/index.html#arguments-30",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths must go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths must pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-26",
    "href": "documentation/matlab/index.html#returns-26",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also notThrough, transmission.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-31",
    "href": "documentation/matlab/index.html#arguments-31",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (object): A Model object.\nvars (char or cell array of char): Name(s) of the variables that paths cannot go through.\nhorizons (vector or cell array of vectors): Time horizons at which the paths cannot pass through the variable(s).\norder (char or cell array of char): Variable ordering defining the transission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-27",
    "href": "documentation/matlab/index.html#returns-27",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\nq (Q): A transmission condition that can be used in transmission to compute the transmission effect.\n\nSee also through, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#obtaining-transimssion-effects.",
    "href": "documentation/matlab/index.html#obtaining-transimssion-effects.",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "5. Obtaining transimssion effects.",
    "text": "5. Obtaining transimssion effects.\nOnce you have defined a model (VAR, SVAR, LP, or DSGE), the transmission method computes transmission effects along your specified channel. Below are the details for each model type.\n\nVAR, SVAR, or LP\nFor VAR, or for SVAR and LP models that have not yet been structurally estimated, you must provide an IdentificationMethod (since at least one structural shock is required):\n\n\n\n\n\n\n\nVAR.transmission\n\n\n\n\n\ntransmission Compute transmission effects in a VAR model.\neffects = transmission(obj, shock, condition, order, maxHorizon, varargin) computes the transmission effects of a shock under a condition, using the transmission matrix defined by order, up to maxHorizon.\n\nArguments\n\nobj (VAR): VAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod): Required method to compute structural IRFs.\n\n\n\nReturns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (of size one for the single selected shock).\nThird dimension: Horizon.\n\nSee also VAR.through, VAR.notThrough\n\n\n\n\n\n\n\n\n\n\n\n\nSVAR.transmission\n\n\n\n\n\ntransmission Compute transmission effects in an SVAR model.\neffects = transmission(obj, shock, condition, order, maxHorizon, varargin) computes the transmission effects of a shock under a condition, using the transmission matrix defined by order, up to maxHorizon.\n\nArguments\n\nobj (SVAR): SVAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod, optional): Method to identify the SVAR if not yet fitted.\n\n\n\nReturns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (only the selected shock).\nThird dimension: Horizon.\n\n\n\nNotes\n\nIf identificationMethod is provided, the model is fitted first.\n\nSee also SVAR.through, SVAR.notThrough, VAR.transmission\n\n\n\n\n\n\n\n\n\n\n\n\nLP.transmission\n\n\n\n\n\ntransmission Compute transmission effects in an LP model.\neffects = transmission(obj, shock, condition, order, maxHorizon, varargin) computes transmission effects for a shock satisfying a condition, based on the ordering order, up to maxHorizon.\n\nArguments\n\nobj (LP): LP model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.\n\n\n\nReturns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Selected shock.\nThird dimension: Horizon.\n\n\n\nNotes\n\nIf identificationMethod is provided, the LP model is refitted.\n\nSee also LP.through, LP.notThrough, LP.IRF\n\n\n\n\n\nFor example, to compute the effects of the first structural shock up to maxHorizon, using a transmission matrix transmissionOrder and a transmission condition q:\n% model can be VAR, SVAR, or LP\neffects = model.transmission(\n    1, ...                % shock index\n    q, ...                % transmission condition\n    transmissionOrder, ...% transmission matrix\n    maxHorizon, ...       % maximum horizon\n    'IdentificationMethod', method ... % Recursive, InternalInstrument (VAR/SVAR) or ExternalInstrument (LP)\n);\nThe returned effects array has dimensions:\n\nResponse variables (in original data order)\nTransmission effect of the chosen shock\nHorizons (starting at 0)\n\nIf your SVAR or LP model is already structurally identified (fitted with a structural identification scheme), you may omit the identification argument:\n% model is a SVAR or structurally estimated LP\neffects = model.transmission(1, q, transmissionOrder, maxHorizon)\n\n\nDSGE\nSince DSGE models are inherently structural and shocks can be named, you may specify the shock by name or index. No identification method is needed:\n\n\n\n\n\n\n\nDSGE.transmission\n\n\n\n\n\ntransmission Compute transmission effects in a DSGE model.\neffects = transmission(obj, shock, condition, order, maxHorizon) computes the transmission effects for a shock under a condition based on order, up to maxHorizon.\n\nArguments\n\nobj (DSGE): DSGE model object.\nshock (char or int): Shock name or index.\ncondition (Q): Transmission condition object.\norder (cell array or vector): Variable ordering.\nmaxHorizon (integer): Maximum forecast horizon.\n\n\n\nReturns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables.\nSecond dimension: Selected shock.\nThird dimension: Horizon.\n\n\n\nNotes\n\nshock and order can be provided by name or index.\n\nSee also DSGE.through, DSGE.notThrough\n\n\n\n\n\nFor example, if mp (monetary policy shock) is the first shock:\n% By name\neffects = model.transmission('mp', q, transmissionOrder, maxHorizon);\n\n% By index (equivalent)\neffects = model.transmission(1, q, transmissionOrder, maxHorizon);",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-32",
    "href": "documentation/matlab/index.html#arguments-32",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod): Required method to compute structural IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-28",
    "href": "documentation/matlab/index.html#returns-28",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (of size one for the single selected shock).\nThird dimension: Horizon.\n\nSee also VAR.through, VAR.notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-33",
    "href": "documentation/matlab/index.html#arguments-33",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod, optional): Method to identify the SVAR if not yet fitted.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-29",
    "href": "documentation/matlab/index.html#returns-29",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (only the selected shock).\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-15",
    "href": "documentation/matlab/index.html#notes-15",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, the model is fitted first.\n\nSee also SVAR.through, SVAR.notThrough, VAR.transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-34",
    "href": "documentation/matlab/index.html#arguments-34",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (LP): LP model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (optional): Identification method.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-30",
    "href": "documentation/matlab/index.html#returns-30",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Selected shock.\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-16",
    "href": "documentation/matlab/index.html#notes-16",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, the LP model is refitted.\n\nSee also LP.through, LP.notThrough, LP.IRF",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#arguments-35",
    "href": "documentation/matlab/index.html#arguments-35",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Arguments",
    "text": "Arguments\n\nobj (DSGE): DSGE model object.\nshock (char or int): Shock name or index.\ncondition (Q): Transmission condition object.\norder (cell array or vector): Variable ordering.\nmaxHorizon (integer): Maximum forecast horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#returns-31",
    "href": "documentation/matlab/index.html#returns-31",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons:\nFirst dimension: Endogenous variables.\nSecond dimension: Selected shock.\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#notes-17",
    "href": "documentation/matlab/index.html#notes-17",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "Notes",
    "text": "Notes\n\nshock and order can be provided by name or index.\n\nSee also DSGE.through, DSGE.notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/index.html#visualising-effects.",
    "href": "documentation/matlab/index.html#visualising-effects.",
    "title": "Matlab Toolbox for Transmission Channel Analysis",
    "section": "6. Visualising effects.",
    "text": "6. Visualising effects.\nTo inspect transmission effects graphically, use the helper functions:\n\n\n\n\n\n\n\nplotDecomposition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplotCompareDecomposition\n\n\n\n\n\n\n\n\n\n\n\nplotDecomposition Visualises a single transmission-channel decomposition of the IRFs.\nplotCompareDecomposition: Compares two decompositions obtained from different transmission matrices.\n\nSee the Examples for usage demos.",
    "crumbs": [
      "Home",
      "Matlab",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html",
    "href": "documentation/matlab/internals.html",
    "title": "Internals",
    "section": "",
    "text": "The internals of the Matlab Toolbox for Transmission Channel Analysis all resolve around the type Q, which is the internal representation of a transmission condition using the variables of the systems form; thus \\(x_i\\) and not \\(y_{i,t}\\).\n\n\n\n\n\n\n\nQ\n\n\n\n\n\nQ Represents a transmission condition.\nThe Q class is used to define transmission conditions based on Boolean statements. A transmission condition is denoted as \\(Q(b)\\), where \\(b\\) is a Boolean statement involving variables x&lt;num&gt;, such as x1, x2, etc. Boolean statements should only contain AND (&) and NOT (!) operations.\n\n\n\nvars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.\n\n\n\n\n\nQ: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.\n\n\n\n\n% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);\n\n\n\n\nThe recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.\n\n\n\n\n\n\nThe basic idea is to start with a singleton statement, such as \\(x_i\\), \\(\\neg x_i\\) or sometimes even just \\(\\text{TRUE}\\). Each of these singleton – or atomic – statements refers to the simplest transmission channel in which \\(x_i\\) must be on the path, \\(x_i\\) cannot be on the path, or in which case the condition is always true. Such singleton statement can be created in the following way.\n% x1 must be on the path\nx1 = Q(1);\n\n% x1 cannot be on the path\nnotX2 = Q('!x2');\n\n% TRUE\nT = Q('T');\nMore complex transmission conditions are then simply a combination of these singleton statements. More precisely, a transmission condition q1 can be combined with another transmission condition q2 using any of AND (&), OR (|) and NOT (~)1. Throughout, parentheses can be used to change the precedence. In the following we will describe how such combinations are internally implemented.\n\n\nSuppose we wanted to combine two conditions q1::Q and q2::Q using an AND. Thus, suppose we wanted to do\nq1 & q2\nThis is achieved by extending and for the type Q. However, key in the internal implementation is the following assumption.\n\n\n\n\n\n\nNote 1: Assumption 1\n\n\n\nThe transmission condition q consists of only conjunctions (&) and negations (!).\n\n\nUnder Assumption 1 q1 and q2 both consist of only conjunctions and disjunctions. This immediately implies that their conjunction will also only consist of conjunctions and negations. We can thus simply “concatenate” the two conditions. This is basically what we internally do, with the caveat that the conditions are represented using String and that, for algorithimic purposes, we prefer the variables to be ordered in the statement.\nThe detailed internal implementation is given by\n\n\n\n\n\n\n\nQ.and\n\n\n\n\n\n& combine two transmission conditions using logical AND.\nresult = q1 & q2 performs a logical AND operation between two transmission conditions, returning a new Q object. This is the same as \\(Q(b \\land b')\\) where \\(b\\) and \\(b'\\) are the Boolean conditions for q1 and q2 respectively.\n\n\n\nobj1 (Q): First transmission condition.\nobj2(Q): Second transmission condition.\n\n\n\n\n\nresult(Q): The combined transmission condition.\n\nExample:\nq1 = Q(1);\nq2 = Q(2);\nq = q1 & q2;  % Returns Q(\"x2 & x1\")\nSee also or (|), not (~)\n\n\n\n\n\nWhile concatenating the two conditions, we need to watch out that no contradictions are being introduced. Contradictions are any statements along the lines \\(x_i \\land \\neg x_i\\) which would always result in false. This is taken care of by the following functions.\n\n\n\n\n\n\n\ncheckContradiction\n\n\n\n\n\ncheckContradiction Check for contradictions of the form x1 & ~x1 (x1 & !x1).\n[hasContradiction, contradictions] = checkContradiction(varAnd, varNot) checks whether there is a contradiction where a variable appears in both varAnd and varNot, meaning it is simultaneously required and forbidden.\n\n\n\nvarAnd (vector or cell array of vectors): AND variable numbers obtained from getVarNumsAndMultiplier.\nvarNot (vector or cell array of vectors): NOT variable numbers obtained from getVarNumsAndMultiplier.\n\n\n\n\n\nhasContradiction (logical): True if any contradictions exist.\ncontradictions (vector of logicals): A vector indicating which elements yield a contradiction.\n\n\n\n\n\nThis function is used in removeContradictions to eliminate contradicting terms, which helps speed up the simplification process by reducing the total number of terms.\n\nSee also removeContradictions, getVarNumsAndMultiplier\n\n\n\n\n\n\n\n\n\n\n\n\nremoveContradictions\n\n\n\n\n\nremoveContradictions Remove contradicting terms from a transmission condition.\nq = removeContradictions(q) removes terms that contain contradictions of the form x_i & !x_i, which always evaluate to false and contribute zero to the transmission effect. Behaviour of the function can be changed by setting REMOVECONTRADICTIONS=false locally.\nArguments: - q (Q): A transmission condition. See also Q and makeCondition.\nReturns: - If REMOVECONTRADICTIONS is set to false, the input q is returned unchanged. - If REMOVECONTRADICTIONS is true or not set: 1. If all terms are contradicting, Q(\"T\", 0) is returned, which represents a transmission effect of zero. 2. If some terms are non-contradicting, only the non-contradicting terms are retained in the output.\n\n\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.\n\n\n\n\nIf REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.\n\n\n\n\n\n\nAs stated in the overview of the documentation, removal of contradictions is governed by the global REMOVECONTRADICTION and the utility function setRemoveContradictions. Not removing contradictions does not lead to mistakes in the computation, but can result in longer computations. Contrary, removing contradictions can lead to longer compile times – it takes longer to compile the transmission conditions. Thus, a trade-off between compile and computing time exists.\n\n\n\n\n\n\n\nsetRemoveContradictions\n\n\n\n\n\nsetRemoveContradictions Set the global flag for removing contradictions in transmission conditions.\nsetRemoveContradictions(bool) controls whether contradictions in transmission conditions are removed when calling setRemoveContradictions.\n\n\n\nbool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.\n\n\n\n\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions\n\n\n\n\n\n\n\n\nLet q1 and q2 be again two transmission conditions. Suppose their internal Boolean conditions are given by \\(b\\) and \\(b'\\) respectively, with both satisfying Assumption 1. The rules for manipulating transmission conditions then imply \\[\nQ(b \\lor b') = Q(b) + Q(b') - Q(b \\land b').\n\\] Implementation of OR (|) therefore simply uses AND and the ability for Q to represent multiple terms with different multipliers. The precise implementation of OR can be found in the following function.\n\n\n\n\n\n\n\nQ.or\n\n\n\n\n\n| Combine two transmission conditions using a logical OR.\nresult = q1 | q2 performs a logical OR operation between two transmission conditions, returning a new Q object.\n\n\n\nobj1 (Q): First transmission condition.\nobj2 (Q): Second transmission condition.\n\n\n\n\n\nresult (Q): The combined transmission condition.\n\n\n\n\nq1 = Q(1);\nq2 = Q(2);\nq = q1 | q2;\nSee also and (&), not (~)\n\n\n\n\n\n\n\n\nSuppose a transmission condition is given by q which internally represents the Boolean condition \\(b\\). By the rules for manipulating transmission conditions we then know that \\[\nQ(\\neg b) = Q(T) - Q(b),\n\\] where \\(T\\) represents the Boolean condition that is always true. This can easily be represented using Q through its ability to represent multiple terms and multipliers. Specifically, we simply replace the original transmission condition with a new one that consists of one additional term, representing true, and switch the sign of all original terms of the condition. The following function implements this behaviour.\n\n\n\n\n\n\n\nQ.not\n\n\n\n\n\n~ Negate a boolean condition using the logican NOT.\nresult = ~q negates a transmission condition, creating a condition where the given Boolean statement does not hold.\n\n\n\nobj (Q): A transmission condition to negate.\n\n\n\n\n\nresult (Q): The negated transmission condition.\n\n\n\n\nq1 = Q(1);\nq = ~q1;\n\n\n\n\nIf the condition consists of a single variable, it is simply negated.\nIf the condition is more complex, an auxiliary \"T\" (true) condition is used and the returned condition is equivalent to \\(Q(T) - Q(b)\\) where \\(b\\) is the origional Boolean condition.\n\nSee also and (&), or (|)\n\n\n\n\n\n\n\n\nRather than letting the user create all variables manually via x1 = Q(1) etc., we provide the function makeCondition. This function simply matches all variables in a string with the regex x\\d+, creates the variables using the above way, and then evaluates the entire condition to create the final condition. Due to the operator overloading above, the final result will be a valid and correct transmission condtion. However, key to this correctness is that all variables match the provided regex pattern. Thus, all variables must be of the form x1, x2, etc.\nFor user friendliness, we also provide a version of makeConditionY that takes variables of the dynamic form, i.e. \\(y_{i,t}\\). However, all that this function does is to translate all variables into variables of the systems form and then calls the method explained above.\nIn any case, makeCondition and makeConditionY should be seen as utility functions with the main funcionality being dependent on correct implementation of Q, &, |, and ~ as explained above.\n\n\n\n\n\n\n\nmakeCondition\n\n\n\n\n\nmakeCondition Create a transmission condition from a Boolean string.\nq = makeCondition(s) constructs a transmission condition \\(Q(b)\\) from a Boolean statement given as a string. The Boolean expression should use variables of the systems form x&lt;num&gt;, where &lt;num&gt; represents a variable index.\n\n\n\ns (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.\n\n\n\n\n\nq (Q): A transmission condition.\n\n\n\n\ns = \"x2 & !x3\";\ncond = makeCondition(s);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY\n\n\n\n\n\n\n\n\n\n\n\n\nmakeConditionY\n\n\n\n\n\nmakeConditionY Create a transmission condition from a Boolean string using dyanmic form variables.\nq = makeConditionY(strY, order) constructs a transmission condition \\(Q(b)\\) from a Boolean statement specified in terms of dynamic system variables (i.e., y_{i,t} notation).\n\n\n\nstrY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.\n\n\n\n\n\nq (Q): A transmission condition object.\n\n\n\n\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#properties",
    "href": "documentation/matlab/internals.html#properties",
    "title": "Internals",
    "section": "",
    "text": "vars (cell array of strings): Contains the Boolean variable expressions.\nmultiplier (vector of numbers): Multipliers associated with each term.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#methods",
    "href": "documentation/matlab/internals.html#methods",
    "title": "Internals",
    "section": "",
    "text": "Q: Constructor to create a transmission condition.\nand: Overloads & (logical AND) for Q objects.\nor: Overloads | (logical OR) for Q objects.\nnot: Overloads ~ (logical NOT) for Q objects.\ndisp: Custom display function.\ndisplay: Calls disp for better formatting.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#usage",
    "href": "documentation/matlab/internals.html#usage",
    "title": "Internals",
    "section": "",
    "text": "% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes",
    "href": "documentation/matlab/internals.html#notes",
    "title": "Internals",
    "section": "",
    "text": "The recommended constructor is Q(i), where i is an integer representing a variable index.\nOther constructors are for internal use and may lead to incorrect results if misused.\nDO NOT use OR (|) inside the string input for Q, as it is not supported.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#combining-two-conditions-using-and",
    "href": "documentation/matlab/internals.html#combining-two-conditions-using-and",
    "title": "Internals",
    "section": "",
    "text": "Suppose we wanted to combine two conditions q1::Q and q2::Q using an AND. Thus, suppose we wanted to do\nq1 & q2\nThis is achieved by extending and for the type Q. However, key in the internal implementation is the following assumption.\n\n\n\n\n\n\nNote 1: Assumption 1\n\n\n\nThe transmission condition q consists of only conjunctions (&) and negations (!).\n\n\nUnder Assumption 1 q1 and q2 both consist of only conjunctions and disjunctions. This immediately implies that their conjunction will also only consist of conjunctions and negations. We can thus simply “concatenate” the two conditions. This is basically what we internally do, with the caveat that the conditions are represented using String and that, for algorithimic purposes, we prefer the variables to be ordered in the statement.\nThe detailed internal implementation is given by\n\n\n\n\n\n\n\nQ.and\n\n\n\n\n\n& combine two transmission conditions using logical AND.\nresult = q1 & q2 performs a logical AND operation between two transmission conditions, returning a new Q object. This is the same as \\(Q(b \\land b')\\) where \\(b\\) and \\(b'\\) are the Boolean conditions for q1 and q2 respectively.\n\n\n\nobj1 (Q): First transmission condition.\nobj2(Q): Second transmission condition.\n\n\n\n\n\nresult(Q): The combined transmission condition.\n\nExample:\nq1 = Q(1);\nq2 = Q(2);\nq = q1 & q2;  % Returns Q(\"x2 & x1\")\nSee also or (|), not (~)\n\n\n\n\n\nWhile concatenating the two conditions, we need to watch out that no contradictions are being introduced. Contradictions are any statements along the lines \\(x_i \\land \\neg x_i\\) which would always result in false. This is taken care of by the following functions.\n\n\n\n\n\n\n\ncheckContradiction\n\n\n\n\n\ncheckContradiction Check for contradictions of the form x1 & ~x1 (x1 & !x1).\n[hasContradiction, contradictions] = checkContradiction(varAnd, varNot) checks whether there is a contradiction where a variable appears in both varAnd and varNot, meaning it is simultaneously required and forbidden.\n\n\n\nvarAnd (vector or cell array of vectors): AND variable numbers obtained from getVarNumsAndMultiplier.\nvarNot (vector or cell array of vectors): NOT variable numbers obtained from getVarNumsAndMultiplier.\n\n\n\n\n\nhasContradiction (logical): True if any contradictions exist.\ncontradictions (vector of logicals): A vector indicating which elements yield a contradiction.\n\n\n\n\n\nThis function is used in removeContradictions to eliminate contradicting terms, which helps speed up the simplification process by reducing the total number of terms.\n\nSee also removeContradictions, getVarNumsAndMultiplier\n\n\n\n\n\n\n\n\n\n\n\n\nremoveContradictions\n\n\n\n\n\nremoveContradictions Remove contradicting terms from a transmission condition.\nq = removeContradictions(q) removes terms that contain contradictions of the form x_i & !x_i, which always evaluate to false and contribute zero to the transmission effect. Behaviour of the function can be changed by setting REMOVECONTRADICTIONS=false locally.\nArguments: - q (Q): A transmission condition. See also Q and makeCondition.\nReturns: - If REMOVECONTRADICTIONS is set to false, the input q is returned unchanged. - If REMOVECONTRADICTIONS is true or not set: 1. If all terms are contradicting, Q(\"T\", 0) is returned, which represents a transmission effect of zero. 2. If some terms are non-contradicting, only the non-contradicting terms are retained in the output.\n\n\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.\n\n\n\n\nIf REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.\n\n\n\n\n\n\nAs stated in the overview of the documentation, removal of contradictions is governed by the global REMOVECONTRADICTION and the utility function setRemoveContradictions. Not removing contradictions does not lead to mistakes in the computation, but can result in longer computations. Contrary, removing contradictions can lead to longer compile times – it takes longer to compile the transmission conditions. Thus, a trade-off between compile and computing time exists.\n\n\n\n\n\n\n\nsetRemoveContradictions\n\n\n\n\n\nsetRemoveContradictions Set the global flag for removing contradictions in transmission conditions.\nsetRemoveContradictions(bool) controls whether contradictions in transmission conditions are removed when calling setRemoveContradictions.\n\n\n\nbool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.\n\n\n\n\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments",
    "href": "documentation/matlab/internals.html#arguments",
    "title": "Internals",
    "section": "",
    "text": "obj1 (Q): First transmission condition.\nobj2(Q): Second transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns",
    "href": "documentation/matlab/internals.html#returns",
    "title": "Internals",
    "section": "",
    "text": "result(Q): The combined transmission condition.\n\nExample:\nq1 = Q(1);\nq2 = Q(2);\nq = q1 & q2;  % Returns Q(\"x2 & x1\")\nSee also or (|), not (~)",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-1",
    "href": "documentation/matlab/internals.html#arguments-1",
    "title": "Internals",
    "section": "",
    "text": "varAnd (vector or cell array of vectors): AND variable numbers obtained from getVarNumsAndMultiplier.\nvarNot (vector or cell array of vectors): NOT variable numbers obtained from getVarNumsAndMultiplier.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns-1",
    "href": "documentation/matlab/internals.html#returns-1",
    "title": "Internals",
    "section": "",
    "text": "hasContradiction (logical): True if any contradictions exist.\ncontradictions (vector of logicals): A vector indicating which elements yield a contradiction.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes-1",
    "href": "documentation/matlab/internals.html#notes-1",
    "title": "Internals",
    "section": "",
    "text": "This function is used in removeContradictions to eliminate contradicting terms, which helps speed up the simplification process by reducing the total number of terms.\n\nSee also removeContradictions, getVarNumsAndMultiplier",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example",
    "href": "documentation/matlab/internals.html#example",
    "title": "Internals",
    "section": "",
    "text": "setRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes-2",
    "href": "documentation/matlab/internals.html#notes-2",
    "title": "Internals",
    "section": "",
    "text": "If REMOVECONTRADICTIONS is not explicitly set, contradictions are removed by default.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-2",
    "href": "documentation/matlab/internals.html#arguments-2",
    "title": "Internals",
    "section": "",
    "text": "bool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example-1",
    "href": "documentation/matlab/internals.html#example-1",
    "title": "Internals",
    "section": "",
    "text": "% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#combining-two-conditions-using-or",
    "href": "documentation/matlab/internals.html#combining-two-conditions-using-or",
    "title": "Internals",
    "section": "",
    "text": "Let q1 and q2 be again two transmission conditions. Suppose their internal Boolean conditions are given by \\(b\\) and \\(b'\\) respectively, with both satisfying Assumption 1. The rules for manipulating transmission conditions then imply \\[\nQ(b \\lor b') = Q(b) + Q(b') - Q(b \\land b').\n\\] Implementation of OR (|) therefore simply uses AND and the ability for Q to represent multiple terms with different multipliers. The precise implementation of OR can be found in the following function.\n\n\n\n\n\n\n\nQ.or\n\n\n\n\n\n| Combine two transmission conditions using a logical OR.\nresult = q1 | q2 performs a logical OR operation between two transmission conditions, returning a new Q object.\n\n\n\nobj1 (Q): First transmission condition.\nobj2 (Q): Second transmission condition.\n\n\n\n\n\nresult (Q): The combined transmission condition.\n\n\n\n\nq1 = Q(1);\nq2 = Q(2);\nq = q1 | q2;\nSee also and (&), not (~)",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-3",
    "href": "documentation/matlab/internals.html#arguments-3",
    "title": "Internals",
    "section": "",
    "text": "obj1 (Q): First transmission condition.\nobj2 (Q): Second transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns-2",
    "href": "documentation/matlab/internals.html#returns-2",
    "title": "Internals",
    "section": "",
    "text": "result (Q): The combined transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example-2",
    "href": "documentation/matlab/internals.html#example-2",
    "title": "Internals",
    "section": "",
    "text": "q1 = Q(1);\nq2 = Q(2);\nq = q1 | q2;\nSee also and (&), not (~)",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#negating-a-condition-using-not",
    "href": "documentation/matlab/internals.html#negating-a-condition-using-not",
    "title": "Internals",
    "section": "",
    "text": "Suppose a transmission condition is given by q which internally represents the Boolean condition \\(b\\). By the rules for manipulating transmission conditions we then know that \\[\nQ(\\neg b) = Q(T) - Q(b),\n\\] where \\(T\\) represents the Boolean condition that is always true. This can easily be represented using Q through its ability to represent multiple terms and multipliers. Specifically, we simply replace the original transmission condition with a new one that consists of one additional term, representing true, and switch the sign of all original terms of the condition. The following function implements this behaviour.\n\n\n\n\n\n\n\nQ.not\n\n\n\n\n\n~ Negate a boolean condition using the logican NOT.\nresult = ~q negates a transmission condition, creating a condition where the given Boolean statement does not hold.\n\n\n\nobj (Q): A transmission condition to negate.\n\n\n\n\n\nresult (Q): The negated transmission condition.\n\n\n\n\nq1 = Q(1);\nq = ~q1;\n\n\n\n\nIf the condition consists of a single variable, it is simply negated.\nIf the condition is more complex, an auxiliary \"T\" (true) condition is used and the returned condition is equivalent to \\(Q(T) - Q(b)\\) where \\(b\\) is the origional Boolean condition.\n\nSee also and (&), or (|)",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-4",
    "href": "documentation/matlab/internals.html#arguments-4",
    "title": "Internals",
    "section": "",
    "text": "obj (Q): A transmission condition to negate.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns-3",
    "href": "documentation/matlab/internals.html#returns-3",
    "title": "Internals",
    "section": "",
    "text": "result (Q): The negated transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example-3",
    "href": "documentation/matlab/internals.html#example-3",
    "title": "Internals",
    "section": "",
    "text": "q1 = Q(1);\nq = ~q1;",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes-3",
    "href": "documentation/matlab/internals.html#notes-3",
    "title": "Internals",
    "section": "",
    "text": "If the condition consists of a single variable, it is simply negated.\nIf the condition is more complex, an auxiliary \"T\" (true) condition is used and the returned condition is equivalent to \\(Q(T) - Q(b)\\) where \\(b\\) is the origional Boolean condition.\n\nSee also and (&), or (|)",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#parsing-transmission-conditions-using-makecondition",
    "href": "documentation/matlab/internals.html#parsing-transmission-conditions-using-makecondition",
    "title": "Internals",
    "section": "",
    "text": "Rather than letting the user create all variables manually via x1 = Q(1) etc., we provide the function makeCondition. This function simply matches all variables in a string with the regex x\\d+, creates the variables using the above way, and then evaluates the entire condition to create the final condition. Due to the operator overloading above, the final result will be a valid and correct transmission condtion. However, key to this correctness is that all variables match the provided regex pattern. Thus, all variables must be of the form x1, x2, etc.\nFor user friendliness, we also provide a version of makeConditionY that takes variables of the dynamic form, i.e. \\(y_{i,t}\\). However, all that this function does is to translate all variables into variables of the systems form and then calls the method explained above.\nIn any case, makeCondition and makeConditionY should be seen as utility functions with the main funcionality being dependent on correct implementation of Q, &, |, and ~ as explained above.\n\n\n\n\n\n\n\nmakeCondition\n\n\n\n\n\nmakeCondition Create a transmission condition from a Boolean string.\nq = makeCondition(s) constructs a transmission condition \\(Q(b)\\) from a Boolean statement given as a string. The Boolean expression should use variables of the systems form x&lt;num&gt;, where &lt;num&gt; represents a variable index.\n\n\n\ns (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.\n\n\n\n\n\nq (Q): A transmission condition.\n\n\n\n\ns = \"x2 & !x3\";\ncond = makeCondition(s);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY\n\n\n\n\n\n\n\n\n\n\n\n\nmakeConditionY\n\n\n\n\n\nmakeConditionY Create a transmission condition from a Boolean string using dyanmic form variables.\nq = makeConditionY(strY, order) constructs a transmission condition \\(Q(b)\\) from a Boolean statement specified in terms of dynamic system variables (i.e., y_{i,t} notation).\n\n\n\nstrY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.\n\n\n\n\n\nq (Q): A transmission condition object.\n\n\n\n\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-5",
    "href": "documentation/matlab/internals.html#arguments-5",
    "title": "Internals",
    "section": "",
    "text": "s (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns-4",
    "href": "documentation/matlab/internals.html#returns-4",
    "title": "Internals",
    "section": "",
    "text": "q (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example-4",
    "href": "documentation/matlab/internals.html#example-4",
    "title": "Internals",
    "section": "",
    "text": "s = \"x2 & !x3\";\ncond = makeCondition(s);",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes-4",
    "href": "documentation/matlab/internals.html#notes-4",
    "title": "Internals",
    "section": "",
    "text": "Boolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#arguments-6",
    "href": "documentation/matlab/internals.html#arguments-6",
    "title": "Internals",
    "section": "",
    "text": "strY (string): A Boolean condition string where variables are represented as y_{i,t}, with i as the variable index and t &gt;= 0 as the time period. t=0 corresponds to the contemporaneous horizon.\norder (vector of integers): The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#returns-5",
    "href": "documentation/matlab/internals.html#returns-5",
    "title": "Internals",
    "section": "",
    "text": "q (Q): A transmission condition object.",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#example-5",
    "href": "documentation/matlab/internals.html#example-5",
    "title": "Internals",
    "section": "",
    "text": "s_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#notes-5",
    "href": "documentation/matlab/internals.html#notes-5",
    "title": "Internals",
    "section": "",
    "text": "Boolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeCondition",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/internals.html#footnotes",
    "href": "documentation/matlab/internals.html#footnotes",
    "title": "Internals",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that Matlab uses ~ as the NOT operator. Internally we tend to use !.↩︎",
    "crumbs": [
      "Home",
      "Matlab",
      "Internals"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/slideIn.html",
    "href": "documentation/matlab/all-functions/slideIn.html",
    "title": "slideIn",
    "section": "",
    "text": "slideIn\n\n\n\n\n\nEnsure A can slide into B",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "slideIn"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyAndToB.html",
    "href": "documentation/matlab/all-functions/applyAndToB.html",
    "title": "applyAndToB",
    "section": "",
    "text": "applyAndToB\n\n\n\n\n\napplyAndToB Manipulate B and Omega to ensure var lies on all paths.\napplyAndToB(B, Omega, from, var) modifies the matrices B and Omega such that the variable indexed by var is present on all paths. This is achieved by: - Zeroing out all edges going directly from the shock (indexed by from) to any variables ordered after var. - Zeroing out any edges going from variables ordered before var to any variables ordered after var.\n\n\n\nB (matrix): Part of the system’s representation.\nOmega (matrix): Part of the system’s representation.\nfrom (integer): The shock index.\nvar (integer): The variable index that must lie on all paths.\n\n\n\n\n\nThis function is intended for internal use only.\n\nSee also applyNotToB, makeB, makeOmega, and makeSystemsForm.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyAndToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyAndToB.html#arguments",
    "href": "documentation/matlab/all-functions/applyAndToB.html#arguments",
    "title": "applyAndToB",
    "section": "",
    "text": "B (matrix): Part of the system’s representation.\nOmega (matrix): Part of the system’s representation.\nfrom (integer): The shock index.\nvar (integer): The variable index that must lie on all paths.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyAndToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/applyAndToB.html#notes",
    "href": "documentation/matlab/all-functions/applyAndToB.html#notes",
    "title": "applyAndToB",
    "section": "",
    "text": "This function is intended for internal use only.\n\nSee also applyNotToB, makeB, makeOmega, and makeSystemsForm.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "applyAndToB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html",
    "href": "documentation/matlab/all-functions/VAR.html",
    "title": "VAR",
    "section": "",
    "text": "VAR\n\n\n\n\n\nVAR Vector Autoregressive (VAR) model in matrix form.\nA VAR of lag order p is specified as:\ny_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\nwhere: - e_t is a vector of deterministic components (constant, trends, etc). - C, B_i are conformable coefficient matrices. - u_t is vector white noise.\nCompac```{.matlab}orm:\ny_t' = z_t' B_+' + u_t'\nwith: - z_t = [e_t; y_{t-1}; ...; y_{t-p}] - B_+ = [C, B_1, ..., B_p]\nStacking from ```{.matlab} p+1 to T:\nY = X B_+' + U\n\n\n\nB (matrix): Coefficient matrix `[C B_1 … B_p].\nSigmaU (matrix): Covariance matrix of the error term.\np (integer): Lag order of the VAR.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1] implies constant and linear trend).\ninputData (table or matrix): Original data used to estimate the VAR.\nY (matrix): Left-hand side outcomes y_t, size (T-p) x k.\nX (matrix): Right-hand side regressors z_t, size (T-p) x (k*p + m) where m is the number of deterministic domponents.\nU (matrix): Residuals u_t, size (T-p) x k.\nYhat (matrix): Fitted values X * B_+', size (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#properties",
    "href": "documentation/matlab/all-functions/VAR.html#properties",
    "title": "VAR",
    "section": "",
    "text": "B (matrix): Coefficient matrix `[C B_1 … B_p].\nSigmaU (matrix): Covariance matrix of the error term.\np (integer): Lag order of the VAR.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1] implies constant and linear trend).\ninputData (table or matrix): Original data used to estimate the VAR.\nY (matrix): Left-hand side outcomes y_t, size (T-p) x k.\nX (matrix): Right-hand side regressors z_t, size (T-p) x (k*p + m) where m is the number of deterministic domponents.\nU (matrix): Residuals u_t, size (T-p) x k.\nYhat (matrix): Fitted values X * B_+', size (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments",
    "href": "documentation/matlab/all-functions/VAR.html#arguments",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nB (matrix): Coefficient matrix [C B_1 ... B_p], where C are coefficients on deterministic components and B_i are lag matrices.\np (integer): Lag order of the VAR.\nm (integer): Number of deterministic components.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns",
    "href": "documentation/matlab/all-functions/VAR.html#returns",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nC (matrix): Companion matrix of the VAR(p) system.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#notes",
    "href": "documentation/matlab/all-functions/VAR.html#notes",
    "title": "VAR",
    "section": "Notes",
    "text": "Notes\n\nThe companion matrix has the structure:\n\n\\[\n\\begin{bmatrix}\nB_1 & B_2 & \\cdots & B_p \\\\\nI   & 0   & \\cdots & 0 \\\\\n0   & I   & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0   & 0   & \\cdots & I\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-1",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-1",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-1",
    "href": "documentation/matlab/all-functions/VAR.html#returns-1",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nYhat (matrix): Matrix of fitted values.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-2",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-2",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-2",
    "href": "documentation/matlab/all-functions/VAR.html#returns-2",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed SIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-3",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-3",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nB (matrix): Stacked coefficient matrix [B_1 ... B_p], excluding deterministic components.\np (integer): Lag order of the VAR.\nmaxHorizon (integer): Maximum horizon for IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-3",
    "href": "documentation/matlab/all-functions/VAR.html#returns-3",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nirfs (3D array): Impulse responses of size (k x k x (maxHorizon+1)), where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (impulses).\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#notes-1",
    "href": "documentation/matlab/all-functions/VAR.html#notes-1",
    "title": "VAR",
    "section": "Notes",
    "text": "Notes\n\nB must not include coefficients on deterministic components (such as constants or trends).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-4",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-4",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod): Required method to compute structural IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-4",
    "href": "documentation/matlab/all-functions/VAR.html#returns-4",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (of size one for the single selected shock).\nThird dimension: Horizon.\n\nSee also VAR.through, VAR.notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-5",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-5",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-5",
    "href": "documentation/matlab/all-functions/VAR.html#returns-5",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed HQC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-6",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-6",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nC (matrix): Companion matrix of the VAR model.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-6",
    "href": "documentation/matlab/all-functions/VAR.html#returns-6",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nrho (number): Spectral radius of the companion matrix.\n\nSee also makeCompanionMatrix_",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-7",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-7",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-7",
    "href": "documentation/matlab/all-functions/VAR.html#returns-7",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): SIC value.\n\nSee also aic, hqc, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-8",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-8",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-8",
    "href": "documentation/matlab/all-functions/VAR.html#returns-8",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed AIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-9",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-9",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-9",
    "href": "documentation/matlab/all-functions/VAR.html#returns-9",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nC (matrix): Companion matrix of the VAR(p)",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-10",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-10",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-11",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-11",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\ndata (table or matrix): Input dataset for the VAR model.\np (integer): Lag order of the VAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nB (matrix): Coefficient matrix. Default is empty (must be estimated).\nSigmaU (matrix): Covariance matrix of residuals. Default is empty (must be estimated).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-10",
    "href": "documentation/matlab/all-functions/VAR.html#returns-10",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nobj (VAR): A VAR model.\n\nSee also fit, simulate",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-12",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-12",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-11",
    "href": "documentation/matlab/all-functions/VAR.html#returns-11",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): BIC value.\n\nSee also aic, hqc, sic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-13",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-13",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nct (number): Complexity term adjusting for sample size.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-12",
    "href": "documentation/matlab/all-functions/VAR.html#returns-12",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed information criterion value.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-14",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-14",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nerrorsOrT (matrix or integer): Either a (k x T) matrix of error terms or an integer specifying the number of periods T to simulate.\nB (matrix): Coefficient matrix [C B_1 ... B_p] where p is the lag order.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Default is [0] (constant term).\ninitial (vector): Initial values for lags, size (p*k, 1). Default is zeros.\nSigmaU (matrix): Covariance matrix for error generation if simulating errors. Default is identity matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-13",
    "href": "documentation/matlab/all-functions/VAR.html#returns-13",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nY (matrix): Simulated data matrix, size (T x k).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-15",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-15",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-14",
    "href": "documentation/matlab/all-functions/VAR.html#returns-14",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nB (matrix): VAR coefficient matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-16",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-16",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-15",
    "href": "documentation/matlab/all-functions/VAR.html#returns-15",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nU (matrix): Matrix of residuals.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-17",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-17",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-16",
    "href": "documentation/matlab/all-functions/VAR.html#returns-16",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (VAR): Best fitting model.\nicTable (table): Table of lag lengths and IC values.\n\nSee also fit, aic, bic, hqc, sic",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-18",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-18",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nSigmaU (matrix): Covariance matrix of the VAR residuals.\nnCoeffs (integer): Total number of estimated coefficients.\nT (integer): Number of effective observations.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-17",
    "href": "documentation/matlab/all-functions/VAR.html#returns-17",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): Computed BIC value.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#notes-2",
    "href": "documentation/matlab/all-functions/VAR.html#notes-2",
    "title": "VAR",
    "section": "Notes",
    "text": "Notes\n\nBIC is the same as SIC.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-19",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-19",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-18",
    "href": "documentation/matlab/all-functions/VAR.html#returns-18",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nrho (number): Spectral radius of the companion matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-20",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-20",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-19",
    "href": "documentation/matlab/all-functions/VAR.html#returns-19",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): AIC value.\n\nSee also hqc, sic, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-21",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-21",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-20",
    "href": "documentation/matlab/all-functions/VAR.html#returns-20",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nflag (logical): True if the model is stable, false otherwise.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-22",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-22",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-21",
    "href": "documentation/matlab/all-functions/VAR.html#returns-21",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): HQC value.\n\nSee also aic, sic, bic, fit",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-23",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-23",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (VAR): VAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.\nvarargin: Name-value pairs for options:\nidentificationMethod (an IdentificationMethod): Optional method to compute structural IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-22",
    "href": "documentation/matlab/all-functions/VAR.html#returns-22",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Object containing computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#notes-3",
    "href": "documentation/matlab/all-functions/VAR.html#notes-3",
    "title": "VAR",
    "section": "Notes",
    "text": "Notes\n\nWithout an identification method, reduced-form IRFs are computed.\nWith an identification method, structural IRFs are computed.\n\nSee also IRF_, IRFContainer, fit, IdentificationMethod",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#arguments-24",
    "href": "documentation/matlab/all-functions/VAR.html#arguments-24",
    "title": "VAR",
    "section": "Arguments",
    "text": "Arguments\n\nB (matrix): Stacked coefficient matrix excluding deterministic components (i.e., the matrix does not include the constant or trend coefficients C). Size is (k, k*p) where k is the number of variables and p is the lag order.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#returns-23",
    "href": "documentation/matlab/all-functions/VAR.html#returns-23",
    "title": "VAR",
    "section": "Returns",
    "text": "Returns\n\nBCellArray (cell array): A 1-by-p cell array where each cell contains the (k x k) lag coefficient matrix for one lag.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/VAR.html#notes-4",
    "href": "documentation/matlab/all-functions/VAR.html#notes-4",
    "title": "VAR",
    "section": "Notes",
    "text": "Notes\n\nAssumes that B has already been stripped of coefficients on deterministic components.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/logdet.html",
    "href": "documentation/matlab/all-functions/logdet.html",
    "title": "logdet",
    "section": "",
    "text": "logdet\n\n\n\n\n\nlogdet Compute the log determinant of a covariance matrix.\nval = logdet(Sigma) returns the log determinant of the symmetric positive definite matrix Sigma.\n\n\n\nSigma (matrix): Symmetric positive definite matrix.\n\n\n\n\n\nval (number): Log determinant of Sigma.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "logdet"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/logdet.html#arguments",
    "href": "documentation/matlab/all-functions/logdet.html#arguments",
    "title": "logdet",
    "section": "",
    "text": "Sigma (matrix): Symmetric positive definite matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "logdet"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/logdet.html#returns",
    "href": "documentation/matlab/all-functions/logdet.html#returns",
    "title": "logdet",
    "section": "",
    "text": "val (number): Log determinant of Sigma.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "logdet"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/findVariableIndex.html",
    "href": "documentation/matlab/all-functions/findVariableIndex.html",
    "title": "findVariableIndex",
    "section": "",
    "text": "findVariableIndex\n\n\n\n\n\nfindVariableIndex Find column index of a variable in a table.\nidx = findVariableIndex(data, variable) returns the index of variable in the table data.\n\n\n\ndata (table): Dataset containing variable columns.\nvariable (char or integer): Name or index of the variable.\n\n\n\n\n\nidx (integer): Column index of the variable.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "findVariableIndex"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/findVariableIndex.html#arguments",
    "href": "documentation/matlab/all-functions/findVariableIndex.html#arguments",
    "title": "findVariableIndex",
    "section": "",
    "text": "data (table): Dataset containing variable columns.\nvariable (char or integer): Name or index of the variable.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "findVariableIndex"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/findVariableIndex.html#returns",
    "href": "documentation/matlab/all-functions/findVariableIndex.html#returns",
    "title": "findVariableIndex",
    "section": "",
    "text": "idx (integer): Column index of the variable.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "findVariableIndex"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLeadMatrix.html",
    "href": "documentation/matlab/all-functions/makeLeadMatrix.html",
    "title": "makeLeadMatrix",
    "section": "",
    "text": "makeLeadMatrix\n\n\n\n\n\nmakeLeadMatrix Create lead matrix from input data.\nleadMatrix = makeLeadMatrix(Y, p) returns a matrix where columns contain 1 to p leads of Y.\n\n\n\nY (matrix): Input data matrix (T x k).\np (integer): Number of leads.\n\n\n\n\n\nleadMatrix (matrix): Matrix of lead values. First k columns are lead 1, next k are lead 2, and so on.\n\n\n\n\n\nMissing values due to leading are filled with NaN.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLeadMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLeadMatrix.html#arguments",
    "href": "documentation/matlab/all-functions/makeLeadMatrix.html#arguments",
    "title": "makeLeadMatrix",
    "section": "",
    "text": "Y (matrix): Input data matrix (T x k).\np (integer): Number of leads.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLeadMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLeadMatrix.html#returns",
    "href": "documentation/matlab/all-functions/makeLeadMatrix.html#returns",
    "title": "makeLeadMatrix",
    "section": "",
    "text": "leadMatrix (matrix): Matrix of lead values. First k columns are lead 1, next k are lead 2, and so on.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLeadMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLeadMatrix.html#notes",
    "href": "documentation/matlab/all-functions/makeLeadMatrix.html#notes",
    "title": "makeLeadMatrix",
    "section": "",
    "text": "Missing values due to leading are filled with NaN.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLeadMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/setRemoveContradictions.html",
    "href": "documentation/matlab/all-functions/setRemoveContradictions.html",
    "title": "setRemoveContradictions",
    "section": "",
    "text": "setRemoveContradictions\n\n\n\n\n\nsetRemoveContradictions Set the global flag for removing contradictions in transmission conditions.\nsetRemoveContradictions(bool) controls whether contradictions in transmission conditions are removed when calling setRemoveContradictions.\n\n\n\nbool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.\n\n\n\n\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "setRemoveContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/setRemoveContradictions.html#arguments",
    "href": "documentation/matlab/all-functions/setRemoveContradictions.html#arguments",
    "title": "setRemoveContradictions",
    "section": "",
    "text": "bool (logical): If true, contradictions of the form “x_i & !x_i” will be removed from transmission conditions. If false, contradictions will not be removed.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "setRemoveContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/setRemoveContradictions.html#example",
    "href": "documentation/matlab/all-functions/setRemoveContradictions.html#example",
    "title": "setRemoveContradictions",
    "section": "",
    "text": "% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\nSee also removeContradictions",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "setRemoveContradictions"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeB.html",
    "href": "documentation/matlab/all-functions/makeB.html",
    "title": "makeB",
    "section": "",
    "text": "makeB\n\n\n\n\n\nmakeB Construct the matrix B in the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\n\n\nAs (cell array of matrices): Autoregressive coefficient matrices.\nSigma (matrix): Covariance matrix of the shocks.\norder (vector): Ordering of variables given by the transmission matrix.\nmaxHorizon (integer): Maximum IRF horizon.\n\n\n\n\n\nB (matrix): Part of the sytems representation.\n\nSee also makeOmega, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeB.html#arguments",
    "href": "documentation/matlab/all-functions/makeB.html#arguments",
    "title": "makeB",
    "section": "",
    "text": "As (cell array of matrices): Autoregressive coefficient matrices.\nSigma (matrix): Covariance matrix of the shocks.\norder (vector): Ordering of variables given by the transmission matrix.\nmaxHorizon (integer): Maximum IRF horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeB.html#returns",
    "href": "documentation/matlab/all-functions/makeB.html#returns",
    "title": "makeB",
    "section": "",
    "text": "B (matrix): Part of the sytems representation.\n\nSee also makeOmega, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeB"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmission.html",
    "href": "documentation/matlab/all-functions/transmission.html",
    "title": "transmission",
    "section": "",
    "text": "transmission\n\n\n\n\n\ntransmission Compute the transmission effect given a transmission condition.\neffects = transmission(from, arr1, arr2, q, method) calculates the transmission effect for a given transmission condition q using either the BOmega method or the irf method. If BOmega is used, then transmission effects will be calculated using the systems form \\(x = Bx + \\Omega\\varepsilon\\)\n\n\n\nfrom (integer): Index of the shock.\narr1 (matrix):\nIf method = \"BOmega\", this must be B from the systems form.\nIf method = \"irf\", this must be structural irfs (technically only those of the shock that is being investigates (from)). Has to be a IRF matrix. See toTransmissionIrfs for more information.\narr2 (matrix):\nIf method = \"BOmega\", this must be Omega from the systems form.\nIf method = \"irf\", this must be irfsOrtho (Cholesky IRFs) following the ordering of the transmission matrix.\nq (Q): A transmission condition. See also Q.\nmethod (string): Specifies the calculation method:\n\"BOmega\" uses the systems form.\n\"irf\" uses only IRFs and can thus be used with local projections.\norder (vector, optional): variable ordering as defined by the transmission matrix.\n\n\n\n\n\neffects (vector): A vector where entry i corresponds to the transmission effect on variable x_i. If x_k is the variable in the transmission condition with the highest index, all entries in the returned vector with index less than k are NaN, since interpretation of those results is nonsensical.\n\n\n\n\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\neffect = transmission(1, B, Omega, cond, \"BOmega\");\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\neffect = transmission(1, irfs, irfsOrtho, cond, \"irf\");\n\n\n\n\nIf method = \"BOmega\", the function applies transmissionBOmega.\nIf method = \"irf\", the function applies transmissionIrfs.\nIf order is provided, the returned effects will be a 3D array of dimension (nVariables, 1, horizons) where the variables are in the original ordering (before applying the transmission matrix).\nIf order is not provided, the returned effects will be a (nVariable*horizons, 1) dimensional vector following the ordering after applying the transmission matrix. This is similar to the matrix obtained via \\((I - B)^{-1}\\Omega\\) using the matrices from the systems form.\n\nSee also transmissionBOmega, transmissionIrfs, makeCondition, through, notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmission.html#arguments",
    "href": "documentation/matlab/all-functions/transmission.html#arguments",
    "title": "transmission",
    "section": "",
    "text": "from (integer): Index of the shock.\narr1 (matrix):\nIf method = \"BOmega\", this must be B from the systems form.\nIf method = \"irf\", this must be structural irfs (technically only those of the shock that is being investigates (from)). Has to be a IRF matrix. See toTransmissionIrfs for more information.\narr2 (matrix):\nIf method = \"BOmega\", this must be Omega from the systems form.\nIf method = \"irf\", this must be irfsOrtho (Cholesky IRFs) following the ordering of the transmission matrix.\nq (Q): A transmission condition. See also Q.\nmethod (string): Specifies the calculation method:\n\"BOmega\" uses the systems form.\n\"irf\" uses only IRFs and can thus be used with local projections.\norder (vector, optional): variable ordering as defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmission.html#returns",
    "href": "documentation/matlab/all-functions/transmission.html#returns",
    "title": "transmission",
    "section": "",
    "text": "effects (vector): A vector where entry i corresponds to the transmission effect on variable x_i. If x_k is the variable in the transmission condition with the highest index, all entries in the returned vector with index less than k are NaN, since interpretation of those results is nonsensical.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmission.html#example",
    "href": "documentation/matlab/all-functions/transmission.html#example",
    "title": "transmission",
    "section": "",
    "text": "k = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\neffect = transmission(1, B, Omega, cond, \"BOmega\");\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\neffect = transmission(1, irfs, irfsOrtho, cond, \"irf\");",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmission.html#notes",
    "href": "documentation/matlab/all-functions/transmission.html#notes",
    "title": "transmission",
    "section": "",
    "text": "If method = \"BOmega\", the function applies transmissionBOmega.\nIf method = \"irf\", the function applies transmissionIrfs.\nIf order is provided, the returned effects will be a 3D array of dimension (nVariables, 1, horizons) where the variables are in the original ordering (before applying the transmission matrix).\nIf order is not provided, the returned effects will be a (nVariable*horizons, 1) dimensional vector following the ordering after applying the transmission matrix. This is similar to the matrix obtained via \\((I - B)^{-1}\\Omega\\) using the matrices from the systems form.\n\nSee also transmissionBOmega, transmissionIrfs, makeCondition, through, notThrough",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeCondition.html",
    "href": "documentation/matlab/all-functions/makeCondition.html",
    "title": "makeCondition",
    "section": "",
    "text": "makeCondition\n\n\n\n\n\nmakeCondition Create a transmission condition from a Boolean string.\nq = makeCondition(s) constructs a transmission condition \\(Q(b)\\) from a Boolean statement given as a string. The Boolean expression should use variables of the systems form x&lt;num&gt;, where &lt;num&gt; represents a variable index.\n\n\n\ns (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.\n\n\n\n\n\nq (Q): A transmission condition.\n\n\n\n\ns = \"x2 & !x3\";\ncond = makeCondition(s);\n\n\n\n\nBoolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeCondition"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeCondition.html#arguments",
    "href": "documentation/matlab/all-functions/makeCondition.html#arguments",
    "title": "makeCondition",
    "section": "",
    "text": "s (string): A Boolean condition string where variables must be represented using x&lt;num&gt;.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeCondition"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeCondition.html#returns",
    "href": "documentation/matlab/all-functions/makeCondition.html#returns",
    "title": "makeCondition",
    "section": "",
    "text": "q (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeCondition"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeCondition.html#example",
    "href": "documentation/matlab/all-functions/makeCondition.html#example",
    "title": "makeCondition",
    "section": "",
    "text": "s = \"x2 & !x3\";\ncond = makeCondition(s);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeCondition"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeCondition.html#notes",
    "href": "documentation/matlab/all-functions/makeCondition.html#notes",
    "title": "makeCondition",
    "section": "",
    "text": "Boolean conditions can include AND (&), NOT (! or ~), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\nSee also transmission, makeConditionY",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeCondition"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/IdentificationMethod.html",
    "href": "documentation/matlab/all-functions/IdentificationMethod.html",
    "title": "IdentificationMethod",
    "section": "",
    "text": "IdentificationMethod\n\n\n\n\n\nIdentificationMethod Abstract class for structural identification.\nThis abstract class specifies the interface for identification methods that recover structural models and IRFs from reduced-form models.\n\n\n\nirfs = identifyIrfs(obj, model, maxHorizon)\n\n\nIdentifies IRFs from the reduced form model.\nReturns a 3D array with dimensions: (response variable, shock, horizon).\nIRFs should be computed up to maxHorizon.\n\n\n[varargout] = identify(obj, model)\n\n\nIdentifies the structural form of a reduced form model.\nFor SVARs from VARs:\nvarargout{1} = A0 (contemporaneous matrix)\nvarargout{2} = APlus (lag polynomial matrix)\nFor LPs:\nvarargout{1} = coefficient estimates per horizon.\n\n\n\n\n\nSee the Recursive class for an example implementation.\n\nSee also Recursive, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "IdentificationMethod"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/IdentificationMethod.html#required-methods",
    "href": "documentation/matlab/all-functions/IdentificationMethod.html#required-methods",
    "title": "IdentificationMethod",
    "section": "",
    "text": "irfs = identifyIrfs(obj, model, maxHorizon)\n\n\nIdentifies IRFs from the reduced form model.\nReturns a 3D array with dimensions: (response variable, shock, horizon).\nIRFs should be computed up to maxHorizon.\n\n\n[varargout] = identify(obj, model)\n\n\nIdentifies the structural form of a reduced form model.\nFor SVARs from VARs:\nvarargout{1} = A0 (contemporaneous matrix)\nvarargout{2} = APlus (lag polynomial matrix)\nFor LPs:\nvarargout{1} = coefficient estimates per horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "IdentificationMethod"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/IdentificationMethod.html#notes",
    "href": "documentation/matlab/all-functions/IdentificationMethod.html#notes",
    "title": "IdentificationMethod",
    "section": "",
    "text": "See the Recursive class for an example implementation.\n\nSee also Recursive, SVAR, LP",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "IdentificationMethod"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionBOmega.html",
    "href": "documentation/matlab/all-functions/transmissionBOmega.html",
    "title": "transmissionBOmega",
    "section": "",
    "text": "transmissionBOmega\n\n\n\n\n\ntransmissionBOmega Compute the transmission effect using the BOmega method.\neffects = transmissionBOmega(from, B, Omega, varAnd, varNot, multiplier) calculates the transmission effect based on the systems form \\(x = Bx + \\Omega\\varepsilon\\).\n\n\n\nfrom (integer): Index of the shock.\nB (matrix): See the systems form.\nOmega (matrix): See the systems form.\nvarAnd (cell array of vectors): Each cell contains a vector of variable indices that must be included (AND conditions). Can be obtained using getVarNumsAndMultiplier.\nvarNot (cell array of vectors): Each cell contains a vector of variable indices that must be excluded (NOT conditions). Can be obtained using getVarNumsAndMultiplier.\nmultiplier (vector of numbers): Multipliers associated with each term. Can be obtained using getVarNumsAndMultiplier.\n\n\n\n\n\neffects (vector): A vector where entry i corresponds to the transmission effect on variable x_i.\n\n\n\n\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionBOmega(1, B, Omega, varAnd, varNot, multiplier);\n\n\n\nInternal function. Should not be called by users directly.\nSee also transmission, applyAndToB, applyNotToB, getVarNumsAndMultiplier",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionBOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionBOmega.html#arguments",
    "href": "documentation/matlab/all-functions/transmissionBOmega.html#arguments",
    "title": "transmissionBOmega",
    "section": "",
    "text": "from (integer): Index of the shock.\nB (matrix): See the systems form.\nOmega (matrix): See the systems form.\nvarAnd (cell array of vectors): Each cell contains a vector of variable indices that must be included (AND conditions). Can be obtained using getVarNumsAndMultiplier.\nvarNot (cell array of vectors): Each cell contains a vector of variable indices that must be excluded (NOT conditions). Can be obtained using getVarNumsAndMultiplier.\nmultiplier (vector of numbers): Multipliers associated with each term. Can be obtained using getVarNumsAndMultiplier.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionBOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionBOmega.html#returns",
    "href": "documentation/matlab/all-functions/transmissionBOmega.html#returns",
    "title": "transmissionBOmega",
    "section": "",
    "text": "effects (vector): A vector where entry i corresponds to the transmission effect on variable x_i.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionBOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionBOmega.html#example",
    "href": "documentation/matlab/all-functions/transmissionBOmega.html#example",
    "title": "transmissionBOmega",
    "section": "",
    "text": "k = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionBOmega(1, B, Omega, varAnd, varNot, multiplier);",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionBOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/transmissionBOmega.html#warning",
    "href": "documentation/matlab/all-functions/transmissionBOmega.html#warning",
    "title": "transmissionBOmega",
    "section": "",
    "text": "Internal function. Should not be called by users directly.\nSee also transmission, applyAndToB, applyNotToB, getVarNumsAndMultiplier",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "transmissionBOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html",
    "href": "documentation/matlab/all-functions/SVAR.html",
    "title": "SVAR",
    "section": "",
    "text": "SVAR\n\n\n\n\n\nSVAR Structural Vector Autoregressive (SVAR) model.\nAn SVAR of lag order p is specified as:\nA0 y_t = C e_t + A1 y_{t-1} + ... + Ap y_{t-p} + \\varepsilon_t\nwhere: - e_t is a vector of deterministic components (constant, trends). - C, A0, Ai are conformable matrices. - \\varepsilon_t are structural shocks.\nAssuming A0 is invertible, the model can be rewritten as a reduced-fo```{.matlab}VAR:\ny_t'A0' = z_t' A_+' + u_t'\nwhere: - z_t = [e_t; y_{t-1}; ...; y_{t-p}] - A_+ = [C, A_1, ..., A_p]\nAssuming A0 is invertible, the reduced-form VAR ca```{.matlab}e obtained as\ny_t' = z_t' A_+'(A_0')^{-1} + u_t'(A_0')^{-1}\nwhich can be represented using a VAR object.\n\n\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [C A1 ... Ap].\np (integer): Lag order of the (S)VAR model.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1]).\nVARModel (VAR): Reduced-form VAR representation.\n\nSee also VAR",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#properties",
    "href": "documentation/matlab/all-functions/SVAR.html#properties",
    "title": "SVAR",
    "section": "",
    "text": "A0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [C A1 ... Ap].\np (integer): Lag order of the (S)VAR model.\ntrendExponents (vector): Time trend exponents (e.g., [0, 1]).\nVARModel (VAR): Reduced-form VAR representation.\n\nSee also VAR",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\ndata (table or matrix): Input dataset for the SVAR model.\np (integer): Lag order of the SVAR.\nvarargin: Name-value pairs for optional arguments:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant term).\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked coefficient matrix [A1, ..., Ap].\nVARModel (VAR): Precomputed reduced-form VAR model.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns",
    "href": "documentation/matlab/all-functions/SVAR.html#returns",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nobj (SVAR): Constructed SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes",
    "href": "documentation/matlab/all-functions/SVAR.html#notes",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nIf VARModel, A0, APlus are not provided, they are estimated from the data.\n\nSee also VAR",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-1",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-1",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-1",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-1",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nYhat (matrix): Matrix of fitted values (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-2",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-2",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Stacked lag coefficient matrix [A1 ... Ap], excluding deterministic components.\np (integer): Lag order of the SVAR.\nmaxHorizon (integer): Maximum horizon for IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-2",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-2",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nirfs (3D array): Impulse response functions of size (k x k x (maxHorizon+1)), where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Structural shocks.\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-1",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-1",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nAPlus must not include coefficients on deterministic terms.\n\nSee also VAR.IRF_",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-3",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-3",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nshock (integer): Index of the shock variable.\ncondition (Q): Transmission condition object.\norder (cell array of char): Variable transmission ordering.\nmaxHorizon (integer): Maximum horizon.\nvarargin: Name-value pairs for options:\nidentificationMethod (IdentificationMethod, optional): Method to identify the SVAR if not yet fitted.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-3",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-3",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\neffects (3D array): Transmission effects over horizons, where:\nFirst dimension: Endogenous variables (responses).\nSecond dimension: Shocks (only the selected shock).\nThird dimension: Horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-2",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-2",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nIf identificationMethod is provided, the model is fitted first.\n\nSee also SVAR.through, SVAR.notThrough, VAR.transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-4",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-4",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-4",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-4",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): SIC value.\n\nSee also aic, hqc, bic, VAR.sic",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-5",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-5",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-5",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-5",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nC (matrix): Companion matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-6",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-6",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (object): An object of type IdentificationMethod used to identify A0 and APlus.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-3",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-3",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nidentificationMethod must implement an identify method taking a VAR object and returning A0 and APlus.\n\nSee also VAR.fit, IdentificationMethod",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-7",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-7",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-6",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-6",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): BIC value.\n\nSee also aic, hqc, sic, VAR.bic",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-8",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-8",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nshocksOrT (matrix or integer): Either a (k x T) matrix of structural shocks or an integer specifying the number of periods to simulate.\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Coefficient matrix [C A1 ... Ap].\nvarargin: Name-value pairs for options:\ntrendExponents (vector): Exponents for deterministic trends. Defaults to [0] (constant).\ninitial (vector): Initial lag values, default is zeros.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-7",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-7",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nY (matrix): Simulated data matrix, size (T x k).",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-4",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-4",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nIf shocksOrT is a scalar, shocks are drawn from a standard normal distribution with identity covariance.\n\nSee also VAR.simulate",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-9",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-9",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nexcludeDeterministic (logical, optional): If true, exclude coefficients on deterministic components from APlus. Defaults to false.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-8",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-8",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nA0 (matrix): Contemporaneous coefficient matrix.\nAPlus (matrix): Coefficient matrix. If excludeDeterministic is true, returns only lag matrices [A1 ... Ap]. Otherwise APlus = [C A_1 ... A_p] is returned.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-10",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-10",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-9",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-9",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nU (matrix): Matrix of residuals (T-p) x k.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-11",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-11",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nidentificationMethod (IdentificationMethod): Identification method for SVAR.\nicFunction (function handle, optional): Information criterion function to minimize. Defaults to aic.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-10",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-10",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nmodelBest (SVAR): Best fitting SVAR model.\nicTable (table): Table of lag lengths and IC values.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-5",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-5",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nMaximum lag length is given by the lag length of the provided model.\n\nSee also SVAr.fit, aic, bic, hqc, sic, VAR.fitAndSelect",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-12",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-12",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-11",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-11",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nrho (number): Spectral radius of the companion matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-13",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-13",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-12",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-12",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): AIC value.\n\nSee also bic, hqc, sic, VAR.aic",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-14",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-14",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-13",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-13",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nflag (logical): True if the model is stable, false otherwise.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-15",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-15",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-14",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-14",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nval (number): HQC value.\n\nSee also aic, bic, sic, VAR.hqc",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#arguments-16",
    "href": "documentation/matlab/all-functions/SVAR.html#arguments-16",
    "title": "SVAR",
    "section": "Arguments",
    "text": "Arguments\n\nobj (SVAR): SVAR model object.\nmaxHorizon (integer): Maximum horizon for IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#returns-15",
    "href": "documentation/matlab/all-functions/SVAR.html#returns-15",
    "title": "SVAR",
    "section": "Returns",
    "text": "Returns\n\nirfObj (IRFContainer): Container with computed IRFs.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/SVAR.html#notes-6",
    "href": "documentation/matlab/all-functions/SVAR.html#notes-6",
    "title": "SVAR",
    "section": "Notes",
    "text": "Notes\n\nThe IRFs have dimensions (k x k x (maxHorizon+1)):\nFirst dimension: Responding variables.\nSecond dimension: Structural shocks.\nThird dimension: Horizons.\n\nSee also VAR.IRF, ~IRFContainer`",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "SVAR"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/checkContradiction.html",
    "href": "documentation/matlab/all-functions/checkContradiction.html",
    "title": "checkContradiction",
    "section": "",
    "text": "checkContradiction\n\n\n\n\n\ncheckContradiction Check for contradictions of the form x1 & ~x1 (x1 & !x1).\n[hasContradiction, contradictions] = checkContradiction(varAnd, varNot) checks whether there is a contradiction where a variable appears in both varAnd and varNot, meaning it is simultaneously required and forbidden.\n\n\n\nvarAnd (vector or cell array of vectors): AND variable numbers obtained from getVarNumsAndMultiplier.\nvarNot (vector or cell array of vectors): NOT variable numbers obtained from getVarNumsAndMultiplier.\n\n\n\n\n\nhasContradiction (logical): True if any contradictions exist.\ncontradictions (vector of logicals): A vector indicating which elements yield a contradiction.\n\n\n\n\n\nThis function is used in removeContradictions to eliminate contradicting terms, which helps speed up the simplification process by reducing the total number of terms.\n\nSee also removeContradictions, getVarNumsAndMultiplier",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "checkContradiction"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/checkContradiction.html#arguments",
    "href": "documentation/matlab/all-functions/checkContradiction.html#arguments",
    "title": "checkContradiction",
    "section": "",
    "text": "varAnd (vector or cell array of vectors): AND variable numbers obtained from getVarNumsAndMultiplier.\nvarNot (vector or cell array of vectors): NOT variable numbers obtained from getVarNumsAndMultiplier.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "checkContradiction"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/checkContradiction.html#returns",
    "href": "documentation/matlab/all-functions/checkContradiction.html#returns",
    "title": "checkContradiction",
    "section": "",
    "text": "hasContradiction (logical): True if any contradictions exist.\ncontradictions (vector of logicals): A vector indicating which elements yield a contradiction.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "checkContradiction"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/checkContradiction.html#notes",
    "href": "documentation/matlab/all-functions/checkContradiction.html#notes",
    "title": "checkContradiction",
    "section": "",
    "text": "This function is used in removeContradictions to eliminate contradicting terms, which helps speed up the simplification process by reducing the total number of terms.\n\nSee also removeContradictions, getVarNumsAndMultiplier",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "checkContradiction"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLagMatrix.html",
    "href": "documentation/matlab/all-functions/makeLagMatrix.html",
    "title": "makeLagMatrix",
    "section": "",
    "text": "makeLagMatrix\n\n\n\n\n\nmakeLagMatrix Create lag matrix from input data.\nlagMatrix = makeLagMatrix(Y, p) returns a matrix where columns contain 1 to p lags of Y.\n\n\n\nY (matrix): Input data matrix (T x k).\np (integer): Number of lags.\n\n\n\n\n\nlagMatrix (matrix): Matrix of lagged values. First k columns are lag 1, next k are lag 2, and so on.\n\n\n\n\n\nMissing values due to lagging are filled with NaN.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLagMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLagMatrix.html#arguments",
    "href": "documentation/matlab/all-functions/makeLagMatrix.html#arguments",
    "title": "makeLagMatrix",
    "section": "",
    "text": "Y (matrix): Input data matrix (T x k).\np (integer): Number of lags.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLagMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLagMatrix.html#returns",
    "href": "documentation/matlab/all-functions/makeLagMatrix.html#returns",
    "title": "makeLagMatrix",
    "section": "",
    "text": "lagMatrix (matrix): Matrix of lagged values. First k columns are lag 1, next k are lag 2, and so on.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLagMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeLagMatrix.html#notes",
    "href": "documentation/matlab/all-functions/makeLagMatrix.html#notes",
    "title": "makeLagMatrix",
    "section": "",
    "text": "Missing values due to lagging are filled with NaN.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeLagMatrix"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeOmega.html",
    "href": "documentation/matlab/all-functions/makeOmega.html",
    "title": "makeOmega",
    "section": "",
    "text": "makeOmega\n\n\n\n\n\nmakeOmega Construct the Omega matrix in the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\n\n\nPhi0 (matrix): Impact matrix for the shocks.\nPsis (cell array of matrices): MA terms for the dynamic model.\norder (vector): Ordering of variables.\nmaxHorizon (integer): Maximum IRF horizon.\n\n\n\n\n\nOmega (matrix): Part of the systems form.\n\nSee also makeB, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeOmega.html#arguments",
    "href": "documentation/matlab/all-functions/makeOmega.html#arguments",
    "title": "makeOmega",
    "section": "",
    "text": "Phi0 (matrix): Impact matrix for the shocks.\nPsis (cell array of matrices): MA terms for the dynamic model.\norder (vector): Ordering of variables.\nmaxHorizon (integer): Maximum IRF horizon.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeOmega.html#returns",
    "href": "documentation/matlab/all-functions/makeOmega.html#returns",
    "title": "makeOmega",
    "section": "",
    "text": "Omega (matrix): Part of the systems form.\n\nSee also makeB, makeSystemsForm",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeOmega"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/notThrough.html",
    "href": "documentation/matlab/all-functions/notThrough.html",
    "title": "notThrough",
    "section": "",
    "text": "notThrough\n\n\n\n\n\nnotThrough Construct a transmission condition excluding specific variables from the channel.\nq = notThrough(idx, horizons, order) creates a transmission condition Q where paths cannot pass through specified variables at given time horizons. The variable indices refer to their positions in the original dynamic system (e.g., in the SVARMA model), before applying the transmission matrix.\n\n\nFor a single variable:\n\nidx (integer): Index of the variable that paths cannot go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths cannot pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths cannot go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\n\n\n\n\nq (Q): A transmission condition.\n\n\n\n\n\nThe resulting transmission condition can be used in transmission to compute the transmission effect.\n\n\n\n\n% Non-contemporaneous monetary policy channel (Section 5.1 in Wegner etal 2024)\nq = notThrough(1, [0], 1:4);\n\n% Anticipation channel of government defense spending (Section 5.2 in Wegner etal 2024)\nq = notThrough(2, 0:20, 1:4);\nSee also through, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "notThrough"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/notThrough.html#arguments",
    "href": "documentation/matlab/all-functions/notThrough.html#arguments",
    "title": "notThrough",
    "section": "",
    "text": "For a single variable:\n\nidx (integer): Index of the variable that paths cannot go through, using its original index in the dynamic system (before transmission ordering).\nhorizons (vector of integers): Time horizons at which the paths cannot pass through the variable.\norder (vector of integers): Variable ordering determined by the transmission matrix.\n\nFor multiple variables:\n\nidx (vector of integers): Indices of the variables that paths cannot go through, using their original indices in the dynamic system.\nhorizons (cell array of vectors or vector of integer): If a single vector of integers is provided, then it will be applied to each idx. Alternatively, a cell array of integer vectors can be provided in which case each element in the cell array applies to the respective element in idx.\norder (vector of integers): Variable ordering determined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "notThrough"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/notThrough.html#returns",
    "href": "documentation/matlab/all-functions/notThrough.html#returns",
    "title": "notThrough",
    "section": "",
    "text": "q (Q): A transmission condition.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "notThrough"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/notThrough.html#notes",
    "href": "documentation/matlab/all-functions/notThrough.html#notes",
    "title": "notThrough",
    "section": "",
    "text": "The resulting transmission condition can be used in transmission to compute the transmission effect.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "notThrough"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/notThrough.html#example",
    "href": "documentation/matlab/all-functions/notThrough.html#example",
    "title": "notThrough",
    "section": "",
    "text": "% Non-contemporaneous monetary policy channel (Section 5.1 in Wegner etal 2024)\nq = notThrough(1, [0], 1:4);\n\n% Anticipation channel of government defense spending (Section 5.2 in Wegner etal 2024)\nq = notThrough(2, 0:20, 1:4);\nSee also through, transmission",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "notThrough"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeSystemsForm.html",
    "href": "documentation/matlab/all-functions/makeSystemsForm.html",
    "title": "makeSystemsForm",
    "section": "",
    "text": "makeSystemsForm\n\n\n\n\n\nmakeSystemsForm Transform an SVARMA dynamic model into the system representation \\(x = Bx + \\Omega\\varepsilon\\).\n\n\n\nPhi0 (matrix): The matrix of contemporaneous structural impulse responses.\nAs (cell array of matrices): A vector of reduced-form autoregressive (AR) matrices, where the first entry corresponds to the AR matrix for the first lag, etc.\nPsis (cell array of matrices): A vector of reduced-form moving average (MA) matrices, where the first entry corresponds to the MA matrix for the first lag, etc.\norder (vector): The vector of intergers indicating the order of variables, typically determined by the transmission matrix.\nmaxHorizon (integer): The maximum time horizon to consider for the systems form, with 0 representing the contemporaneous period.\n\n\n\n\n\nB (matrix)\nOmega (matrix)\n\nSee also makeB, makeOmega.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeSystemsForm"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeSystemsForm.html#arguments",
    "href": "documentation/matlab/all-functions/makeSystemsForm.html#arguments",
    "title": "makeSystemsForm",
    "section": "",
    "text": "Phi0 (matrix): The matrix of contemporaneous structural impulse responses.\nAs (cell array of matrices): A vector of reduced-form autoregressive (AR) matrices, where the first entry corresponds to the AR matrix for the first lag, etc.\nPsis (cell array of matrices): A vector of reduced-form moving average (MA) matrices, where the first entry corresponds to the MA matrix for the first lag, etc.\norder (vector): The vector of intergers indicating the order of variables, typically determined by the transmission matrix.\nmaxHorizon (integer): The maximum time horizon to consider for the systems form, with 0 representing the contemporaneous period.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeSystemsForm"
    ]
  },
  {
    "objectID": "documentation/matlab/all-functions/makeSystemsForm.html#returns",
    "href": "documentation/matlab/all-functions/makeSystemsForm.html#returns",
    "title": "makeSystemsForm",
    "section": "",
    "text": "B (matrix)\nOmega (matrix)\n\nSee also makeB, makeOmega.",
    "crumbs": [
      "Home",
      "Matlab",
      "All",
      "makeSystemsForm"
    ]
  },
  {
    "objectID": "documentation/julia/index.html",
    "href": "documentation/julia/index.html",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "",
    "text": "Get the Package\nTransmissionChannelAnalysis.jl provides a suite of functions for conducting transmission channel analysis (TCA) in Julia. It includes both standard methods—which are sufficient for most users—and more advanced, customisable techniques.\nThis overview focuses on the standard methods. Advanced options are described in the Advanced Section, and implementation details can be found in the Internals Section.\nBefore performing any transmission analysis, add TransmissionChannelAnalysis.jl to Julia and load it.\nusing Pkg; \nPkg.add(\"TransmissionChannelAnalysis\")\nusing TransmissionChannelAnalysis\nA typical transmission channel analysis workflow consists of the following steps:\nThe sections that follow document the functions available for each of these steps.",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#defining-and-estimating-a-model.",
    "href": "documentation/julia/index.html#defining-and-estimating-a-model.",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "1. Defining and estimating a model.",
    "text": "1. Defining and estimating a model.\nThe first step in transmission channel analysis is to define a model. This model will be used to derive total dynamic causal effects (impulse response functions) and to decompose these effects into effects along transmission channels. Currently supported are the following model types:\n\nVector Autoregressions (VARs) for baseline dynamic modelling, estimated via OLS without structural identification.\nStructural VARs (SVARs) with recursive and internal identification schemes.\nLocal projections with recursive and external instrument identification schemes.\n\nEach model class extends the abstract type Model. Detailed descriptions of each model follow.\n\nVector Autoregressions (VARs)\nA VAR model can be defined using the VAR type and its constructor as shown below:\n\n\n\n\n\n\n\nVAR\n\n\n\n\n\nVAR(data::DataFrame, p::Int;\n    trend_exponents::Vector{&lt;:Number} = [0])\nConstructs a VAR model object with data, lag length p, and specified time trend exponents. Coefficients and residuals are uninitialised but can be estimed using fit!.\n\nArguments\n\ndata::DataFrame: Dataset to construct lag matrix and outcomes\np::Int: Lag length\n\n\nKeyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])\n\n\n\n\n\n\n\nThe constructor requires a dataset of type DataFrame, with each column representing a variable and each row an observation, ordered from earliest to latest. For example:\n\n# data is some dataset of type DataFrame\np = 2  # lag length\nmodel = VAR(data, p)\n\nYou can include deterministic trends by specifying the trend_exponents keyword-argument:\n\np = 2\nmodel = VAR(data, p; trend_exponents = 0:1)\n\nHere, 0:1 indicates a constant (\\(t^0\\)) and a linear trend (\\(t^1\\)). For constant, linear, and quadratic trends use 0:2, or [0,2] to skip the linear term.\nTo estimate the VAR via OLS, call fit!:\n\nfit!(model)\n\nRetrieve estimates with coeffs, fitted, and residuals:\n\n# All coefficients\ncoeffs(model)\n# Excluding constants/trends\ncoeffs(model, true)\n# Fitted values\nfitted(mdoel)\n# Residuals\nresiduals(model)\n\nTo select the optimal lag length automatically, use fit_and_select!. This method fits VAR models for every lag length from 0 up to the specified maximum, evaluates each using the chosen information criterion (AIC by default), and returns the model with the lowest criterion value along with a table of lag lengths and their corresponding scores:\n\nmodel = VAR(data, 20)\nmodel_best, ic_table = fit_and_select!(model)\n\nfit_and_select! supports AIC (aic), BIC/SIC (bic/sic), and HQC (hqc). For example, to use the Bayesian Information Criteria (BIC), call:\n\nmodel = VAR(data, 20)\nmodel_best, ic_table = fit_and_select!(model, bic)\n\nTo compute information criteria for an already estimated model over its own sample, call aic, bic, sic, or hqc on the model. Note these values may differ from those returned by fit_and_select!, which evaluates ICs over a common sample across all models:\n\naic(model)  # computes the AIC of the model\nbic(model)  # computes the BIC of the model\nsic(model)  # computes the SIC of the model\nhqc(model)  # computes the HQC of the model\n\n\n\nStructural Vector Autoregressions (SVARs)\nAn SVAR can be defined using the SVAR class and its constructor as documented below:\n\n\n\n\n\n\n\nSVAR\n\n\n\n\n\nSVAR(data::DataFrame, \n     p::Int;\n     trend_exponents::Vector{&lt;:Number} = [0])\nConstructs a SVAR model object with data, lag length p, and specified time trend exponents. Coefficients and residuals are uninitialised but can be estimed using fit! and an appropriate AbstractIdentificationMethod.\n\nArguments\n\ndata::DataFrame: Dataset used for the estimation\np::Int: Lag length\n\n\nKeyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])\n\n\n\n\n\n\n\nThe constructor requires a dataset of type DataFrame, with each column representing a variable and each row an observation, ordered from earliest to latest. For example:\n\np = 4  # lag length\nmodel = SVAR(data, p)\n\nYou may include deterministic trends as for the VAR case, using the trend_exponents keyword-argument:\n\nmodel = SVAR(data, p; trend_exponents=0:1)\n\nTo estimate the structural model, an identification method must be provided. Only recursive identification (Recursive) is supported for full structural identification. Note that InternalInstrument methods can be used to identify impulse responses to a single shock; these are documented in a later section. Fit the model as follows:\n\nfit!(model, Recursive())\n\nAfter estimation, coefficients, fitted values, and residuals can be obtained analogenously to the VAR using coeffs, fitted, and residuals, respectively.\n\n# All coefficients (A0, A_plus)\ncoeffs(model)\n# Excluding constants/trends\ncoeffs(model, true)\n# Fitted values\nfitted(mdoel)\n# Residuals\nresiduals(model)\n\nYou can select the lag length automatically via fit_and_select!, which first determines the best reduced‑form VAR up to the maximum lag and then applies the chosen identification method:\nUsing AIC (default) with a maximum of twenty lags:\n\nmodel = SVAR(data, 20)\nmodel_best, ic_table = fit_and_select!(model, Recursive())\n\nOr using HQC for model selection:\n\nmodel = SVAR(data, 20)\nmodel_best, ic_table = fit_and_select!(model, Recursive(), hqc)\n\nAll VAR information‑criterion functions may be supplied to choose the optimal SVAR.\n\n\nLocal Projections\nA local projection model can be specified using the LP class and its constructor:\n\n\n\n\n\n\n\nVAR\n\n\n\n\n\nLP(data::DataFrame,\n   treatment::Union{Symbol, Int},\n   p::Int,\n   horizons::Union{Int, AbstractVector{&lt;:Int}};\n   include_constant::Bool=true)\nConstructs a LP model object for estimating local projections with specified horizons, treatment variable, and lag length p.\nAll variables before the treatment variable in the dataset are used as contemporaneous controls.\n\nArguments\n\ndata: the time series dataset\ntreatment: the treatment variable (column index or name)\np: number of lags to include\nhorizons: forecast horizons to compute IRFs for\n\n\nKeyword Arguments\n\ninclude_constant: whether to include a constant in the regressors\n\n\n\n\n\n\n\nThe constructor requires:\n\nA dataset of type DataFrame\nA treatment variable (either the shock itself or the instrumented variable)\nThe number of lags (p)\nA vector of horizons (horizons)\n\nFor example, to estimate horizons \\(0\\)–\\(20\\) with 4 lags for treatment variable Y1:\n\nmodel = LP(data, :Y1, 4, 0:20)\n\nBy default, each regression includes a constant term. To omit the constant, set the include_constant keyword-argument to false:\n\nmodel = LP(data, :Y1, 4, 0:20; include_constant=false)\n\nUse the fit! method to estimate the projections:\n\nfit!(model)\n\nBy default, fit! applies a recursive (conditional ignorability) assumption. These estimates are structural only if the true shock satisfies this assumption; otherwise, they should be treated as reduced‐form.\nAvailable identification schemes:\n\nRecursive (default)\nExternalInstrument (for external‐instrument IV)\n\nTo use an external instrument, first instantiate ExternalInstrument with the treatment name and an instrument dataset, then supply it to fit!:\n\nmethod = ExternalInstrument(:Y1, data_instruments)\nfit!(model, method)\n\nAfter estimation, extract the results (note the differing dimensions) via:\n\ncoeffs: (response variable × regressors × horizons)\nfitted, residuals: (observations × variables × horizons)\n\n\n# All coefficients\ncoeffs(model)\n# Excluding the constant\ncoeffs(model, true)\n# Fitted values \nfitted(model)\n# Residuals\nresiduals(model)\n\nTo select the lag order automatically, use fit_and_select!, which fits VARs internally to choose the optimal p:\nAll VAR information‑criterion functions (e.g., aic, bic, sic, hqc) may be used for LP lag selection. For example, using BIC:\n\nmodel = LP(data, :Y1, 20, 0:20)\nmodel_best, ic_table = fit_and_select!(model, Recursive(), bic)",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#keyword-arguments",
    "href": "documentation/julia/index.html#keyword-arguments",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#keyword-arguments-1",
    "href": "documentation/julia/index.html#keyword-arguments-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#keyword-arguments-2",
    "href": "documentation/julia/index.html#keyword-arguments-2",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ninclude_constant: whether to include a constant in the regressors",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#obtaining-the-effects-structural-irfs",
    "href": "documentation/julia/index.html#obtaining-the-effects-structural-irfs",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "2. Obtaining the effects – structural IRFs",
    "text": "2. Obtaining the effects – structural IRFs\nOnce a model is defined, you can compute total dynamic causal effects—impulse response functions (IRFs)—using the IRF method. The IRF function always requires a maximum horizon (max_horizon) for computation. For reduced‐form models, you may also supply an IdentificationMethod to derive structural IRFs.\nDetails on IRF computation for all models are provided below.\n\nVARs\nObtain reduced‐form IRFs from a VAR model by specifying the maximal horizon:\n\nmax_horizon = 20\nirf_obj = IRF(model, max_horizon)\n\nHere, irf_obj is of type IRF holding both the IRF array and related metadata:\nPrinting irf_obj displays a 3D array with dimensions:\n\nResponse variable\nShock\nHorizon (starting at 0 for contemporaneous effect)\n\nTo retrieve the raw IRF array, call:\n\nirf_obj.irfs\n\nTo compute structural IRFs, supply an IdentificationMethod. Supported methods include recursive (Recursive) and internal‐instrument (InternalInstrument) schemes:\nFor a recursive identification:\n\nirf_obj = IRF(model, Recursive(), max_horizon)\n\nTo use an internal instrument, specify a normalising_variable, then optionally override the instrument (default: first variable) or the normalising_horizon (default: 0 for contemporaneous effect):\n\nnormalising_variable = :Y1\nmethod = InternalInstrument(normalising_variable)\nirf_obj = IRF(model, method, max_horizon)\n\n\n# Changing the instrument to be Y2 and the normalising variable to be Y3\nmethod = InternalInstrument(:Y3; instrument=:Y2)\n\n\n# Changing the normalising horizon to period 1\nmethod = InternalInstrument(:Y3; instrument=:Y2, normalising_horizon=1)\n\n\n\nSVARs\nImpulse response functions can be obtained from an SVAR using the IRF function, analogous to the VAR case. Since an SVAR is already structurally identified, IRF returns structural IRFs directly:\n\n# model is a SVAR\nirf_obj = IRF(model, max_horizon)  # will be structural IRFs\n\n\n\n\n\n\n\nUsing SVARs and Internal Instruments\n\n\n\nThe IRF method for SVARs requires a fully identified SVAR. Internal instruments (via InternalInstrument) cannot be applied to an SVAR directly. To use internal instruments for IRF identification, first define a reduced‐form VAR, apply the instrument there, and then compute IRFs:\n\nmodel = VAR(data, p);\nnormalising_variable = :Y2;\nmethod = InternalInstrument(normalising_variable);\nirf_obj = IRF(model, method, max_horizon)\n\n\n\n\n\nLocal Projections\nImpulse response functions can be obtained from an estimated LP model using IRF and providing an identification method. Available methods are:\n\nRecursive identification via Recursive\nExternal instruments via ExternalInstrument\n\nFor example, using Recursive:\n\n# model is an LP model\nirf_obj = IRF(model, Recursive(), max_horizon)\n\nOr using external instruments\n\nmethod = ExternalInstrument(:Y1, data_instruments)\nirf_obj = IRF(model, method, max_horizon)",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#defining-a-transmission-matrix.",
    "href": "documentation/julia/index.html#defining-a-transmission-matrix.",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "3. Defining a transmission matrix.",
    "text": "3. Defining a transmission matrix.\nThe next step in a transmission channel analysis is to define the transmission matrix, which specifies the ceteris paribus ordering of variables in the chosen equilibrium representation. The simplest way is to list the variables in the desired order as a vector of Symbol. For example, if your data contains Y1, Y2, Y3, and Y4, and you wish to order them as Y4, Y2, Y1, Y3, define:\n\ntransmission_order = [:Y3, :Y2, :Y1, :Y3]\n\n\n\n\n\n\n\nNote: The ordering must be a vector of Symbol not String.\n\n\n\nAdvanced methods for constructing transmission matrices are covered in the Advanced Methods Section.",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#definining-transmission-channels.",
    "href": "documentation/julia/index.html#definining-transmission-channels.",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "4. Definining transmission channels.",
    "text": "4. Definining transmission channels.\nWith the transmission matrix in place, you can specify transmission channels of interest via the helper functions through and not_through. These functions return a transmission condition Q that you can combine to define complex transmission channels. More advanced methods for defining transmission channels are documented in the Advanced Methods Section.\nthrough\nUse through to define channels that pass through specified variables at given horizons.\nExamples (for any model — VAR, SVAR, or LP — with transmission_order or a transmission matrix as described above):\n\nChannel through Y1 at horizons 0-3:\n\n\nq = through(model, :Y1, 0:0, transmission_order)\n\n\nChannel through Y1 and Y2 contemporaneously:\n\n\nq = through(model, [:Y1, :Y2], 0:0, transmission_order)\n\n\nChannel through Y1 at horizon 0 and Y2 at horizons 0–1:\n\n\nq = through(model, [:Y1, :Y2], [0:0, 0:1])\n\nnot_through\nUse not_through to define channels that do not go through specified variables at given horizons.\nExamples (for any model — VAR, SVAR, or LP — with transmission_order a transmission matrix as described above):\n\nChannel not through Y1 at horizons 0-20:\n\n\nq = not_through(model, :Y1, 0:20, transmission_order)\n\n\nChannel not through Y1 and not through Y2 at horizons 0-20:\n\n\nq = not_through(model, [:Y1, :Y2], 0:20, transmission_order)\n\n\nChannel not through Y1 contemporaneously and not through Y2 at horizon 1:\n\n\nq = not_through(model, [:Y1, :Y2], [0:0, 1:1], transmission_order)\n\nCombining through and not_through\nBoth through and not_through return a transmission condition Q, which can be combined using logical operators:\n\nAND (&): both conditions must be satisfied.\nOR (|): at least one condition must be satisfied.\nNOT (!): negates a condition.\n\nExamples:\n\nChannel through Y1 contemporaneously but not through Y2 contemporaneously:\n\n\nq1 = through(model, :Y1, 0:0, transmission_order)\nq2 = not_through(model, :Y2, 0:0, transmission_order)\nq = q1 & q2\n\n\nChannel through Y1 contemporaneously or not through Y2 contemporaneously:\n\n\nq1 = through(model, :Y1, 0:0, transmission_order)\nq2 = not_through(model, :Y2, 0:0, transmission_order)\nq = q1 | q2\n\n\nChannel not through Y1 contemporaneously (both ways are equivalent):\n\n\nq1 = through(model, :Y1, 0:0, transmission_order)\nq = !q1\nq = not_through(model, :Y1, 0:0, transmission_order)\n\n\nChannel through Y1 in at least one period between horizons 0-20:\n\n\nq = not_through(model, :Y1, 0:20, transmission_order)\nq = !q\n\nBy combining through and not_through with logical operators, you can flexibly construct any complex transmission channel you require.",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/index.html#obtaining-transimssion-effects.",
    "href": "documentation/julia/index.html#obtaining-transimssion-effects.",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "5. Obtaining transimssion effects.",
    "text": "5. Obtaining transimssion effects.\nOnce you have defined a model (VAR, SVAR, or LP), the transmission method computes transmission effects along your specified channel. Below are the details for each model type.\nFor VAR and LP, or for SVAR models that have not yet been structurally estimated, you must provide an identification method (since at least one structural shock is required). As outlined above, this can be Recursive for SVAR and LP, InternalInstrument for SVAR, or ExternalInstrument for LP.\nFor example, to compute the effects of the first structural shock up to max_horizon, using a transmission matrix transmission_order and a transmission condition q:\n\neffects = transmission(\n    model,               # VAR, SVAR, or LP\n    method,              # identification method\n    1,                   # shock index\n    q,                   # transmission condition\n    transmission_order,  # transmission matrix\n    max_horizon          # maximum horizon\n)\n\nThe returned effects array has dimensions:\n\nResponse variables (in original data order)\nTransmission effect of the chosen shock\nHorizons (starting at 0)\n\nIf your SVAR model is already structurally identified (fitted with a structural identification scheme), you may omit the identification argument:\n\neffects = transmission(model, 1, q, transmission_order, max_horizon)",
    "crumbs": [
      "Home",
      "Julia",
      "Overview"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html",
    "href": "documentation/julia/advanced.html",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "",
    "text": "The package TransmissionChannelAnalysis.jl provides functionns for TCA in Julia. It is to date the most advanced of the packages, allowing for all kinds of transmission channels. However, implementing more advanced trasnmission channels requires the use of more advanced methods within the package. For most users and for most applications, the basic funcionality is sufficient. This basic functionality will be documented first, with some more advanced features discussed later.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#defining-simple-transmission-channels",
    "href": "documentation/julia/advanced.html#defining-simple-transmission-channels",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Defining Simple Transmission Channels",
    "text": "Defining Simple Transmission Channels\nTwo helper functions are provided that allow for the definition of transmission channels without having to use the more advanced methods. These are through and not_throug. As the names hint at, through is used to define a channel that must go through certain variables in certain periods, while not_through is used to define a transmission channel that cannot go through certain variables in all defined periods.\n\n\n\n\n\n\n\nthrough\n\n\n\n\n\nthrough(idx, horizons, order) --&gt; Q\nAll paths must go through variables in idx in periods horizons. Note, this uses the dynamic system notation y such that idx refers to the index of the variable in the original dynamic system, i.e. in the SVARMA.\n\nArguments\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths should go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths must go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths should go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths must go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\n\n\nReturns\n\nReturns a transmission condition Q.\n\n\n\nNotes\n\nThe transmission effect can be calculated using transmission.\n\n\n\nExamples\nSuppose we are interested in the contemporaneous channel in Section 5.1 of Wegner et al (2024), i.e. we are interested in the effect going through the federal funds rate contemporaneously. In our estimated model, the federal funds rate is the first variable. We would thus define the contemporaneous channe```{julia}s\ncontemporaneous_channel = through(1, [0], 1:4)  # we have four variables with ffr being first\nMore generally, we could define the following, which would be the effect through the federal funds rate in the first t```{julia}periods.\nq = through(1, [0, 1], 1:4)\nThe following is also allowed which is the effect through the federal funds rate contemporaneously and one period later, and through the output gap contemporaneously and one period later, where the federal funds rate is ordered first and the ```{julia}put gap second.\nq = through([1, 2], [[0, 1], [0, 1]], 1:4)\nIf we want to re-order the federal funds rate after the output gap, we simply change the ordering to [2, 1, 3, 4] where 2 corresponds to the output gap ```{julia}the original ordering.\nq = through([1, 2], [[0, 1], [0, 1]], [2, 1, 3, 4])\n\n\n\n\n\n\n\n\n\n\n\n\nthrough\n\n\n\n\n\nthrough(\n    model::Model, \n    variables::Union{AbstractVector{Symbol}, Symbol}, \n    horizons::Union{AbstractVector{&lt;:Int},Vector{&lt;:AbstractVector{&lt;:Int}}}, \n    order::AbstractVector{Symbol}\n) --&gt; Q\nDefine a transmission channel through variables for horizons. Contrary to the other through methods, variables and order are defined using the variable names of the model – other through methods use indices.\n\n\n\n\n\n\n\n\n\n\n\nnot_through\n\n\n\n\n\nnot_through(idx, horizons, order) --&gt; Q\nAll paths cannot go through variables in idx in periods horizons. Note, this uses the dynamic system notation y such that idx refers to the index of the variable in the original dynamic system, i.e. in the SVARMA.\n\nArguments\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths cannot go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths cannot go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths cannot go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths cannot go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\n\n\nReturns\n\nReturns a transmission condition Q.\n\n\n\nNotes\n\nThe transmission effect can be calculated using transmission.\n\n\n\nExamples\nThe non-contemporaneous channel of monetary policy is defined in Section 5.1 of Wegner et al (2024) as the effect not going through a contemporaneous adjustment of the federal funds rate, where the transmission matrix orders the federal funds rate first. Thus, if the original SVAR has the federal funds rate ordered first, the non-contemporaneous effect can be obtained in the following ```{julia}.\nq = not_through(1, [0], 1:4)\nSimilarly, Wegner et al (2024) define the anticipation channel of government defense spending as the effect not going through government defense spending. With government defense spending ordered second in the VAR, the following can be used to obtain the anticipati```{julia}channel.\nq = not_through(2, 0:20, 1:4)\n\n\n\n\n\n\n\n\n\n\n\n\nnot_through\n\n\n\n\n\nnot_through(\n    model::Model, \n    variables::Union{AbstractVector{Symbol}, Symbol}, \n    horizons::Union{AbstractVector{&lt;:Int},Vector{&lt;:AbstractVector{&lt;:Int}}}, \n    order::AbstractVector{Symbol}\n) --&gt; Q\nDefine a transmission channel not through variables for horizons. Contrary to the other not_through methods, variables and order are defined using the variable names of the model – other not_through methods use indices.\n\n\n\n\nBoth through and not_through return a transmission condition Q, which is simply an internal representation of the provided transmission channel (represented as Boolean statements). To double check whether the condition represents the desired channel, simply run Q in the REPL, which will display the internal representation using the systems form and thus using the variable notation \\(x\\). Alternatively, show_y or @show_y can be used to display the internal representation in the dynamic form and thus using the variable notation \\(y\\).\n\n\n\n\n\n\n\nshow_y\n\n\n\n\n\nshow_y(q::Q, order::AbstractVector{&lt;:Int})\n@show_y(q, order)\nPretty print the condition q::Q using the variables of the dynamic system, i.e. y.\n\nArguments\n\nq::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.\n\n\n\nExa```{julia}es\ns_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order\n\n\n\n\n\n\nAdvanced Usage of through and not_through\nConditions created using through and not_through can be combined using AND (&), OR (|) and NOT (!). Every new combination will return a new condition that combines the previous conditions. The returned conditions can again be combined using AND, OR, and NOT. For example, if q1, q2 and q3 are conditions obtained using through or not_through, then the following works.\n\nq1_and_q2 = q1 & q2\nq1_and_not_q3 = q1 & !q3\nq4 = (q1 | q2) & !q3\nq5 = q4 | q1\n\nThis functionality allows definitions of transmission channels that are not easily defined using through and not_through. For example, if we were interested in the transmission channel that goes through \\(y_{1,0}\\) OR through \\(y_{1,1}\\), then neither of the helper functions can be used, since neither can handle OR statements. However, we can use Boolean logic and the rules for the manipulation of transmission conditions to define this transmission channel using our helper functions.\nIn most cases, the easiest step is to negate the original condition. The above condition can be succintly be represented as \\[\ny_{1,0} \\lor y_{1,1}.\n\\] The negated statement is thus \\[\n\\neg y_{1,0} \\land \\neg y_{1,1}.\n\\] This can be defined using not_through in the following way\n\nq = not_through(1, [0,1], 1:n)\n\nwhere we assumed that the transmission matrix is the identity matrix, implying an ordering 1:n.\nTo obtain the original transmission channel, we can simply negate this condition.\n\noriginal_condition = !q",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments",
    "href": "documentation/julia/advanced.html#arguments",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths should go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths must go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths should go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths must go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns",
    "href": "documentation/julia/advanced.html#returns",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a transmission condition Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#notes",
    "href": "documentation/julia/advanced.html#notes",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Notes",
    "text": "Notes\n\nThe transmission effect can be calculated using transmission.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#examples",
    "href": "documentation/julia/advanced.html#examples",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Examples",
    "text": "Examples\nSuppose we are interested in the contemporaneous channel in Section 5.1 of Wegner et al (2024), i.e. we are interested in the effect going through the federal funds rate contemporaneously. In our estimated model, the federal funds rate is the first variable. We would thus define the contemporaneous channe```{julia}s\ncontemporaneous_channel = through(1, [0], 1:4)  # we have four variables with ffr being first\nMore generally, we could define the following, which would be the effect through the federal funds rate in the first t```{julia}periods.\nq = through(1, [0, 1], 1:4)\nThe following is also allowed which is the effect through the federal funds rate contemporaneously and one period later, and through the output gap contemporaneously and one period later, where the federal funds rate is ordered first and the ```{julia}put gap second.\nq = through([1, 2], [[0, 1], [0, 1]], 1:4)\nIf we want to re-order the federal funds rate after the output gap, we simply change the ordering to [2, 1, 3, 4] where 2 corresponds to the output gap ```{julia}the original ordering.\nq = through([1, 2], [[0, 1], [0, 1]], [2, 1, 3, 4])",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-1",
    "href": "documentation/julia/advanced.html#arguments-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths cannot go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths cannot go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths cannot go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths cannot go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-1",
    "href": "documentation/julia/advanced.html#returns-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a transmission condition Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#notes-1",
    "href": "documentation/julia/advanced.html#notes-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Notes",
    "text": "Notes\n\nThe transmission effect can be calculated using transmission.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#examples-1",
    "href": "documentation/julia/advanced.html#examples-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Examples",
    "text": "Examples\nThe non-contemporaneous channel of monetary policy is defined in Section 5.1 of Wegner et al (2024) as the effect not going through a contemporaneous adjustment of the federal funds rate, where the transmission matrix orders the federal funds rate first. Thus, if the original SVAR has the federal funds rate ordered first, the non-contemporaneous effect can be obtained in the following ```{julia}.\nq = not_through(1, [0], 1:4)\nSimilarly, Wegner et al (2024) define the anticipation channel of government defense spending as the effect not going through government defense spending. With government defense spending ordered second in the VAR, the following can be used to obtain the anticipati```{julia}channel.\nq = not_through(2, 0:20, 1:4)",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-2",
    "href": "documentation/julia/advanced.html#arguments-2",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nq::Q: A transmission condition. See also Q.\norder::AbstractVector{&lt;:Int}: The order of variables defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#exajuliaes",
    "href": "documentation/julia/advanced.html#exajuliaes",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\ns_y = \"y_{1,0} | !y_{1,1}\"\norder = [3,1,2]\n\nq = make_condition(s_y, order)\n@show_y q $order",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#defining-complex-transmission-channels",
    "href": "documentation/julia/advanced.html#defining-complex-transmission-channels",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Defining Complex Transmission Channels",
    "text": "Defining Complex Transmission Channels\nAlthough through and not_through are sufficient for many situations, it is still sometimes more convenient to directly define the transmission channel as a Boolean condition withough having to refer back to though and not_through.\nSay, for example, we are again interested in the transmission channel going through y_{1,0} OR y_{1,1}. Instead of using the approach of first negating the statement, then using not_through, just to negate this statement again, we may as well just define the condition directly using the more advanced functionality of TransmissionChannelAnalysis.jl.\nThe advanced functionality simply takes a String that defines the transmission channel as a Boolean condition. The string can either be defined using the variables of the dynamic form \\(y\\) or the variables using the systems form \\(x\\). In the former case, the ordering defined by the transmission matrix must also be defined. In either case, make_condition is used.\n\n\n\n\n\n\n\nmake_condition\n\n\n\n\n\nmake_condition(s::String)\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int})\nMake a transmission condition, i.e. Q(b), out of a string.\nTransmission channels are described using Boolean statements involving the variables in the dynamic model. make_condition allows for specifying these Boolean conditions as a string which is then converted to an internal representation allowing the computation of transmission channels.\nTwo ways of specifying the Boolean conditions exist:\n\nmake_condition(s::String) takes the Boolean condition in the systems form of Wegner et al (2024), i.e. variables must start with x followed by a number. For example, given a three variable VAR(1), y_{1,t} -&gt; x_1, y_{2, t} -&gt; x_2, y_{3, t} -&gt; x_3, y_{1, t+1} -&gt; x_4, y_{2, t+1} -&gt; x_5, … Boolean statements then involve expressions in the x variables and define which paths can be taken. Each path involved in the transmission mechanism must satisfy the Boolean statement.\nmake_condition(s_y::String, order::AbstractVector{&lt;:Int}) does the same as the first method, however the Boolean condition can be specified using the variables of the dynamic systems, i.e. y. Variables must then be specified using y_{i,t} where i is the variable number and t is the period. At all times t &gt;= 0 with 0 denoting the contemporaneous horizon.\n\n\nArguments\n\ns::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.\n\n\n\nReturns\n\nReturns a transmission condition. See also Q.\n\n\n\nExa```{julia}es\ns = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)\n\n\nNotes\n\nBoolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.\n\n\n\n\n\n\nSo, to define the transmission channel that goes through y_{1,0} OR through \\(y_{1,1}\\) with an identity transmission matrix, we can do either of the following.\n\n# Note, we assume 4 variables in the system. \nq = make_condition(\"y_{1,0} | y_{1,1}\", 1:4)\n# With an identity transmission matrix, y_{1,0} -&gt; x1\n# and y_{1,1} -&gt; x5 if the transmission matrix\n# is the identity matrix.\nq = make_condition(\"x1 | x5\")",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-3",
    "href": "documentation/julia/advanced.html#arguments-3",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\ns::String: A Boolean statement given as a string. Variables must start with x for them to be valid variables.\ns_y::String: A Boolean statement given as a string. Variabls must have the form y_{i,t} where i is the variable number and t &gt;= 0 is the time period. t=0 corresponds to the contemporaneous horizon.\norder::AbstractVector{&lt;:Int}: The variable ordering defined by the transmission matrix.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-2",
    "href": "documentation/julia/advanced.html#returns-2",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#exajuliaes-1",
    "href": "documentation/julia/advanced.html#exajuliaes-1",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\ns = \"x2 & !x3\"\ncond = make_cond```{julia}on(s)\ns_y = \"y_{1,0} & !y_{1,1}\"\norder = [3,1,2]\ncond = make_condition(s_y, order)",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#notes-2",
    "href": "documentation/julia/advanced.html#notes-2",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Notes",
    "text": "Notes\n\nBoolean conditions can consist of AND (&), NOT (!), OR (|), and parentheses.\nThe resulting transmission condition can be used in transmission to calculate the transmission effect.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#computing-transmission-effects",
    "href": "documentation/julia/advanced.html#computing-transmission-effects",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Computing Transmission Effects",
    "text": "Computing Transmission Effects\nTransmission effects, i.e. the effect through the transmission channel, can be computed in one of two ways in TransmissionChannelAnalysis.jl. The first way is to use the systems form to compute the transmission effect. The second way exploits the sufficiency of impulse response functions (IRFs)1 and uses these to compute the effects. The following sections describe both methods.\n\nPreparing the Systems Form\nThe systems form can be used whenever a SVAR(MA) was estimated and the AR and MA coefficients are available. The first step then consists of transforming the dynamic form of the SVAR(MA) into the systems form. We provide the utility function make_systems_form for this purpose.\n\n\n\n\n\n\n\nmake_systems_form\n\n\n\n\n\nmake_systems_form(\n    Phi0::AbstractMatrix, \n    As::Vector{&lt;:AbstractMatrix}, \n    Psis::Vector{&lt;:AbstractMatrix}, \n    Sigma::AbstractMatrix{&lt;:Real}, \n    order::AbstractVector{&lt;:Int}, \n    max_horizon::Int\n) -&gt; Tuple{AbstractMatrix, AbstractMatrix}\nTransform an SVARMA dynamic model into the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nArguments\n\nPhi0::AbstractMatrix: The matrix of contemporaneous structural impulse responses.\nAs::Vector{&lt;:AbstractMatrix}: A vector of reduced-form autoregressive (AR). First entry corresponds to the AR matrix for the first lag, etc.\nPsis::Vector{&lt;:AbstractMatrix}: A vector of reduced-form moving average (MA) matrices. First index corresponds to the first lag, etc.\nSigma::AbstractMatrix{&lt;:Real}: The covariance matrix of reduced-form errors.\norder::AbstractVector{&lt;:Int}: The vector indicating the order of variables, typically determined by the transmission matrix.\nmax_horizon::Int: The maximum time horizon to consider for the systems model, with 0 representing the contemporaneous period.\n\n\n\nReturns\n\n(B, Omega) with the meaning being the same as in Wegner et al (2024).\n\n\n\nNotes\n\nUse make_B and make_Omega to construct the two matrices seperately.\n\n\n\n\n\n\nThe returned systems form can then be used in transmission to compute the trasnmission effect.\nBesides make_systems_form we also offer the two separate functions make_B and make_Omega which respectively create \\(B\\) and \\(\\Omega\\) of the systems form. Use of these two functions should most of the time not be required. However, for users that might want to research of TCA, having access to these two methods seperately can be helpful.\n\n\n\n\n\n\n\nmake_B\n\n\n\n\n\nConstruct B of the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nNotes\n\nSee make_systems_form for further information.\n\n\n\n\n\n\n\n\n\n\n\n\n\nmake_Omega\n\n\n\n\n\nConstruct Omega of the systems representation \\(x = Bx + Omega\\varepsilon\\).\n\nNotes\n\nSee make_systems_form for further information.\n\n\n\n\n\n\n\n\nPreparing the IRFs\nEstimating the transmission effects using IRFs requires Cholesky / orthogonalised IRFs for all variables, as well as the structural shocks impulse response functions. In either case, TransmissionChannelAnalysis.jl works internally with a matrix representation of IRFs. Since many software solutions for SVAR(MA) return IRFs in the form of three-dimensional arrays, we provide the utility function to_transmission_irfs that transforms the three-dimensional arrays into a matrix of IRFs.\n\n\n\n\n\n\n\nto_transmission_irfs\n\n\n\n\n\nto_transmission_irfs(irfs::AbstractArray{T, 3})\nTransform a standard three dimensional IRF array into a IRF matrix. The\n\nArguments\n\nirfs::AbstractArray{T, 3}: IRF Array of dimension nvariabels × nshocks × n_horizons with the first horizons corresponding to horizon 0.\n\n\n\nReturns\n\nMatrix{T} of dimension (nvariables  nhorizons) × (nvariables * n*horizons). This is the same as what would be obtained via \\((I-B)^{-1}\\mathbb{Q}\\) using the notation of Wegner et al (2024).\n\n\n\n\n\n\nto_transmission_irfs should be applied to both the Cholesky / orthogonalised and the structural IRFs. The resulting IRFs can then be used in transmission to compute the transmission effects.\n\n\nComputing\nWith either the IRFs or the systems form prepared, transmission effects can be computed using any of the following versions of the transmission function. In either case, the fourth argument to transmission must be a transmission condition that can be obtained in any of the ways described above.\nTo compute transmission effects using the systems form, method should be set equal to :BOmega. Similarly, to use IRFs, method should be set equal to :irfs. The default is set to :BOmega and thus, if not further specified, TransmissionChannelAnalysis.jl assumes that the systems form is being used. This choice was mostly made because the computations under the systems form are faster than the computations using IRFs.\n\n\n\n\n\n\n\ntransmission\n\n\n\n\n\ntransmission(from::Int, arr1::AbstractMatrix{T}, arr2::AbstractMatrix{T}, q::Q; method = :BOmega) where {T}\nGiven a transmission condition q, calculate the transmission effect using the either the :BOmega method (the default), or the :irfs method.\n\nArguments\n\nfrom::Int: Shock number.\narr1::AbstractMatrix{T}. In case of :BOmega this must be B, in case of :irfs this must be irfs. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\narr2::AbstractMatrix{T}: In case of :BOmega this must be Omega, in case of :irfs this must be irfs_ortho. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\nq::Q: A transmission condition. See also Q.\n\n\n\nKeyword Arguments\n\nmethod::Symbol: Either :BOmega in which case the transmission effect will be calculated using the second method in Wegner et al (2024), or :irfs in which case the transmission effect is calculated using the first method in Wegner et al (2024).\n\n\n\nReturns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.\n\n\n\nExa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond; method = :BOmega)\neffect = transmission(1, B, Omega, cond)  # same as above; default is :BOmega\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)\n\n\n\n\n\n\n\n\n\n\n\n\ntransmission\n\n\n\n\n\ntransmission(\n    from::Int, \n    B::AbstractMatrix{T},\n    Omega::AbstractMatrix{T}, \n    q::Q, \n    ::Type{Val{:BOmega}}\n) where {T}\nGiven a transmission condition q, calculate the transmission effect using the :BOmega method.\n\nArguments\n\nfrom::Int: Shock number.\nB::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nOmega::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nq::Q: A transmission condition. See also Q.\n\n\n\nReturns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.\n\n\n\nExa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond)\n\n\n\n\n\n\n\n\n\n\n\n\ntransmission\n\n\n\n\n\ntransmission(from::Int, \n    irfs::AbstractMatrix{T}, \n    irfs_ortho::AbstractMatrix{T}, \n    q::Q, \n    ::Type{Val{:irfs}}\n) where {T}\nGiven a transmission condition q, calculate the transmission effect using the :irfs method.\n\nArguments\n\nfrom::Int: Shock number.\nirfs::AbstractMatrix{T}: Impulse responses. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nirfs_ortho::AbstractMatrix{T}: Orthogonalised IRFs. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nq::Q: A transmission condition. See also Q.\n\n\n\nReturns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.\n\n\n\nExa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)\n\n\n\n\n\n\n\n\n\n\n\n\ntransmission\n\n\n\n\n\ntransmission(model::Model, \n             from::Int, \n             q::Q, \n             order::AbstractVector{&lt;:Int}, \n             max_horizon::Int) --&gt; Array{&lt;:Number, 3}\n\ntransmission(model::Model, \n             method::AbstractIdentificationMethod, \n             from::Int, \n             q::Q,\n             order::AbstractVector{&lt;:Int}, \n             max_horizon::Int) --&gt; Array{&lt;:Number, 3}\n\ntransmission(model::Model, \n             from::Int, \n             q::Q, \n             order::AbstractVector{Symbol}, \n             max_horizon::Int) --&gt; Array{&lt;:Number, 3}\n\ntransmission(model::Model, \n             method::AbstractIdentificationMethod, \n             from::Int, \n             q::Q,\n             order::AbstractVector{Symbol}, \n             max_horizon::Int) --&gt; Array{&lt;:Number, 3}\nCompute the transmission effect of a transmission channel defined by the condition q. If model is a reduced-form model, method will be used to identify the required structural shock.\n\nArguments\n\nmodel::Model: A model, such as an SVAR, VAR, or LP.\nmethod::AbstractIdentificationMethod: An identification method to identify the from-th structural shock.\nfrom::Int: Shock number.\nq::Q: A transmission condition. See also Q and make_condition.\norder::AbnstractVector{&lt;:Int}: order of variables defined by the transmission matrix using variable indices.\norder::AbnstractVector{Symbol}: order of variables defined by the transmission matrix using variable names.\nmax_horizon::Int: Maximum horizon for the transmission effect.\n\n\n\nReturns\n\nReturns a three dimensional array with the first dimension correspondin to the endogenous variables (in original order), the second to the shock, and the third to the horizon (from 0 to max_horizon).\n\n\n\n\n\n\nIt may occur that a transmission condition contains a contradiction, i.e. a part of the boolean conditions says \\(x_i \\land \\neg x_i\\). These are usually automatically removed internally. However, this automatic removal can sometimes lengthen the time it takes for the condition to compile. We therefore offer the utility function set_remove_contradictions that can be used to turn this off. Even if off, the resulting transmission effect will be correct, but the computation may take a bit longer. Thus, there is a trade-off between longer compile times (if contradictions are being removed) and longer computing time (if contradictions are not removed).\n\n\n\n\n\n\n\nset_remove_contradictions\n\n\n\n\n\nset_remove_contradictions(b::Bool)\nSets REMOVE_CONTRADICTIONS to b.\nIf REMOVE_CONTRADICTIONS==true, then contradicting terms are removed before the transmission effect is computed. A term is deemed contradicting if it includes some “xi & !xi”. This would result in the entire Boolean statement to be false, and thus in the effect of this terms to be zero.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-5",
    "href": "documentation/julia/advanced.html#arguments-5",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nirfs::AbstractArray{T, 3}: IRF Array of dimension nvariabels × nshocks × n_horizons with the first horizons corresponding to horizon 0.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-4",
    "href": "documentation/julia/advanced.html#returns-4",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nMatrix{T} of dimension (nvariables  nhorizons) × (nvariables * n*horizons). This is the same as what would be obtained via \\((I-B)^{-1}\\mathbb{Q}\\) using the notation of Wegner et al (2024).",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-6",
    "href": "documentation/julia/advanced.html#arguments-6",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nfrom::Int: Shock number.\narr1::AbstractMatrix{T}. In case of :BOmega this must be B, in case of :irfs this must be irfs. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\narr2::AbstractMatrix{T}: In case of :BOmega this must be Omega, in case of :irfs this must be irfs_ortho. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#keyword-arguments",
    "href": "documentation/julia/advanced.html#keyword-arguments",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\nmethod::Symbol: Either :BOmega in which case the transmission effect will be calculated using the second method in Wegner et al (2024), or :irfs in which case the transmission effect is calculated using the first method in Wegner et al (2024).",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-5",
    "href": "documentation/julia/advanced.html#returns-5",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#exajuliaes-2",
    "href": "documentation/julia/advanced.html#exajuliaes-2",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond; method = :BOmega)\neffect = transmission(1, B, Omega, cond)  # same as above; default is :BOmega\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-7",
    "href": "documentation/julia/advanced.html#arguments-7",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nfrom::Int: Shock number.\nB::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nOmega::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-6",
    "href": "documentation/julia/advanced.html#returns-6",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#exajuliaes-3",
    "href": "documentation/julia/advanced.html#exajuliaes-3",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond)",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-8",
    "href": "documentation/julia/advanced.html#arguments-8",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nfrom::Int: Shock number.\nirfs::AbstractMatrix{T}: Impulse responses. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nirfs_ortho::AbstractMatrix{T}: Orthogonalised IRFs. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-7",
    "href": "documentation/julia/advanced.html#returns-7",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#exajuliaes-4",
    "href": "documentation/julia/advanced.html#exajuliaes-4",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#arguments-9",
    "href": "documentation/julia/advanced.html#arguments-9",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Arguments",
    "text": "Arguments\n\nmodel::Model: A model, such as an SVAR, VAR, or LP.\nmethod::AbstractIdentificationMethod: An identification method to identify the from-th structural shock.\nfrom::Int: Shock number.\nq::Q: A transmission condition. See also Q and make_condition.\norder::AbnstractVector{&lt;:Int}: order of variables defined by the transmission matrix using variable indices.\norder::AbnstractVector{Symbol}: order of variables defined by the transmission matrix using variable names.\nmax_horizon::Int: Maximum horizon for the transmission effect.",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#returns-8",
    "href": "documentation/julia/advanced.html#returns-8",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Returns",
    "text": "Returns\n\nReturns a three dimensional array with the first dimension correspondin to the endogenous variables (in original order), the second to the shock, and the third to the horizon (from 0 to max_horizon).",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/advanced.html#footnotes",
    "href": "documentation/julia/advanced.html#footnotes",
    "title": "TransmissionChannelAnalysis.jl",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee Section 4 in Wegner et al. (2025).↩︎",
    "crumbs": [
      "Home",
      "Julia",
      "Advanced Tools"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/VAR.html",
    "href": "documentation/julia/all-functions/VAR.html",
    "title": "VAR",
    "section": "",
    "text": "VAR\n\n\n\n\n\nVAR &lt;: Model\nVector Autoregressive (VAR) model in matrix form.\nA VAR of lag order p is specified as:\n\\[\n    y_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\n\\]\nwhere:\n\n\\(e_t\\) is a vector of deterministic components (constant, trends, etc)\n\\(C, B_i\\) are conformable matrices\n\\(u_t\\) is vector white noise\n\nThis can be rewritten compactly as:\n\\[\n    y_t' = z_t' B_+' + u_t'\n\\]\nwhere:\n\n\\(z_t = [e_t; y_{t-1}; ...; y_{t-p}]\\) includes deterministic components and lagged values of all variables\n\\(B_+ = [C, B_1, ..., B_p]\\) is the coefficient matrix stacking trend and autoregressive terms\n\nStacking observations from \\(t = p+1\\) to \\(T\\), the system can be written in matrix form:\n\\[\n    Y = X B_+' + U\n\\]\nwhere:\n\n\\(Y\\): an \\((T - p) \\times k\\) matrix of outcomes\n\\(X\\): an \\((T - p) \\times (k p + d)\\) matrix of regressors (lags and trends)\n\\(B_+\\): a \\(k \\times (kp + d)\\) matrix of coefficients where \\(d\\) is the number of deterministic components.\n\\(U\\): a \\((T - p) \\times k\\) matrix of residuals\n\nThis structure is represented by the VAR object.\n\n\n\nB::Matrix{&lt;:Number}: Coefficient matrix [C, B_1, ..., B_p]\nSigma_u::Matrix{&lt;:Number}: Covariance matrix of the error term\np::Int: Lag order of the VAR\ntrend_exponents::Vector{&lt;:Number}: Time trend exponents (e.g., [0,1] implies constant and linear trend)\ninput_data::DataFrame: Original dataset used to estimate the VAR\nY::Matrix{&lt;:Number}: Left-hand side matrix of outcomes y_t, shape (T - p, k)\nX::Matrix{&lt;:Number}: Right-hand side matrix of regressors z_t, shape (T - p, k * p + d)\nU::Matrix{&lt;:Number}: Residuals u_t, shape (T - p, k)\nYhat::Matrix{&lt;:Number}: Fitted values X * B_+', shape (T - p, k)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/VAR.html#keyword-arguments",
    "href": "documentation/julia/all-functions/VAR.html#keyword-arguments",
    "title": "VAR",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ntrend_exponents::Vector{&lt;:Number}: Exponents of time trends (default: [0])",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "VAR"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/is_structural.html",
    "href": "documentation/julia/all-functions/is_structural.html",
    "title": "is_structural",
    "section": "",
    "text": "is_structural\n\n\n\n\n\nis_structural(::Model)\nReturns true if the model is a structural model and false otherwise.\n\n\n\n\n\n\n\n\n\n\n\nis_structural\n\n\n\n\n\nis_structural(model::LP)\nAlways returns true. We assume here that local projections are only used to estimate structural IRFs. This is not always true. is_structural should thus be used with care in the case of local projections.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "is_structural"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/coeffs.html",
    "href": "documentation/julia/all-functions/coeffs.html",
    "title": "coeffs",
    "section": "",
    "text": "coeffs\n\n\n\n\n\ncoeffs(::Model, args...)\nReturns the coefficient estimates of the model.\n\n\n\n\n\n\n\n\n\n\n\ncoeffs\n\n\n\n\n\ncoeffs(model::LP, exclude_deterministic::Bool=false)\nReturns the coefficient estimates of the local projections. The returned object is three dimensional with the coefficients for each horizon stacked along the third dimension. If exclude_deterministic is true, then all coefficients for deterministic variables, i.e. the coefficient on the constant, will be removed.\nCoefficients for each horizon have the ordering [constant, contemporaneous controls, treatment, lagged controls]",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "coeffs"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/to_transmission_irfs.html",
    "href": "documentation/julia/all-functions/to_transmission_irfs.html",
    "title": "to_transmission_irfs",
    "section": "",
    "text": "to_transmission_irfs\n\n\n\n\n\nto_transmission_irfs(irfs::AbstractArray{T, 3})\nTransform a standard three dimensional IRF array into a IRF matrix. The\n\n\n\nirfs::AbstractArray{T, 3}: IRF Array of dimension nvariabels × nshocks × n_horizons with the first horizons corresponding to horizon 0.\n\n\n\n\n\nMatrix{T} of dimension (nvariables  nhorizons) × (nvariables * n*horizons). This is the same as what would be obtained via \\((I-B)^{-1}\\mathbb{Q}\\) using the notation of Wegner et al (2024).",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "to_transmission_irfs"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/to_transmission_irfs.html#arguments",
    "href": "documentation/julia/all-functions/to_transmission_irfs.html#arguments",
    "title": "to_transmission_irfs",
    "section": "",
    "text": "irfs::AbstractArray{T, 3}: IRF Array of dimension nvariabels × nshocks × n_horizons with the first horizons corresponding to horizon 0.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "to_transmission_irfs"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/to_transmission_irfs.html#returns",
    "href": "documentation/julia/all-functions/to_transmission_irfs.html#returns",
    "title": "to_transmission_irfs",
    "section": "",
    "text": "Matrix{T} of dimension (nvariables  nhorizons) × (nvariables * n*horizons). This is the same as what would be obtained via \\((I-B)^{-1}\\mathbb{Q}\\) using the notation of Wegner et al (2024).",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "to_transmission_irfs"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/not_through.html",
    "href": "documentation/julia/all-functions/not_through.html",
    "title": "not_through",
    "section": "",
    "text": "not_through\n\n\n\n\n\nnot_through(idx, horizons, order) --&gt; Q\nAll paths cannot go through variables in idx in periods horizons. Note, this uses the dynamic system notation y such that idx refers to the index of the variable in the original dynamic system, i.e. in the SVARMA.\n\n\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths cannot go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths cannot go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths cannot go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths cannot go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\n\n\n\n\nReturns a transmission condition Q.\n\n\n\n\n\nThe transmission effect can be calculated using transmission.\n\n\n\n\nThe non-contemporaneous channel of monetary policy is defined in Section 5.1 of Wegner et al (2024) as the effect not going through a contemporaneous adjustment of the federal funds rate, where the transmission matrix orders the federal funds rate first. Thus, if the original SVAR has the federal funds rate ordered first, the non-contemporaneous effect can be obtained in the following ```{julia}.\nq = not_through(1, [0], 1:4)\nSimilarly, Wegner et al (2024) define the anticipation channel of government defense spending as the effect not going through government defense spending. With government defense spending ordered second in the VAR, the following can be used to obtain the anticipati```{julia}channel.\nq = not_through(2, 0:20, 1:4)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "not_through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/not_through.html#arguments",
    "href": "documentation/julia/all-functions/not_through.html#arguments",
    "title": "not_through",
    "section": "",
    "text": "For the single variable version:\n\nidx::Int: Index of variable through which the paths cannot go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths cannot go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths cannot go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths cannot go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "not_through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/not_through.html#returns",
    "href": "documentation/julia/all-functions/not_through.html#returns",
    "title": "not_through",
    "section": "",
    "text": "Returns a transmission condition Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "not_through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/not_through.html#notes",
    "href": "documentation/julia/all-functions/not_through.html#notes",
    "title": "not_through",
    "section": "",
    "text": "The transmission effect can be calculated using transmission.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "not_through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/not_through.html#examples",
    "href": "documentation/julia/all-functions/not_through.html#examples",
    "title": "not_through",
    "section": "",
    "text": "The non-contemporaneous channel of monetary policy is defined in Section 5.1 of Wegner et al (2024) as the effect not going through a contemporaneous adjustment of the federal funds rate, where the transmission matrix orders the federal funds rate first. Thus, if the original SVAR has the federal funds rate ordered first, the non-contemporaneous effect can be obtained in the following ```{julia}.\nq = not_through(1, [0], 1:4)\nSimilarly, Wegner et al (2024) define the anticipation channel of government defense spending as the effect not going through government defense spending. With government defense spending ordered second in the VAR, the following can be used to obtain the anticipati```{julia}channel.\nq = not_through(2, 0:20, 1:4)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "not_through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/ExternalInstrument.html",
    "href": "documentation/julia/all-functions/ExternalInstrument.html",
    "title": "ExternalInstrument",
    "section": "",
    "text": "ExternalInstrument\n\n\n\n\n\nExternalInstrument &lt;: AbstractIdentificationMethod\nIdentification method using external instruments for structural shock identification in time series models.\nExternal instruments serve as proxies for structural shocks and are not included in the estimation model (e.g., a VAR), but are used in instrumental variable estimators such as two-stage least squares (2SLS).\nThis method identifies relative structural impulse response functions (IRFs), meaning that the scale of the identified shock is normalised. Specifically, the IRF is scaled such that the response of the treatment variable equals one at a given normalising horizon.\nThis approach also generalises to the Local Projections Instrumental Variables (LP-IV) framework and supports the use of multiple instruments.\nThe method is based on:\nStock, J. H., & Watson, M. W. (2018). Identification and Estimation of Dynamic Causal Effects in Macroeconomics Using External Instruments. The Economic Journal, 128(610), 917–948. https://doi.org/10.1111/ecoj.12593\n\n\n\ntreatment::Union{Symbol, Int}: the variable used to normalise the IRF\ninstruments::AbstractMatrix: matrix of external instruments\nnormalising_horizon::Int: the horizon at which the IRF of the treatment variable is set to one",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/ExternalInstrument.html#arguments",
    "href": "documentation/julia/all-functions/ExternalInstrument.html#arguments",
    "title": "ExternalInstrument",
    "section": "Arguments",
    "text": "Arguments\n\ntreatment::Union{Symbol, Int}: treatment variable in the model data specified either as the column index in the data or by variable name.\ninstruments::Union{AbstractMatrix, DataFrame}: observations of external instruments. Instruments must be observed over the same period as the model data.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/ExternalInstrument.html#keyword-arguments",
    "href": "documentation/julia/all-functions/ExternalInstrument.html#keyword-arguments",
    "title": "ExternalInstrument",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\nnormalising_horizon::Int: horizon of the treatment variable with respect to which all IRFs are normalised.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "ExternalInstrument"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/is_stable.html",
    "href": "documentation/julia/all-functions/is_stable.html",
    "title": "is_stable",
    "section": "",
    "text": "is_stable\n\n\n\n\n\nis_stable(model::Union{VAR,SVAR}) -&gt; Bool\nis_stable(C::AbstractMatrix) -&gt; Bool\nChecks whether a VAR model or a companion matrix corresponds to a stable VAR process.\nA VAR system is stable if all eigenvalues of its companion matrix lie strictly inside the unit circle. This is equivalent to requiring that the spectral radius is less than one:\n\\[\n\\rho(C) = \\max_i |\\lambda_i| &lt; 1\n\\]\n\nArguments\n\nmodel::VAR: A fitted VAR model\nC::AbstractMatrix: A companion matrix\n\n\n\nReturns\n\nBool: true if the VAR is stable, false otherwise",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "is_stable"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/simulate.html",
    "href": "documentation/julia/all-functions/simulate.html",
    "title": "simulate",
    "section": "",
    "text": "simulate\n\n\n\n\n\nsimulate(::Type{VAR}, T::Int, B::Matrix{&lt;:Number},\n         Sigma_u::Matrix{&lt;:Number}=I(size(B,1));\n         trend_exponents::Vector{&lt;:Number}=[0],\n         initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; VAR\n\nsimulate!(::Type{VAR}, errors::Matrix{&lt;:Number}, B::Matrix{&lt;:Number};\n          trend_exponents::Vector{&lt;:Number}=[0],\n          initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; VAR\nSimulates a VAR(p) model using the specified coefficient matrix B and optionally a covariance matrix Sigma_u and deterministic trends.\nThe simulation uses the reduced-form VAR representation:\n\\[\n    y_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\n\\]\n\nMethod 1: simulate!\nSimulates a VAR process by overwriting the provided error matrix errors with simulated values. Returns a VAR object constructed from the simulated data.\n\n\nMethod 2: simulate\nGenerates error terms internally from a Gaussian distribution with covariance Sigma_u (default is the identity matrix). Returns a VAR object containing the simulated series.\n\n\nArguments\n\nB::Matrix{&lt;:Number}: Coefficient matrix [C B_1 ... B_p], size k × (k * p + m), where m is the number of deterministic components.\ntrend_exponents::Vector{&lt;:Number}: Exponents used to simulate trends (e.g. [0,1] implies constant and linear trend)\ninitial::Union{Nothing, Vector{&lt;:Number}}: Optional initial values for lags (length k * p). Default is zero.\nT::Int: Number of time periods to simulate\nSigma_u::Matrix{&lt;:Number}: Covariance matrix of the error term (default is identity)\nerrors::Matrix{&lt;:Number}: Pre-allocated matrix of shape k × T, initially filled with innovations, overwritten with simulated data\n\n\n\nReturns\n\nVAR: A new VAR object containing the simulated dataset. The data can be obtained using get_input_data. Alternatively, the model can be directly estimated using fit!.\n\n\n\n\n\n\n\n\n\n\n\n\n\nsimulate\n\n\n\n\n\nsimulate(::Type{SVAR}, shocks::Matrix{&lt;:Number}, A0::Matrix{&lt;:Number},\n         A_plus::Matrix{&lt;:Number};\n         trend_exponents::Vector{&lt;:Number}=[0],\n         initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; SVAR\n\nsimulate(::Type{SVAR}, T::Int, A0::Matrix{&lt;:Number}, A_plus::Matrix{&lt;:Number};\n         trend_exponents::Vector{&lt;:Number}=[0],\n         initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; SVAR\nSimulates a structural VAR (SVAR) model using the structural form characterised by matrices A0 and A_plus.\nThe SVAR model is given by:\n\\[\n    A_0 y_t = C e_t + A_1 y_{t-1} + ... + A_p y_{t-p} + \\varepsilon_t\n\\]\n\nMethod 1: simulate(::Type{SVAR}, shocks, A0, A_plus)\nSimulates an SVAR process given structural shocks.\n\n\nMethod 2: simulate(::Type{SVAR}, T, A0, A_plus)\nGenerates random structural shocks from a multivariate Guassian with identify covariance and simulates the SVAR process using these shocks.\n\n\nArguments\n\nA0::Matrix{&lt;:Number}: Contemporaneous impact matrix (invertible)\nA_plus::Matrix{&lt;:Number}: Coefficient matrix [C A_1 ... A_p] (size k × (k*p + m)) where m is the number of exogenous components.\nshocks::Matrix{&lt;:Number}: Structural shocks of shape k × T\nT::Int: Number of time periods to simulate\ntrend_exponents::Vector{&lt;:Number}: Exponents for deterministic trends (e.g., [0,1] for constant and linear trend)\ninitial::Union{Nothing, Vector{&lt;:Number}}: Optional initial conditions for lagged variables (length k * p). If nothing lags will be initialised at zero.\n\n\n\nReturns\n\nSVAR: A simulated SVAR model containing the generated dataset. The data can be accessed using get_input_data, or the model can be estimated using fit!.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "simulate"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html",
    "href": "documentation/julia/all-functions/transmission.html",
    "title": "transmission",
    "section": "",
    "text": "transmission\n\n\n\n\n\ntransmission(from::Int, arr1::AbstractMatrix{T}, arr2::AbstractMatrix{T}, q::Q; method = :BOmega) where {T}\nGiven a transmission condition q, calculate the transmission effect using the either the :BOmega method (the default), or the :irfs method.\n\n\n\nfrom::Int: Shock number.\narr1::AbstractMatrix{T}. In case of :BOmega this must be B, in case of :irfs this must be irfs. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\narr2::AbstractMatrix{T}: In case of :BOmega this must be Omega, in case of :irfs this must be irfs_ortho. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\nq::Q: A transmission condition. See also Q.\n\n\n\n\n\nmethod::Symbol: Either :BOmega in which case the transmission effect will be calculated using the second method in Wegner et al (2024), or :irfs in which case the transmission effect is calculated using the first method in Wegner et al (2024).\n\n\n\n\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.\n\n\n\n\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond; method = :BOmega)\neffect = transmission(1, B, Omega, cond)  # same as above; default is :BOmega\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#arguments",
    "href": "documentation/julia/all-functions/transmission.html#arguments",
    "title": "transmission",
    "section": "",
    "text": "from::Int: Shock number.\narr1::AbstractMatrix{T}. In case of :BOmega this must be B, in case of :irfs this must be irfs. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\narr2::AbstractMatrix{T}: In case of :BOmega this must be Omega, in case of :irfs this must be irfs_ortho. See the documentation for the specific methods for transmission(..., ::Type{Val{:BOmega}}) and transmission(...,::Type{Val{:irfs}}).\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#keyword-arguments",
    "href": "documentation/julia/all-functions/transmission.html#keyword-arguments",
    "title": "transmission",
    "section": "",
    "text": "method::Symbol: Either :BOmega in which case the transmission effect will be calculated using the second method in Wegner et al (2024), or :irfs in which case the transmission effect is calculated using the first method in Wegner et al (2024).",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#returns",
    "href": "documentation/julia/all-functions/transmission.html#returns",
    "title": "transmission",
    "section": "",
    "text": "Returns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#exajuliaes",
    "href": "documentation/julia/all-functions/transmission.html#exajuliaes",
    "title": "transmission",
    "section": "",
    "text": "k = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond; method = :BOmega)\neffect = transmission(1, B, Omega, cond)  # same as above; default is :BOmega\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#arguments-1",
    "href": "documentation/julia/all-functions/transmission.html#arguments-1",
    "title": "transmission",
    "section": "Arguments",
    "text": "Arguments\n\nfrom::Int: Shock number.\nB::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nOmega::AbstractMatrix{T}: Part of the systems representation in Wegner et al (2024).\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#returns-1",
    "href": "documentation/julia/all-functions/transmission.html#returns-1",
    "title": "transmission",
    "section": "Returns",
    "text": "Returns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#exajuliaes-1",
    "href": "documentation/julia/all-functions/transmission.html#exajuliaes-1",
    "title": "transmission",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nB = randn(k*(h+1), k*(h+1))\nOmega = randn(k*(h+1), k*(h+1))\n\neffect = transmission(1, B, Omega, cond)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#arguments-2",
    "href": "documentation/julia/all-functions/transmission.html#arguments-2",
    "title": "transmission",
    "section": "Arguments",
    "text": "Arguments\n\nfrom::Int: Shock number.\nirfs::AbstractMatrix{T}: Impulse responses. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nirfs_ortho::AbstractMatrix{T}: Orthogonalised IRFs. These should be in the form of the structural transmission model. See also to_transmission_irfs.\nq::Q: A transmission condition. See also Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#returns-2",
    "href": "documentation/julia/all-functions/transmission.html#returns-2",
    "title": "transmission",
    "section": "Returns",
    "text": "Returns\n\nReturns a Vector{T} with entry i corresponding to the transmission effect on variable \\(x_i\\). If \\(x_k\\) is the variable in the transmission condition with the highest subscript, then all entries in the returned vector with index less thatn k are NaN since interpretation of those results is nonsensical.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#exajuliaes-2",
    "href": "documentation/julia/all-functions/transmission.html#exajuliaes-2",
    "title": "transmission",
    "section": "Exa```{julia}es",
    "text": "Exa```{julia}es\nk = 6\nh = 3\ns = \"(x1 | x2) & !x3\"\ncond = make_condition(s)\n\nirfs = randn(k, k, h+1)\nirfs_ortho = randn(k, k, h+1)\n\nirfs = to_transmission_irfs(irfs)\nirfs_ortho = to_transmission_irfs(irfs_ortho)\n\neffect = transmission(1, irfs, irfs_ortho, cond; method = :irfs)",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#arguments-3",
    "href": "documentation/julia/all-functions/transmission.html#arguments-3",
    "title": "transmission",
    "section": "Arguments",
    "text": "Arguments\n\nmodel::Model: A model, such as an SVAR, VAR, or LP.\nmethod::AbstractIdentificationMethod: An identification method to identify the from-th structural shock.\nfrom::Int: Shock number.\nq::Q: A transmission condition. See also Q and make_condition.\norder::AbnstractVector{&lt;:Int}: order of variables defined by the transmission matrix using variable indices.\norder::AbnstractVector{Symbol}: order of variables defined by the transmission matrix using variable names.\nmax_horizon::Int: Maximum horizon for the transmission effect.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/transmission.html#returns-3",
    "href": "documentation/julia/all-functions/transmission.html#returns-3",
    "title": "transmission",
    "section": "Returns",
    "text": "Returns\n\nReturns a three dimensional array with the first dimension correspondin to the endogenous variables (in original order), the second to the shock, and the third to the horizon (from 0 to max_horizon).",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "transmission"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/identify!.html",
    "href": "documentation/julia/all-functions/identify!.html",
    "title": "identify!",
    "section": "",
    "text": "identify!\n\n\n\n\n\nNo documentation found for public symbol.\n\n\n\n\n\n\n\n\n\n\n\nidentify!\n\n\n\n\n\nTransmissionChannelAnalysis.identify! is a Function.\n\n\n\n\n\n\n\n\n\n\n\nidentify!\n\n\n\n\n\n# 1 method for generic function \"identify!\" from TransmissionChannelAnalysis:\n [1] identify!(model::TransmissionChannelAnalysis.SVAR, method::TransmissionChannelAnalysis.AbstractIdentificationMethod)\n     @ ~/.julia/packages/TransmissionChannelAnalysis/ZQ5o4/src/models/svar.jl:200",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "identify!"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/LP.html",
    "href": "documentation/julia/all-functions/LP.html",
    "title": "LP",
    "section": "",
    "text": "LP\n\n\n\n\n\nLP &lt;: Model\nLocal Projection (LP) model for estimating impulse response functions (IRFs) in a flexible and semi-parametric manner.\nEach LP regression estimates the dynamic response of an outcome variable at future horizon h to a one-period change in a treatment variable at time t, controlling for contemporaneous and lagged covariates.\nThe regression model is specified as:\n\\[\n    w_{i,t+h} = \\mu_{i,h} + \\theta_{i,h} x_t + \\gamma_{i,h}' r_t +\n                \\sum_{l=1}^p \\delta_{i,h,l} w_{t-l} + \\xi_{i,h,t}\n\\]\nwhere \\(w_t = (r_t', x_t, q_t')\\) and:\n\n\\(x_t\\) is the treatment variable\n\\(r_t\\) contains contemporaneous controls (all variables before x_t)\n\\(p\\) is the number of lags included\n\\(\\theta_{i,h}\\) is the relative IRF of x_t on the i-th variable at horizon \\(h\\).\n\nThe treatment variable may be endogenous. Structural interpretation of IRFs can be achieved using valid instruments—see ExternalInstrument for one such method. If the treatment satisfies a conditional ignorability assumption (a recursive assumption in macro), then the coefficient has a structural interpretation even without the use of instruments. For this to hold, \\(x_t - E(x_t|r_t, w_{t-1}, ..., w_{t-p})\\) must be equal to the structural shock.\n\n\n\ndata::DataFrame: the dataset containing the time series\ntreatment::Union{Symbol, Int}: column indicating the treatment variable\np::Int: number of lags to include\nhorizons::AbstractVector{&lt;:Int}: forecast horizons for the projections\ninclude_constant::Bool: whether to include an intercept in each regression\ncoeffs::AbstractArray{&lt;:Number}: coefficient estimates per horizon\nY::AbstractArray{&lt;:Number}: dependent variables for each horizon\nX::AbstractMatrix{&lt;:Number}: common regressor matrix\nU::AbstractArray{&lt;:Number}: residuals per horizon\nYhat::AbstractArray{&lt;:Number}: fitted values per horizon",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/LP.html#keyword-arguments",
    "href": "documentation/julia/all-functions/LP.html#keyword-arguments",
    "title": "LP",
    "section": "Keyword Arguments",
    "text": "Keyword Arguments\n\ninclude_constant: whether to include a constant in the regressors",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "LP"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/through.html",
    "href": "documentation/julia/all-functions/through.html",
    "title": "through",
    "section": "",
    "text": "through\n\n\n\n\n\nthrough(idx, horizons, order) --&gt; Q\nAll paths must go through variables in idx in periods horizons. Note, this uses the dynamic system notation y such that idx refers to the index of the variable in the original dynamic system, i.e. in the SVARMA.\n\n\nFor the single variable version:\n\nidx::Int: Index of variable through which the paths should go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths must go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths should go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths must go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\n\n\n\n\nReturns a transmission condition Q.\n\n\n\n\n\nThe transmission effect can be calculated using transmission.\n\n\n\n\nSuppose we are interested in the contemporaneous channel in Section 5.1 of Wegner et al (2024), i.e. we are interested in the effect going through the federal funds rate contemporaneously. In our estimated model, the federal funds rate is the first variable. We would thus define the contemporaneous channe```{julia}s\ncontemporaneous_channel = through(1, [0], 1:4)  # we have four variables with ffr being first\nMore generally, we could define the following, which would be the effect through the federal funds rate in the first t```{julia}periods.\nq = through(1, [0, 1], 1:4)\nThe following is also allowed which is the effect through the federal funds rate contemporaneously and one period later, and through the output gap contemporaneously and one period later, where the federal funds rate is ordered first and the ```{julia}put gap second.\nq = through([1, 2], [[0, 1], [0, 1]], 1:4)\nIf we want to re-order the federal funds rate after the output gap, we simply change the ordering to [2, 1, 3, 4] where 2 corresponds to the output gap ```{julia}the original ordering.\nq = through([1, 2], [[0, 1], [0, 1]], [2, 1, 3, 4])",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/through.html#arguments",
    "href": "documentation/julia/all-functions/through.html#arguments",
    "title": "through",
    "section": "",
    "text": "For the single variable version:\n\nidx::Int: Index of variable through which the paths should go. This is the original index in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::AbstractVector{&lt;:Int}: Horizons for which the paths must go through the variable.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix\n\nFor the multiple variable version:\n\nidx::AbstractVector{&lt;:Int}: Indices of variables through which the paths should go. These are the original indices in the dynamic system, e.g. the SVAR, before applying the transmission matrix.\nhorizons::Union{AbstractVector{&lt;:Int},Vector{AbstractVector{&lt;:Int}}}: Horizons for which the paths must go through the variable. Must either be a vector for each variable in idx or a single vector. If it is a single vector, then the horizons will be applied to each variable in idx.\norder::AbstractVector{&lt;:Int}: Variable ordering determined by the transmission matrix",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/through.html#returns",
    "href": "documentation/julia/all-functions/through.html#returns",
    "title": "through",
    "section": "",
    "text": "Returns a transmission condition Q.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/through.html#notes",
    "href": "documentation/julia/all-functions/through.html#notes",
    "title": "through",
    "section": "",
    "text": "The transmission effect can be calculated using transmission.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/through.html#examples",
    "href": "documentation/julia/all-functions/through.html#examples",
    "title": "through",
    "section": "",
    "text": "Suppose we are interested in the contemporaneous channel in Section 5.1 of Wegner et al (2024), i.e. we are interested in the effect going through the federal funds rate contemporaneously. In our estimated model, the federal funds rate is the first variable. We would thus define the contemporaneous channe```{julia}s\ncontemporaneous_channel = through(1, [0], 1:4)  # we have four variables with ffr being first\nMore generally, we could define the following, which would be the effect through the federal funds rate in the first t```{julia}periods.\nq = through(1, [0, 1], 1:4)\nThe following is also allowed which is the effect through the federal funds rate contemporaneously and one period later, and through the output gap contemporaneously and one period later, where the federal funds rate is ordered first and the ```{julia}put gap second.\nq = through([1, 2], [[0, 1], [0, 1]], 1:4)\nIf we want to re-order the federal funds rate after the output gap, we simply change the ordering to [2, 1, 3, 4] where 2 corresponds to the output gap ```{julia}the original ordering.\nq = through([1, 2], [[0, 1], [0, 1]], [2, 1, 3, 4])",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "through"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/nobs.html",
    "href": "documentation/julia/all-functions/nobs.html",
    "title": "nobs",
    "section": "",
    "text": "nobs\n\n\n\n\n\nnobs(::Model)\nReturns the effective number of observations used for the estimation of the model.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "nobs"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/identify.html",
    "href": "documentation/julia/all-functions/identify.html",
    "title": "identify",
    "section": "",
    "text": "identify\n\n\n\n\n\nNo documentation found for public symbol.\n\n\n\n\n\n\n\n\n\n\n\nidentify\n\n\n\n\n\nTransmissionChannelAnalysis.identify is a Function.\n\n\n\n\n\n\n\n\n\n\n\nidentify\n\n\n\n\n\n# 1 method for generic function \"identify\" from TransmissionChannelAnalysis:\n [1] identify(model::TransmissionChannelAnalysis.VAR, method::TransmissionChannelAnalysis.AbstractIdentificationMethod)\n     @ ~/.julia/packages/TransmissionChannelAnalysis/ZQ5o4/src/models/svar.jl:206",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "identify"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/get_dependent.html",
    "href": "documentation/julia/all-functions/get_dependent.html",
    "title": "get_dependent",
    "section": "",
    "text": "get_dependent\n\n\n\n\n\nget_dependent(::Model)\nReturns the dependent variables.\n\n\n\n\n\n\n\n\n\n\n\nget_dependent\n\n\n\n\n\nget_dependent(model::LP)\nThe dependent variables are returned as a three dimensional array, with the third dimension corresponding the the various forecast horizons.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "get_dependent"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/spectral_radius.html",
    "href": "documentation/julia/all-functions/spectral_radius.html",
    "title": "spectral_radius",
    "section": "",
    "text": "spectral_radius\n\n\n\n\n\nspectral_radius(X::AbstractMatrix) -&gt; Number\nComputes the spectral radius of a matrix X.\n\nDescription\nThe spectral radius of a matrix is defined as the largest absolute eigenvalue of the matrix.\nMathematically, for a given square matrix X, the spectral radius is computed as:\n\\[\n\\rho(X) = \\max |\\lambda_i|\n\\]\nwhere \\lambda_i are the eigenvalues of X.\n\n\nArguments\n\nX::AbstractMatrix: A square matrix.\n\n\n\nReturns\n\nThe spectral radius of X.\n\n\n\nEx```{julia}le\nX = [0.5 0.2; 0.1 0.9]\nr = spectral_radius(X)\n\n\n\n\n\n\n\n\n\n\n\n\nspectral_radius\n\n\n\n\n\nspectral_radius(model::Union{VAR,SVAR}) -&gt; Real\nComputes the spectral radius of the companion matrix of a fitted VAR model.\nThe spectral radius of a matrix \\(A\\) is defined as the largest absolute value among its eigenvalues:\n\\[\n\\rho(A) = \\max_i |\\lambda_i|\n\\]\nwhere \\(\\lambda_i\\) are the eigenvalues of \\(A\\).\nIn the context of VAR models, the spectral radius of the companion matrix is a key measure of stability. A VAR model is stable if the spectral radius is strictly less than 1.\n\nArguments\n\nmodel::VAR: A fitted VAR model",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "spectral_radius"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/set_remove_contradictions.html",
    "href": "documentation/julia/all-functions/set_remove_contradictions.html",
    "title": "set_remove_contradictions",
    "section": "",
    "text": "set_remove_contradictions\n\n\n\n\n\nset_remove_contradictions(b::Bool)\nSets REMOVE_CONTRADICTIONS to b.\nIf REMOVE_CONTRADICTIONS==true, then contradicting terms are removed before the transmission effect is computed. A term is deemed contradicting if it includes some “xi & !xi”. This would result in the entire Boolean statement to be false, and thus in the effect of this terms to be zero.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "set_remove_contradictions"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/sic.html",
    "href": "documentation/julia/all-functions/sic.html",
    "title": "sic",
    "section": "",
    "text": "sic\n\n\n\n\n\naic(model::Union{VAR,SVAR}) -&gt; Real\naic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nbic(model::Union{VAR,SVAR}) -&gt; Real\nbic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nsic(model::Union{VAR,SVAR}) -&gt; Real\nsic(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\n\nhqc(model::Union{VAR,SVAR}) -&gt; Real\nhqc(Sigma_u::Matrix{&lt;:Number}, num_coeffs::Int, T::Int) -&gt; Real\nComputes information criteria for model selection in VARs.\nGiven a fitted VAR model or directly the covariance matrix Sigma_u, the number of estimated coefficients, and sample size T, each function returns the respective criterion value:\n\nAIC (Akaike Information Criterion):\n\n\\[\n\\text{AIC} = \\log\\det(\\Sigma_u) + \\frac{2k}{T}\n\\]\n\nSIC/BIC (Schwarz/Bayesian Information Criterion):\n\n\\[\n\\text{SIC} = \\log\\det(\\Sigma_u) + \\frac{\\log(T) k}{T}\n\\]\n\nHQC (Hannan-Quinn Criterion):\n\n\\[\n\\text{HQC} = \\log\\det(\\Sigma_u) + \\frac{2 \\log(\\log T) k}{T}\n\\]\nHere, \\(k\\) is the number of estimated parameters and \\(T\\) is the effective sample size.\n\nArguments\n\nmodel::VAR: A fitted VAR model\nSigma_u::Matrix{&lt;:Number}: Residual covariance matrix\nnum_coeffs::Int: Number of estimated coefficients\nT::Int: Number of observations used in estimation",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "sic"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/simulate!.html",
    "href": "documentation/julia/all-functions/simulate!.html",
    "title": "simulate!",
    "section": "",
    "text": "simulate!\n\n\n\n\n\nsimulate(::Type{VAR}, T::Int, B::Matrix{&lt;:Number},\n         Sigma_u::Matrix{&lt;:Number}=I(size(B,1));\n         trend_exponents::Vector{&lt;:Number}=[0],\n         initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; VAR\n\nsimulate!(::Type{VAR}, errors::Matrix{&lt;:Number}, B::Matrix{&lt;:Number};\n          trend_exponents::Vector{&lt;:Number}=[0],\n          initial::Union{Nothing,Vector{&lt;:Number}}=nothing) -&gt; VAR\nSimulates a VAR(p) model using the specified coefficient matrix B and optionally a covariance matrix Sigma_u and deterministic trends.\nThe simulation uses the reduced-form VAR representation:\n\\[\n    y_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\n\\]\n\nMethod 1: simulate!\nSimulates a VAR process by overwriting the provided error matrix errors with simulated values. Returns a VAR object constructed from the simulated data.\n\n\nMethod 2: simulate\nGenerates error terms internally from a Gaussian distribution with covariance Sigma_u (default is the identity matrix). Returns a VAR object containing the simulated series.\n\n\nArguments\n\nB::Matrix{&lt;:Number}: Coefficient matrix [C B_1 ... B_p], size k × (k * p + m), where m is the number of deterministic components.\ntrend_exponents::Vector{&lt;:Number}: Exponents used to simulate trends (e.g. [0,1] implies constant and linear trend)\ninitial::Union{Nothing, Vector{&lt;:Number}}: Optional initial values for lags (length k * p). Default is zero.\nT::Int: Number of time periods to simulate\nSigma_u::Matrix{&lt;:Number}: Covariance matrix of the error term (default is identity)\nerrors::Matrix{&lt;:Number}: Pre-allocated matrix of shape k × T, initially filled with innovations, overwritten with simulated data\n\n\n\nReturns\n\nVAR: A new VAR object containing the simulated dataset. The data can be obtained using get_input_data. Alternatively, the model can be directly estimated using fit!.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "simulate!"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/is_fitted.html",
    "href": "documentation/julia/all-functions/is_fitted.html",
    "title": "is_fitted",
    "section": "",
    "text": "is_fitted\n\n\n\n\n\nis_fitted(::Model)\nReturn true if the model as been estimated. Returns false otherwise.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "is_fitted"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/InternalInstrument.html",
    "href": "documentation/julia/all-functions/InternalInstrument.html",
    "title": "InternalInstrument",
    "section": "",
    "text": "InternalInstrument\n\n\n\n\n\nInternalInstrument &lt;: AbstractIdentificationMethod\nIdentification method using internal instruments within a VAR framework.\nThis method estimates relative structural impulse response functions (IRFs) using an internal instrument—i.e., a variable within the system that is assumed to proxy for a structural shock of interest. The IRFs are normalised such that the response of a designated normalising variable equals one at a specific horizon.\nThis approach is based on:\nPlagborg-Møller, M., & Wolf, C. K. (2021). Local Projections and VARs Estimate the Same Impulse Responses. Econometrica, 89(2), 955–980. https://doi.org/10.3982/ecta17813\n\nFields\n\ninstrument::Union{Symbol, Int}: the variable to be used as the instrument\nnormalising_variable::Union{Symbol, Int}: the variable used to normalise the IRF\nnormalising_horizon::Int: the horizon at which the IRF of the normalising variable is set to one\n\n\n\n\n\n\n\n\n\n\n\n\n\nInternalInstrument\n\n\n\n\n\nInternalInstrument(normalising_variable::Union{Symbol, Int};\n                   instrument::Union{Symbol, Int}=1,\n                   normalising_horizon::Int=0)\nConstructs an InternalInstrument identification method with the given normalising variable, optional instrument (default is the first variable), and normalisation horizon (default is 0).",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "InternalInstrument"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/get_independent.html",
    "href": "documentation/julia/all-functions/get_independent.html",
    "title": "get_independent",
    "section": "",
    "text": "get_independent\n\n\n\n\n\nget_independent(::Model)\nReturns the independent variables.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "get_independent"
    ]
  },
  {
    "objectID": "documentation/julia/all-functions/fitted.html",
    "href": "documentation/julia/all-functions/fitted.html",
    "title": "fitted",
    "section": "",
    "text": "fitted\n\n\n\n\n\nfitted(::Model)\nReturns the fitted values of the of the estimated model.\n\n\n\n\n\n\n\n\n\n\n\nfitted\n\n\n\n\n\nfitted(model::LP)\nReturns the fitted values of the local projection in a three dimensional array. The fitted values for each horizon are stacked along the third dimension. The second dimension corresponds to each variable.",
    "crumbs": [
      "Documentation",
      "Julia",
      "All",
      "fitted"
    ]
  },
  {
    "objectID": "faq/topics/boolean-conditions.html",
    "href": "faq/topics/boolean-conditions.html",
    "title": "What are Boolean Conditions?",
    "section": "",
    "text": "Transmission channels are a subset of the paths connecting a shock to an outcome variable in the associated graph. Since a channel is a subset, there must exist a Boolean condition that, when applied to all paths, will only be true for those of the transmission channel. In other words, there must exist some logical statement about which variables should and should not be on the paths, such that the collection of all paths can effectively filtered down to only those making up the transmission channel. Because of this relationship, transmission channels are most effectively defined using Boolean conditions.\nBoolean conditions and algebra, however, are not a standard tool in the economists toolbox. The above may thus sound a bit daunting, maybe even a bit intimidating, but it truly does not need to. Take, for example, the simple transmission channel having to go through \\(x_1\\) – note we will use the systems form throughout this article. Futher suppose that all available paths in the graph are the ones given below.\n\\[\n\\begin{array}{r}\n\\varepsilon_1 \\to x_1 \\to x_2 \\to x_3 \\\\\n\\varepsilon_1 \\to x_1 \\to x_3 \\\\\n\\varepsilon_1 \\to x_2 \\to x_3 \\\\\n\\varepsilon_1 \\to x_3 \\\\\n\\end{array}\n\\]\nThe paths corresponding to the transmission channel are then simply those paths in the first two rows. As a Boolean condition, we would have written this simply as \\(b=x_1\\), which denotes the same as saying that \\(x_1\\) must be on all paths. Note that if we were to check each path on whether it includes \\(x_1\\), we would obtain true, true, false, false for the four paths in the four rows respectively. Thus, the Boolean condition \\(b=x_1\\) indeed is only true for the paths making up the transmission channel.\nWhat if we wanted a transmission channel that either goes through \\(x_1\\) or \\(x_2\\). In that case, the paths corresponding to the transmission channel would be those of the first three rows. Using Booleans, we would use \\(\\lor\\) (for math) or | (for code) to denote the OR in our condition. Thus \\(b=x_1 \\lor x_2\\) is the corresponding Boolean condition. Note that checking each path on whether it satisfies this condition would now result in true, true, true, false and thus only the paths of the transmission channel are selected.\nAnd what if \\(x_2\\) should not be on any of the paths (we don’t care if \\(x_1\\) is on the path)? Then the paths corresponding to the transmission channel would be those in rows two and four. Using Booleans, we would use \\(\\neg\\) (for math) or ! (for code) to denote the NOT in our condition. The Boolean condition would thus read \\(b = \\neg x_2\\). Checking again all paths for this condition results in false, true, false, true and thus the correct paths are selected.\nLastly, what if we wanted both \\(x_1\\) and \\(x_2\\) to be on the paths? In that case only the first row would be in our transmission channel. The corresponding Boolean condition would be \\(b=x_1 \\land x_2\\) where \\(\\land\\) (in math) and & (in code) denotes the AND in our condition.\nAND, NOT, and OR can be combined in various ways to form complex conditions and thus complex transmission channels. Moreover, parentheses can be used to make these statements even more complicated. Since these complicated statements go far beyond the scope of this little Wiki, we invite the reader to read the Appendix of Wegner et al. (2025) and the references therein.\n\n\n\n\n\n\nWhere can I find more information?\n\n\n\nMore information can be found in the Appendix of Wegner et al. (2025) and the references therein.\n\n\n\nRead the Paper\n\n\n\n\n\nReferences\n\nWegner, Enrico, Lenard Lieb, Stephan Smeekes, and Ines Wilms. 2025. “Transmission Channel Analysis in Dynamic Models.” 2025. https://doi.org/10.48550/arxiv.2405.18987.",
    "crumbs": [
      "Home",
      "Wiki",
      "What are Boolean Conditions?"
    ]
  },
  {
    "objectID": "faq/topics/how-to-implement.html",
    "href": "faq/topics/how-to-implement.html",
    "title": "How can I implement TCA?",
    "section": "",
    "text": "We provide various packages to make the implementation of TCA easier. Currently, a Julia and Matlab (including Dynare) package exist. These packages all work similarly, with the Julia version being the most general. We also provide various tutorials that help in getting started.\nIf none of these packages are satisfactory for an application, then the only remaining option is to implement TCA from scratch. In most cases this will entail rewriting the transmission condition into a form that can be used to compute the transmission effect from either the systems form or directly from impulse response functions (IRFs). The Julia version could assist in the rewriting process – check the make_condition function for this. Once rewritten into an amendable form, transmission effects can be calculated along the way outlined in the appendix of Wegner et al. (2025).\n\n\n\n\n\n\nIf indeed none of the packages are able to compute the desired transmission effect, please get in contact with us. We try to make these libraries as general as we can, so finding a query that cannot be computed would provide us with key information on how to improve these packages.\n\n\n\n\nRead the Paper\n\n\n\n\n\nReferences\n\nWegner, Enrico, Lenard Lieb, Stephan Smeekes, and Ines Wilms. 2025. “Transmission Channel Analysis in Dynamic Models.” 2025. https://doi.org/10.48550/arxiv.2405.18987.",
    "crumbs": [
      "Home",
      "Wiki",
      "How can I implement TCA?"
    ]
  },
  {
    "objectID": "faq/topics/what-is-tca.html",
    "href": "faq/topics/what-is-tca.html",
    "title": "What is Transmission Channel Analysis (TCA)?",
    "section": "",
    "text": "Standard impulse response analysis only provides information about the total effect of a shock or a policy. However, two shocks or policies1 can have the same total effect on a variable but work in two very different ways. Thus, to distinguish between two shocks or to distinguish between two theories, pure impulse response analysis is sometimes not enough.\nTransmission Channel Analysis (TCA) is an analytic tool used to decompose impulse response functions into the effects along transmission channels. Transmission channels, on the other hand, are descriptions of a how a shock or a policy work. Thus, TCA allows to quantify the different channels or machanisms behind total effects.",
    "crumbs": [
      "Home",
      "Wiki",
      "What is Transmission Channel Analysis (TCA)?"
    ]
  },
  {
    "objectID": "faq/topics/what-is-tca.html#what-does-tca-do-intuitively",
    "href": "faq/topics/what-is-tca.html#what-does-tca-do-intuitively",
    "title": "What is Transmission Channel Analysis (TCA)?",
    "section": "What does TCA do (intuitively)?",
    "text": "What does TCA do (intuitively)?\nThink about what happens after a contractionary monetary policy shock. The shock will increase the policy rate. Because the policy rate indirectly determines other rates, corporate bond rates will increase. Higher corporate bond rates, on the other hand, increase the funding costs of firms, but also increases the incentive to invest in corporate bonds. The former will most likely lead to lower capital investments, while the latter will lead to an increase in savings. Either of these effects will decrease aggregate demand and will thus lead to downward pressure on prices.\nRather than describing the shocks propagation in words, we could have also used a graphical representation like the following.\n\n\n\n\n\n\nflowchart LR\n  A[Monetary policy shock] --&gt; B[Policy rate]\n  B --&gt; C[Corporate bond rates]\n  C --&gt; D[Funding cost of firms]\n  C --&gt; E[Incentive to save]\n  D --&gt; F[Capital investments]\n  E --&gt; G[Savings]\n  F --&gt; H[Aggregate demand]\n  G --&gt; H\n  H --&gt; I[Prices]\n\n\n\n\n\n\n\n\nThis graphical representation is often more intuitive since it directly shows the various paths that the shock can take to arrive at prices. Each of these paths represents one transmission channel – or machanism – behind the shock’s total effect on prices.\nTransmission Channel Analysis uses the fact that graphs are often more intuitive and defines dynamic models in terms of graphs2, similar to the one above, but now including the time dimension. Channels – descriptions of how a shock propagates through the system to a specific variable – are then defined as paths through the graph. By tracing the effect along a subcollection of paths, i.e. by tracing the effect of the shock but ignoring some of the paths, various new insights can be gained. Moreover, by keeping track of the effects when moving from one node to another, TCA can quantify the effect along all transmission channels and can thus fully decompose the total effect.\n\n\n\n\n\n\nWant to know more?\n\n\n\nMore information about what TCA is, including small examples, can be found in Sections 1 and 2 of Wegner et al. (2025).\n\n\n\nRead the Paper",
    "crumbs": [
      "Home",
      "Wiki",
      "What is Transmission Channel Analysis (TCA)?"
    ]
  },
  {
    "objectID": "faq/topics/what-is-tca.html#footnotes",
    "href": "faq/topics/what-is-tca.html#footnotes",
    "title": "What is Transmission Channel Analysis (TCA)?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe will use shock and policy interchangeably throughout the rest.↩︎\nWegner et al. (2025) refer to this graph as the associated graph.↩︎",
    "crumbs": [
      "Home",
      "Wiki",
      "What is Transmission Channel Analysis (TCA)?"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "Examples on how to implement a transmission channel analysis in Julia and Matlab can be found below. We provide examples for local projections (LP) and SVARs for both packages. DSGEs, however, are only supported by the Matlab package. Choose your preferred language below.\n\n\n\n\n\n\nThe examples are still actively under construction and most examples do not yet exist. Please come back at a later point. Note that the documentation provides details on the use of LPs, SVARs, and DSGEs.\n\n\n\nJulia\n\nSVAR: Forward guidance of monetary policy\nLP: Anticipation effects of government spending\n\nMatlab\n\nSVAR: Forward guidance of monetary policy\nLP: Anticipation effects of government spending using\nDSGE: The wage channel of monetary policy",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html",
    "href": "examples/matlab/lp/index.html",
    "title": "TCA in Local Projections",
    "section": "",
    "text": "In this example, we examine the anticipation and implementation effects of government defense spending, closely following Section 5.2 in Wegner et al. (2025). Before beginning, download both the code and the replication data. Ensure that the data and code are placed in the same folder.\nFor a clean working environment, we recommend starting a new Matlab session. Alternatively, clear the workspace and console by running:\nNext, add the TCA Toolbox to the Matlab path. Adjust the file paths within the quotation marks as necessary:\nFinally, before proceeding with the analysis, load the replication data into a table:\nThe remainder of this example follows the standard six-step approach.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#defining-the-model",
    "href": "examples/matlab/lp/index.html#defining-the-model",
    "title": "TCA in Local Projections",
    "section": "1. Defining the model",
    "text": "1. Defining the model\nWe estimate structural impulse response functions (IRFs) using local projections (LPs). An LP model can be created using LP, specifying the treatment variable and maximum horizon. Wegner et al. (2025) use the defense spending series from Ramey (2016) as a direct measure of the shock. Thus, the treatment is newsy, and the maximum horizon is set to 20 periods.\nmodel = LP(data, 'newsy', 4, 0:20, 'includeConstant', true);\nThe local projection can then be estimated using fit:\nmodel.fit();",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#obtaining-total-effects",
    "href": "examples/matlab/lp/index.html#obtaining-total-effects",
    "title": "TCA in Local Projections",
    "section": "2. Obtaining total effects",
    "text": "2. Obtaining total effects\nSince newsy is treated as a direct measure of the shock, the effects of a government defense spending shock can be identified recursively by ordering the newsy series first. This recursive identification scheme can be defined using Recursive:\nmethod = Recursive()\nUsing this Recursive identification scheme, structural IRFs can be obtained via IRF:\nirfObj = model.IRF(20, 'identificationMethod', method);\nirfs = irfObj.getIrfArray();",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#defning-the-transmission-matrix-order",
    "href": "examples/matlab/lp/index.html#defning-the-transmission-matrix-order",
    "title": "TCA in Local Projections",
    "section": "3. Defning the transmission matrix / order",
    "text": "3. Defning the transmission matrix / order\nThe transmission matrix is defined as a cell array of char. Wegner et al. (2025) split the total effects into anticipation and implementation effects. They define the anticipation channel as effects that do not pass through actual government defense spending. Thus, it is logical to order gdef (government defense spending) as early as possible in the transmission matrix, but it must not precede the shock variable, newsy. The chosen transmission matrix is:\ntransmissionOrder = {'newsy', 'gdef', 'g', 'y'};\nAlternatively, since columns in data are already correctly ordered, the following simpler definition can be used:\ntransmissionOrder = model.getVariableNames();  % because order is already correct",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#defining-the-transmission-channels",
    "href": "examples/matlab/lp/index.html#defining-the-transmission-channels",
    "title": "TCA in Local Projections",
    "section": "4. Defining the transmission channels",
    "text": "4. Defining the transmission channels\nWegner et al. (2025) define the anticipation channel as the effects of the government defense spending shock that do not pass through government defense spending at any period. This channel can be defined using notThrough as follows:\nanticipationChannel = model.notThrough('gdef', 0:20, transmissionOrder);\nThe implementation channel, representing effects passing through government defense spending in at least one period, is then the complement of the anticipation channel:\nimplementationChannel = ~anticipationChannel;",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#computing-transmission-effects",
    "href": "examples/matlab/lp/index.html#computing-transmission-effects",
    "title": "TCA in Local Projections",
    "section": "5. Computing transmission effects",
    "text": "5. Computing transmission effects\nTransmission effects are computed using transmission for the first 20 periods, considering the first shock, corresponding to defense spending shock. Structural IRFs required for the computations are derived using the Recursive identification method defined earlier.\nanticipationEffects = model.transmission(1, anticipationChannel, transmissionOrder, 20, 'identificationMethod', method);\nimplementationEffects = model.transmission(1, implementationChannel, transmissionOrder, 20, 'identificationMethod', method);",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/matlab/lp/index.html#visualising-transmission-effects",
    "href": "examples/matlab/lp/index.html#visualising-transmission-effects",
    "title": "TCA in Local Projections",
    "section": "6. Visualising transmission effects",
    "text": "6. Visualising transmission effects\nTo visualise transmission effects, first define channel names and collect the effects in a cell array:\nchannelNames = [\"Anticipation Channel\", \"Implementation Channel\"];\ncellChannelEffects = {anticipationEffects, implementationEffects};\nFigures Figure 1 (a) to Figure 1 (c) illustrate decompositions for output, total government spending, and government defense spending, respectively. These can be obtained using:\n% output\nfig = plotDecomposition(4, irfs(:, 1, :), cellChannelEffects, channelNames)\n% Total government spending\nfig = plotDecomposition(3, irfs(:, 1, :), cellChannelEffects, channelNames)\n% Government defense spending\nfig = plotDecomposition(2, irfs(:, 1, :), cellChannelEffects, channelNames)\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Output\n\n\n\n\n\n\n\n\n\n\n\n(b) Total Government Spending\n\n\n\n\n\n\n\n\n\n\n\n(c) Government Defense Spending\n\n\n\n\n\n\n\nFigure 1: Decomposition of the government defense spending shock of Ramey (2016) into the effect through an anticipation and implementation channel.",
    "crumbs": [
      "Home",
      "Matlab",
      "TCA in LPs"
    ]
  },
  {
    "objectID": "examples/julia/svar/index.html",
    "href": "examples/julia/svar/index.html",
    "title": "TCA in SVARs",
    "section": "",
    "text": "This part of the website is still under construction. Our apologies.",
    "crumbs": [
      "Home",
      "Julia",
      "TCA in SVARs"
    ]
  }
]