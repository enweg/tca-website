{"mapY2X":"","makeLeadMatrix":"\n`makeLeadMatrix` Create lead matrix from input data.\n\n`leadMatrix = makeLeadMatrix(Y, p)` returns a matrix where\ncolumns contain 1 to `p` leads of `Y`.\n\n## Arguments\n- `Y` (matrix): Input data matrix (T x k).\n- `p` (integer): Number of leads.\n\n## Returns\n- `leadMatrix` (matrix): Matrix of lead values. First `k`\ncolumns are lead 1, next `k` are lead 2, and so on.\n\n## Notes\n- Missing values due to leading are filled with NaN.","applyNotToB":"\n`applyNotToB` Manipulate B and Omega to ensure var lies on no paths.\n\n`applyNotToB(B, Omega, from, var)` modifies the matrices `B` and `Omega` such that\nthe variable indexed by `var` is absent from all paths. This is achieved by:\n- Zeroing out the edge from the shock (indexed by from) to `var`.\n- Zeroing out all edges from variables ordered before var to `var`.\n\n## Arguments\n- `B` (matrix): Part of the systems form.\n- `Omega` (matrix): Part of the systems form.\n- `from` (integer): The shock index.\n- `var` (integer): The variable index that cannot lie on any paths.\n\n## Notes\n- This function is intended for internal use only.\n\nSee also `applyAndToB`, `makeB`, `makeOmega`, and `makeSystemsForms`.","setRemoveContradictions":"\n`setRemoveContradictions` Set the global flag for removing contradictions in transmission conditions.\n\n`setRemoveContradictions(bool)` controls whether contradictions in transmission\nconditions are removed when calling `setRemoveContradictions`.\n\n## Arguments\n- `bool` (logical): If `true`, contradictions of the form \"x_i & !x_i\" will\nbe removed from transmission conditions. If `false`, contradictions will\nnot be removed.\n\n## Example\n```\n% Enable contradiction removal\nsetRemoveContradictions(true);\n\n% Disable contradiction removal\nsetRemoveContradictions(false);\n```\n\nSee also `removeContradictions`","transmission":"\n`transmission` Compute the transmission effect given a transmission condition.\n\n`effects = transmission(from, arr1, arr2, q, method)` calculates the\ntransmission effect for a given transmission condition `q` using either\nthe `BOmega` method or the `irf` method. If `BOmega` is used, then\ntransmission effects will be calculated using the systems form\n$x = Bx + \\Omega\\varepsilon$\n\n## Arguments\n- `from` (integer): Index of the shock.\n- `arr1` (matrix):\n- If `method = \"BOmega\"`, this must be `B` from the systems form.\n- If `method = \"irf\"`, this must be structural `irfs` (technically\nonly those of the shock that is being investigates (`from`)).\nHas to be a IRF matrix. See `toTransmissionIrfs` for more information.\n- `arr2` (matrix):\n- If `method = \"BOmega\"`, this must be `Omega` from the systems form.\n- If `method = \"irf\"`, this must be `irfsOrtho` (Cholesky IRFs) following\nthe ordering of the transmission matrix.\n- `q` (Q): A transmission condition. See also `Q`.\n- `method` (string): Specifies the calculation method:\n- `\"BOmega\"` uses the systems form.\n- `\"irf\"` uses only IRFs and can thus be used with local projections.\n- `order` (vector, optional): variable ordering as defined by the transmission matrix.\n\n## Returns:\n- `effects` (vector): A vector where entry `i` corresponds to the transmission\neffect on variable `x_i`. If `x_k` is the variable in the transmission\ncondition with the highest index, all entries in the returned vector with\nindex less than `k` are `NaN`, since interpretation of those results is nonsensical.\n\n## Example:\n```\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\neffect = transmission(1, B, Omega, cond, \"BOmega\");\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\neffect = transmission(1, irfs, irfsOrtho, cond, \"irf\");\n```\n\n## Notes:\n- If `method = \"BOmega\"`, the function applies `transmissionBOmega`.\n- If `method = \"irf\"`, the function applies `transmissionIrfs`.\n- If `order` is provided, the returned effects will be a 3D array\nof dimension (nVariables, 1, horizons) where the variables are in the\noriginal ordering (before applying the transmission matrix).\n- If `order` is not provided, the returned effects will be a (nVariable*horizons, 1)\ndimensional vector following the ordering after applying the transmission\nmatrix. This is similar to the matrix obtained via $(I - B)^{-1}\\Omega$\nusing the matrices from the systems form.\n\nSee also `transmissionBOmega`, `transmissionIrfs`, `makeCondition`, `through`, `notThrough`","mapX2YInt":"","makeCondition":"\n`makeCondition` Create a transmission condition from a Boolean string.\n\n`q = makeCondition(s)` constructs a transmission condition $Q(b)$ from a\nBoolean statement given as a string. The Boolean expression should use\nvariables of the systems form `x<num>`, where `<num>` represents a\nvariable index.\n\n## Arguments\n- `s` (string): A Boolean condition string where variables must be\nrepresented using `x<num>`.\n\n## Returns\n- `q` (Q): A transmission condition.\n\n## Example\n```\ns = \"x2 & !x3\";\ncond = makeCondition(s);\n```\n\n## Notes\n- Boolean conditions can include AND (&), NOT (! or ~), OR (|), and\nparentheses.\n- The resulting transmission condition can be used in `transmission` to\ncalculate the transmission effect.\n\nSee also `transmission`, `makeConditionY`","combinations":"\n`combinations` Generate all possible subsets of an array.\n\n`combs = combinations(arr)` returns all possible combinations of elements\nin `arr`, for subset lengths ranging from 1 to K, where K is the length of `arr`.\n\n## Arguments\n- `arr` (vector): Input array of elements.\n\n## Returns\n- `combs` (cell array): A cell array where each element is a subset of `arr`\nwith varying lengths (from 1 to `length(arr)`).\n\n## Example\n```\narr = [1, 2, 3];\ncombs = combinations(arr);\n% Output:\n%   { [1], [2], [3], [1 2], [1 3], [2 3], [1 2 3] }\n```","removeContradictions":"\n`removeContradictions` Remove contradicting terms from a transmission condition.\n\n`q = removeContradictions(q)` removes terms that contain contradictions of\nthe form `x_i & !x_i`, which always evaluate to false and contribute zero\nto the transmission effect. Behaviour of the function can be changed by\nsetting `REMOVECONTRADICTIONS=false` locally.\n\nArguments:\n- `q` (Q): A transmission condition. See also `Q` and `makeCondition`.\n\nReturns:\n- If `REMOVECONTRADICTIONS` is set to `false`, the input `q` is returned unchanged.\n- If `REMOVECONTRADICTIONS` is `true` or not set:\n1. If all terms are contradicting, `Q(\"T\", 0)` is returned, which\nrepresents a transmission effect of zero.\n2. If some terms are non-contradicting, only the non-contradicting terms\nare retained in the output.\n\n## Example\n```\nsetRemoveContradictions(true); % on by default\n\nq = Q('x1', 1);\nq = removeContradictions(q); % Returns q unchanged (no contradictions).\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns Q('T', 0).\n\nq = Q({'x1 & !x1', 'x1 & x2'}, [1, 1]);\nq = removeContradictions(q); % Returns Q('x2 & x1', 1).\n\nsetRemoveContradictions(false);\n\nq = Q('x1 & !x1', 1);\nq = removeContradictions(q); % Returns the original q.\n```\n\n## Notes\n- If `REMOVECONTRADICTIONS` is not explicitly set, contradictions are removed by default.","mapX2Y":"","makeSystemsForm":"\n`makeSystemsForm` Transform an SVARMA dynamic model into the system representation $x = Bx + \\Omega\\varepsilon$.\n\n## Arguments\n- `Phi0` (matrix): The matrix of contemporaneous structural impulse responses.\n- `As` (cell array of matrices): A vector of reduced-form autoregressive (AR)\nmatrices, where the first entry corresponds to the AR matrix for the first lag, etc.\n- `Psis` (cell array of matrices): A vector of reduced-form moving average (MA)\nmatrices, where the first entry corresponds to the MA matrix for the first lag, etc.\n- `order` (vector): The vector of intergers indicating the order of\nvariables, typically determined by the transmission matrix.\n- `maxHorizon` (integer): The maximum time horizon to consider for the systems form,\nwith `0` representing the contemporaneous period.\n\n## Returns\n- `B` (matrix)\n- `Omega` (matrix)\n\nSee also `makeB`, `makeOmega`.","permmatrix":"","transmissionIrfs":"\n`transmissionIrfs` Compute the transmission effect using the IRF method.\n\n`effects = transmissionIrfs(from, irfs, irfsOrtho, varAnd, varNot, multiplier)`\ncalculates the transmission effect using impulse response functions (IRFs).\n\nArguments:\n- `from` (integer): Index of the shock.\n- `irfs` (matrix): Structural impulse responses (only the one of the `from`\nshock is needed). Must be a matrix which can be obtained from `toTransmissionIrfs`.\n- `irfsOrtho` (matrix): Cholesky IRFs that must use the ordering defined\nin the transmission matrix. Must be a matrix which can be obtained from `toTransmissionIrfs`.\n- `varAnd` (vector of integers): Indices of variables that must be included\n(AND conditions). Can be obtained from `getVarNumsAndMultiplier`.\n- `varNot` (vector of integers): Indices of variables that must be excluded\n(NOT conditions). Can be obtained from `getVarNumsAndMultiplier`.\n- `multiplier` (number): Multiplier associated with each term. Can be\nobtained from `getVarNumsAndMultiplier`.\n\n## Returns\n- `effects` (vector): A vector where entry `i` corresponds to the transmission\neffect on variable `x_i`.\n\n## Example\n```\nk = 6;\nh = 3;\ns = \"x1\";\ncond = makeCondition(s);\n\nirfs = randn(k, k, h+1);\nirfsOrtho = randn(k, k, h+1);\n\nirfs = toTransmissionIrfs(irfs);\nirfsOrtho = toTransmissionIrfs(irfsOrtho);\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionIrfs(1, irfs, irfsOrtho, varAnd{1}, varNot{1}, multiplier);\n```\n\n## WARNING\nInternal function. Should not be called by users directly.\n\nSee also `transmission`, `getVarNumsAndMultiplier`, `makeCondition`, `through`, `notThrough`","checkContradiction":"\n`checkContradiction` Check for contradictions of the form `x1 & ~x1` (`x1 & !x1`).\n\n`[hasContradiction, contradictions] = checkContradiction(varAnd, varNot)`\nchecks whether there is a contradiction where a variable appears in both\n`varAnd` and `varNot`, meaning it is simultaneously required and forbidden.\n\n## Arguments\n- `varAnd` (vector or cell array of vectors): AND variable numbers obtained\nfrom `getVarNumsAndMultiplier`.\n- `varNot` (vector or cell array of vectors): NOT variable numbers obtained\nfrom `getVarNumsAndMultiplier`.\n\n## Returns\n- `hasContradiction` (logical): True if any contradictions exist.\n- `contradictions` (vector of logicals): A vector indicating which elements\nyield a contradiction.\n\n## Notes\n- This function is used in `removeContradictions` to eliminate contradicting terms,\nwhich helps speed up the simplification process by reducing the total\nnumber of terms.\n\nSee also `removeContradictions`, `getVarNumsAndMultiplier`","makeLD":"","makeB":"\n`makeB` Construct the matrix B in the system representation $x = Bx + \\Omega\\varepsilon$.\n\n## Arguments\n- `As` (cell array of matrices): Autoregressive coefficient matrices.\n- `Sigma` (matrix): Covariance matrix of the shocks.\n- `order` (vector): Ordering of variables given by the transmission matrix.\n- `maxHorizon` (integer): Maximum IRF horizon.\n\n## Returns\n- `B` (matrix): Part of the sytems representation.\n\nSee also `makeOmega`, `makeSystemsForm`","vec":"","collectTerms":"\n`collectTerms` Collect and sum multipliers for identical Boolean terms.\n\n`qOut = collectTerms(q)` collects all terms $Q(b)$ where the Boolean statement\n$b$ is the same and sums their multipliers. The result is a transmission\ncondition where each term appears only once, but with possibly different\nmultipliers (not restricted to ±1).\n\n## Arguments\n- `q` (Q): A transmission condition. See also `Q`.\n\n## Returns\n- `qOut` (Q): A new transmission condition where identical terms have been\ncombined with summed multipliers.\n\n## Example\n```\nq = Q({\"x1\", \"x1\"}, [1, 1]);\ncollectTerms(q)\n% Output: Q({\"x1\"}, 2)\n\nq = Q({\"x1\", \"T\", \"x1\"}, [1, 1, -1]);\ncollectTerms(q)\n% Output: Q({\"T\"}, 1)\n```","through":"\n`through` Construct a transmission condition enforcing paths through specific variables.\n\n`q = through(idx, horizons, order)` creates a transmission condition `Q`\nwhere paths must pass through the variables specified in `idx`.\nThe variable indices refer to their positions in the original dynamic system\n(e.g., in the SVARMA model), before applying the transmission matrix.\n\n## Arguments\n\n**For a single variable:**\n\n- `idx` (integer): Index of the variable that paths must go through,\nusing its original index in the dynamic system (before transmission ordering).\n- `horizons` (vector of integers): Time horizons at which the paths must\npass through the variable.\n- `order` (vector of integers): Variable ordering determined by the\ntransmission matrix.\n\n**For multiple variables:**\n\n- `idx` (vector of integers): Indices of the variables that paths must\ngo through, using their original indices in the dynamic system.\n- `horizons` (cell array of vectors or vector of integer): If a single\nvector of integers is provided, then it will be applied to each `idx`.\nAlternatively, a cell array of integer vectors can be provided in which\ncase each element in the cell array applies to the respective element\nin `idx`.\n- `order` (vector of integers): Variable ordering determined by the\ntransmission matrix.\n\n## Returns\n- `q` (Q): A transmission condition.\n\n## Notes\n- The resulting transmission condition can be used in `transmission` to\ncompute the transmission effect.\n\n## Example\n```\n% Contemporaneous channel (Section 5.1 in Wegner)\ncontemporaneous_channel = through(1, [0], 1:4);\n\n% Effect through the federal funds rate in the first two periods\nq = through(1, [0, 1], 1:4);\n\n% Effect through both the federal funds rate and output gap\nq = through([1, 2], {[0, 1], [0, 1]}, 1:4);\n\n% Adjusting for a re-ordered system where the output gap comes first\nq = through([1, 2], {[0, 1], [0, 1]}, [2, 1, 3, 4]);\n```\n\nSee also `notThrough`, `transmission`","mapY2XInt":"","makeLagMatrix":"\n`makeLagMatrix` Create lag matrix from input data.\n\n`lagMatrix = makeLagMatrix(Y, p)` returns a matrix where\ncolumns contain 1 to `p` lags of `Y`.\n\n## Arguments\n- `Y` (matrix): Input data matrix (T x k).\n- `p` (integer): Number of lags.\n\n## Returns\n- `lagMatrix` (matrix): Matrix of lagged values. First `k`\ncolumns are lag 1, next `k` are lag 2, and so on.\n\n## Notes\n- Missing values due to lagging are filled with NaN.","makeConditionY":"\n`makeConditionY` Create a transmission condition from a Boolean string using dyanmic form variables.\n\n`q = makeConditionY(strY, order)` constructs a transmission condition $Q(b)$\nfrom a Boolean statement specified in terms of dynamic system variables\n(i.e., `y_{i,t}` notation).\n\n## Arguments\n- `strY` (string): A Boolean condition string where variables are represented\nas `y_{i,t}`, with `i` as the variable index and `t >= 0` as the time period.\n`t=0` corresponds to the contemporaneous horizon.\n- `order` (vector of integers): The variable ordering defined by the transmission matrix.\n\n## Returns\n- `q` (Q): A transmission condition object.\n\n## Example\n```\ns_y = \"y_{1,0} & !y_{1,1}\";\norder = [3,1,2];\ncond = makeConditionY(s_y, order);\n```\n\n## Notes\n- Boolean conditions can include AND (&), NOT (! or ~), OR (|), and\nparentheses.\n- The resulting transmission condition can be used in `transmission` to\ncalculate the transmission effect.\n\nSee also `transmission`, `makeCondition`","findVariableIndex":"\n`findVariableIndex` Find column index of a variable in a table.\n\n`idx = findVariableIndex(data, variable)` returns the index\nof `variable` in the table `data`.\n\n## Arguments\n- `data` (table): Dataset containing variable columns.\n- `variable` (char or integer): Name or index of the variable.\n\n## Returns\n- `idx` (integer): Column index of the variable.","slideIn":"\nEnsure A can slide into B","logdet":"\n`logdet` Compute the log determinant of a covariance matrix.\n\n`val = logdet(Sigma)` returns the log determinant of the\nsymmetric positive definite matrix `Sigma`.\n\n## Arguments\n- `Sigma` (matrix): Symmetric positive definite matrix.\n\n## Returns\n- `val` (number): Log determinant of `Sigma`.","calculateQAndOnly":"\n`calculateQAndOnly` Compute the transmission effect of a condition with only ANDs.\n\n`result = calculateQAndOnly(from, irfs, irfsOrtho, vars, multiplier)`\ncalculates the transmission effect of a transmission condition/query\nthat involves only AND operations.\n\n## Arguments\n- `from` (integer): Index of the shock.\n- `irfs` (matrix): IRFs in transmission form. See also `toTransmissionIrfs`.\n- `irfsOrtho` (matrix): Orthogonalized / Cholesky IRFs in transmission form.\nSee also `toTransmissionIrfs`.\n- `vars` (vector of integers): Indices of variables involved in the condition.\n- `multiplier` (number): Multiplier.\n\n## Returns\n- `result` (vector): A vector where entry `i` corresponds to the transmission\neffect on variable `x_i`.\n\n## Notes\n- This function is intended for internal use only.\n\nSee also `toTransmissionIrfs`","plotDecomposition":"","plotCompareDecomposition":"","getVarNumsAndMultiplier":"\n`getVarNumsAndMultiplier` Extract AND and NOT expressions from a transmission condition.\n\n`[andNums, andNotNums, multiplier] = getVarNumsAndMultiplier(q)` extracts\nthe AND and NOT expressions from a transmission condition and returns\nthe corresponding variable numbers. It also returns the multiplier for\neach term.\n\nA valid transmission condition consists of terms that involve only AND\nand NOT expressions. For each term, the AND and NOT expressions are\ncollected, and vectors of the respective variable numbers are returned.\n\n## Arguments\n- `q` (Q): A transmission condition. See also `Q`.\n\n## Returns\n- `andNums` (cell array of vectors): Each cell contains a vector of variable\nnumbers included via AND in the term.\n- `andNotNums` (cell array of vectors): Each cell contains a vector of\nvariable numbers included via NOT in the term.\n- `multiplier` (vector of numbers): Contains the multiplier for each term.\n\n##Example\n```\nq = Q({\"x1\", \"!x2\", \"x1 & !x2\"}, [1, 2, 3]);\n[andNums, andNotNums, multiplier] = getVarNumsAndMultiplier(q);\n% Output:\n% andNums = { [1], [], [1] }\n% andNotNums = { [], [2], [2] }\n% multiplier = [1, 2, 3]\n```\n\nSee also `Q`","applyAndToB":"\n`applyAndToB` Manipulate `B` and `Omega` to ensure var lies on all paths.\n\n`applyAndToB(B, Omega, from, var)` modifies the matrices `B` and `Omega` such that\nthe variable indexed by `var` is present on all paths. This is achieved by:\n- Zeroing out all edges going directly from the shock (indexed by from)\nto any variables ordered after `var`.\n- Zeroing out any edges going from variables ordered before `var` to any\nvariables ordered after `var`.\n\n## Arguments\n- `B` (matrix): Part of the system's representation.\n- `Omega` (matrix): Part of the system's representation.\n- `from` (integer): The shock index.\n- `var` (integer): The variable index that must lie on all paths.\n\n## Notes\n- This function is intended for internal use only.\n\nSee also `applyNotToB`, `makeB`, `makeOmega`, and `makeSystemsForm`.","toTransmissionIrfs":"\n`toTransmissionIrfs` Transform a standard 3D IRF array into a 2D IRF matrix.\n\n`irfs = toTransmissionIrfs(irfs)` converts an impulse response function (IRF)\narray of dimensions `(n_variables × n_shocks × n_horizons)` into a 2D matrix.\nThe first horizon in the input corresponds to horizon 0.\n\nArguments:\n- `irfs` (3D array): An IRF array of size `(n_variables × n_shocks × n_horizons)`,\nwhere:\n- `n_variables` is the number of variables,\n- `n_shocks` is the number of shocks,\n- `n_horizons` is the number of forecast horizons.\n\n## Returns\n- `irfs` (2D matrix): A transformed IRF matrix of size\n`(n_variables * n_horizons) × (n_variables * n_horizons)`. This is\nequivalent to computing $(I - B)^{-1}Q$ using the systems form.\n\n## Example\n```\nirfs3D = rand(4, 2, 10); % Example 3D IRF array with 4 variables, 2 shocks, and 10 horizons\nirfs2D = toTransmissionIrfs(irfs3D);\n```\n\n## Notes\n- The first `n_shocks` column of the returned matrix are simply the standard\nslices of the IRF 3D-array stacked vertically. The next `n_shocks` columns\nfollow the same principle, but with the first `n_variables` columns being\nzero because the shocks are time t shocks which cannot affect time t-1\nvariables.","transmissionBOmega":"\n`transmissionBOmega` Compute the transmission effect using the `BOmega` method.\n\n`effects = transmissionBOmega(from, B, Omega, varAnd, varNot, multiplier)`\ncalculates the transmission effect based on the systems form $x = Bx + \\Omega\\varepsilon$.\n\n## Arguments\n- `from` (integer): Index of the shock.\n- `B` (matrix): See the systems form.\n- `Omega` (matrix): See the systems form.\n- `varAnd` (cell array of vectors): Each cell contains a vector of variable\nindices that must be included (AND conditions). Can be obtained using\n`getVarNumsAndMultiplier`.\n- `varNot` (cell array of vectors): Each cell contains a vector of variable\nindices that must be excluded (NOT conditions). Can be obtained using\n`getVarNumsAndMultiplier`.\n- `multiplier` (vector of numbers): Multipliers associated with each term.\nCan be obtained using `getVarNumsAndMultiplier`.\n\n## Returns\n- `effects` (vector): A vector where entry `i` corresponds to the transmission\neffect on variable `x_i`.\n\n## Example\n```\nk = 6;\nh = 3;\ns = \"(x1 | x2) & !x3\";\ncond = makeCondition(s);\n\nB = randn(k*(h+1), k*(h+1));\nOmega = randn(k*(h+1), k*(h+1));\n\n[varAnd, varNot, multiplier] = getVarNumsAndMultiplier(cond);\neffect = transmissionBOmega(1, B, Omega, varAnd, varNot, multiplier);\n```\n\n##  WARNING\nInternal function. Should not be called by users directly.\n\nSee also `transmission`, `applyAndToB`, `applyNotToB`, `getVarNumsAndMultiplier`","makeOmega":"\n`makeOmega` Construct the Omega matrix in the system representation $x = Bx + \\Omega\\varepsilon$.\n\n## Arguments\n- `Phi0` (matrix): Impact matrix for the shocks.\n- `Psis` (cell array of matrices): MA terms for the dynamic model.\n- `order` (vector): Ordering of variables.\n- `maxHorizon` (integer): Maximum IRF horizon.\n\n## Returns\n- `Omega` (matrix): Part of the systems form.\n\nSee also `makeB`, `makeSystemsForm`","testTCA":"","notThrough":"\n`notThrough` Construct a transmission condition excluding specific variables from the channel.\n\n`q = notThrough(idx, horizons, order)` creates a transmission condition `Q`\nwhere paths cannot pass through specified variables at given time horizons.\nThe variable indices refer to their positions in the original dynamic system\n(e.g., in the SVARMA model), before applying the transmission matrix.\n\n## Arguments\n\n**For a single variable:**\n\n- `idx` (integer): Index of the variable that paths cannot go through,\nusing its original index in the dynamic system (before transmission ordering).\n- `horizons` (vector of integers): Time horizons at which the paths cannot\npass through the variable.\n- `order` (vector of integers): Variable ordering determined by the\ntransmission matrix.\n\n**For multiple variables:**\n\n- `idx` (vector of integers): Indices of the variables that paths cannot\ngo through, using their original indices in the dynamic system.\n- `horizons` (cell array of vectors or vector of integer): If a single\nvector of integers is provided, then it will be applied to each `idx`.\nAlternatively, a cell array of integer vectors can be provided in which\ncase each element in the cell array applies to the respective element\nin `idx`.\n- `order` (vector of integers): Variable ordering determined by the\ntransmission matrix.\n\n## Returns\n- `q` (Q): A transmission condition.\n\n## Notes\n- The resulting transmission condition can be used in `transmission` to\ncompute the transmission effect.\n\n## Example\n```\n% Non-contemporaneous monetary policy channel (Section 5.1 in Wegner etal 2024)\nq = notThrough(1, [0], 1:4);\n\n% Anticipation channel of government defense spending (Section 5.2 in Wegner etal 2024)\nq = notThrough(2, 0:20, 1:4);\n```\n\nSee also `through`, `transmission`","stringAnd":""}