{"Q":"\n`Q` Represents a transmission condition.\n\nThe `Q` class is used to define transmission conditions based on Boolean\nstatements. A transmission condition is denoted as $Q(b)$, where $b$ is a\nBoolean statement involving variables `x<num>`, such as `x1`, `x2`, etc.\nBoolean statements should only contain AND (&) and NOT (!) operations.\n\n## Properties\n- `vars` (cell array of strings): Contains the Boolean variable expressions.\n- `multiplier` (vector of numbers): Multipliers associated with each term.\n\n## Methods\n- `Q`: Constructor to create a transmission condition.\n- `and`: Overloads `&` (logical AND) for `Q` objects.\n- `or`: Overloads `|` (logical OR) for `Q` objects.\n- `not`: Overloads `~` (logical NOT) for `Q` objects.\n- `disp`: Custom display function.\n- `display`: Calls `disp` for better formatting.\n\n## Usage\n```\n% Define variables as transmission conditions\nx = arrayfun(@(i) Q(sprintf('x%d', i)), 1:10);\nq = (x(1) | x(2)) & ~x(3);\n\n% Alternatively, define variables separately\nx1 = Q('x1');\nx2 = Q('x2');\nx3 = Q('x3');\nq = (x1 | x2) & ~x3;\n\n% Creating Q objects with multipliers\nq = Q('x1 & !x3', 1);\nq = Q({'x1', 'x2', 'x1 & x2'}, [1, 1, -1]);\n```\n\n## Notes\n- The recommended constructor is `Q(i)`, where `i` is an integer representing a variable index.\n- Other constructors are for internal use and may lead to incorrect results if misused.\n- DO NOT use OR (`|`) inside the string input for `Q`, as it is not supported.","SVAR":"\n`SVAR` Structural Vector Autoregressive (SVAR) model.\n\nAn SVAR of lag order `p` is specified as:\n\n```\nA0 y_t = C e_t + A1 y_{t-1} + ... + Ap y_{t-p} + \\varepsilon_t\n```\n\nwhere:\n- `e_t` is a vector of deterministic components (constant, trends).\n- `C`, `A0`, `Ai` are conformable matrices.\n- `\\varepsilon_t` are structural shocks.\n\nAssuming `A0` is invertible, the model can be rewritten as a\nreduced-form VAR:\n\n```\ny_t'A0' = z_t' A_+' + u_t'\n```\n\nwhere:\n- `z_t = [e_t; y_{t-1}; ...; y_{t-p}]`\n- `A_+ = [C, A_1, ..., A_p]`\n\nAssuming `A0` is invertible, the reduced-form VAR can be obtained as\n\n```\ny_t' = z_t' A_+'(A_0')^{-1} + u_t'(A_0')^{-1}\n```\nwhich can be represented using a `VAR` object.\n\n## Properties\n- `A0` (matrix): Contemporaneous coefficient matrix.\n- `APlus` (matrix): Stacked coefficient matrix `[C A1 ... Ap]`.\n- `p` (integer): Lag order of the (S)VAR model.\n- `trendExponents` (vector): Time trend exponents (e.g., `[0, 1]`).\n- `VARModel` (VAR): Reduced-form VAR representation.\n\nSee also `VAR`","LP":"\n`LP` Local Projection (LP) model for estimating IRFs.\n\nLocal Projection (LP) model for estimating impulse response functions (IRFs)\nin a flexible and semi-parametric manner.\n\nEach LP regression estimates the dynamic response of an outcome variable at\nfuture horizon `h` to a one-period change in a treatment variable at time `t`,\ncontrolling for contemporaneous and lagged covariates.\n\nThe regression model is specified as:\n\n```\nw_{i,t+h} = \\mu_{i,h} + \\theta_{i,h} x_t + \\gamma_{i,h}' r_t +\n\\sum_{l=1}^p \\delta_{i,h,l} w_{t-l} + \\xi_{i,h,t}\n```\n\nwhere `w_t = (r_t', x_t, q_t')` and:\n- `x_t` is the treatment variable\n- `r_t` contains contemporaneous controls (all variables before `x_t`)\n- `p` is the number of lags included\n- `\\theta_{i,h}` is the relative IRF of `x_t` on the `i`-th variable at\nhorizon `h`.\n\nThe treatment variable may be endogenous. Structural interpretation of IRFs\ncan be achieved using valid instrumentsâ€”see `ExternalInstrument` for one such\nmethod. If the treatment satisfies a conditional ignorability assumption\n(a recursive assumption in macro), then the coefficient has a structural\ninterpretation even without the use of instruments. For this to hold,\n`x_t - E(x_t|r_t, w_{t-1}, ..., w_{t-p})` must be equal to the structural shock.\n\n## Properties\n- `data` (table or matrix): Input time series dataset.\n- `treatment` (char or integer): Treatment variable.\n- `p` (integer): Number of lags.\n- `horizons` (vector): Forecast horizons for projections.\n- `includeConstant` (logical): Whether to include an intercept.\n- `B` (array): Coefficient estimates per horizon.\n- `Y` (array): Dependent variables per horizon.\n- `X` (matrix): Common regressor matrix.\n- `U` (array): Residuals per horizon.\n- `Yhat` (array): Fitted values per horizon.\n","ExternalInstrument":"\n`ExternalInstrument` Identify IRFs using external instruments.\n\nThis class identifies structural IRFs from (S)VARs using the\nexternal instrument approach proposed by Stock and Watson (2018).\n\n## Notes\n- IRFs are computed relative to the reaction of the\n`treatment` variable at `normalisingHorizon`.\n- `instruments` must be a matrix or table spanning the same\nperiod as the model data.\n- Defaults:\n- `normalisingHorizon = 0`\n\n## Reference\n- Stock, J. H., & Watson, M. W. (2018).\n\"Identification and Estimation of Dynamic Causal Effects in\nMacroeconomics Using External Instruments.\"\n*The Economic Journal*, 128(610), 917-948.\n[https://doi.org/10.1111/ecoj.12593]\n\nSee also `IdentificationMethod`, `Recursive`, `InternalInstrument`","DSGE":"\n`DSGE` Dynamic Stochastic General Equilibrium (DSGE) model.\n\nThis class specifies a DSGE model structure. The model must\nbe previously computed using Dynare. It provides access to\nthe Dynare output structures.\n\n## Properties\n- `M_` (struct): Model structure returned by Dynare.\n- `options_` (struct): Options structure from Dynare.\n- `oo_` (struct): Output structure with results from Dynare.\n\n## Notes\n- The model must have already been solved in Dynare.\n- This class serves as a wrapper to interface with Dynare output.","Recursive":"\n`Recursive` Identify reduced-form models using recursivity.\n\nThis class implements identification under a recursive\n(Cholesky) structure, assuming conditional ignorability.\n\n## Notes\n- For SVARs, this corresponds to Cholesky identification.\n- For LPs, it assumes conditioning on prior ordered variables.\n- Commonly used in macroeconomics when contemporaneous shocks\nare assumed to have a lower triangular impact.\n\nSee also `IdentificationMethod`, `SVAR`, `LP`","VAR":"\n`VAR` Vector Autoregressive (VAR) model in matrix form.\n\nA VAR of lag order `p` is specified as:\n\n```\ny_t = C e_t + B_1 y_{t-1} + ... + B_p y_{t-p} + u_t\n```\n\nwhere:\n- `e_t` is a vector of deterministic components (constant, trends, etc).\n- `C, B_i` are conformable coefficient matrices.\n- `u_t` is vector white noise.\n\nCompact form:\n\n```\ny_t' = z_t' B_+' + u_t'\n```\n\nwith:\n- `z_t = [e_t; y_{t-1}; ...; y_{t-p}]`\n- `B_+ = [C, B_1, ..., B_p]`\n\nStacking from `t = p+1` to `T`:\n\n```\nY = X B_+' + U\n```\n\n## Properties\n- `B` (matrix): Coefficient matrix `[C B_1 ... B_p].\n- `SigmaU` (matrix): Covariance matrix of the error term.\n- `p` (integer): Lag order of the VAR.\n- `trendExponents` (vector): Time trend exponents (e.g., `[0, 1]`\nimplies constant and linear trend).\n- `inputData` (table or matrix): Original data used to estimate\nthe VAR.\n- `Y` (matrix): Left-hand side outcomes `y_t`, size `(T-p) x k`.\n- `X` (matrix): Right-hand side regressors `z_t`, size `(T-p) x (k*p + m)`\nwhere `m` is the number of deterministic domponents.\n- `U` (matrix): Residuals `u_t`, size `(T-p) x k`.\n- `Yhat` (matrix): Fitted values `X * B_+'`, size `(T-p) x k`.","IRFContainer":"\n`IRFContainer` Container for storing impulse response functions.\n\nThis class holds IRFs, variable names, the originating model,\nand the identification method used (if any).\n\n## Properties\n- `irfs` (3D array): IRFs with dimensions:\n- First: Response variable.\n- Second: Shock.\n- Third: Horizon.\n- `varnames` (cell array): Names of response variables.\n- `model` (Model): Model used to compute the IRFs.\n- `identificationMethod` (IdentificationMethod):\n- Identification method if the model is reduced form.","IdentificationMethod":"\n`IdentificationMethod` Abstract class for structural identification.\n\nThis abstract class specifies the interface for identification\nmethods that recover structural models and IRFs from reduced-form\nmodels.\n\n## Required Methods\n1. `irfs = identifyIrfs(obj, model, maxHorizon)`\n- Identifies IRFs from the reduced form `model`.\n- Returns a 3D array with dimensions:\n(response variable, shock, horizon).\n- IRFs should be computed up to `maxHorizon`.\n\n2. `[varargout] = identify(obj, model)`\n- Identifies the structural form of a reduced form `model`.\n- For SVARs from VARs:\n- `varargout{1}` = A0 (contemporaneous matrix)\n- `varargout{2}` = APlus (lag polynomial matrix)\n- For LPs:\n- `varargout{1}` = coefficient estimates per horizon.\n\n## Notes\n- See the `Recursive` class for an example implementation.\n\nSee also `Recursive`, `SVAR`, `LP`","Model":"\nAbstract Model Class","InternalInstrument":"\n`InternalInstrument` Identify IRFs using internal instruments.\n\nThis class identifies impulse responses in (S)VARs using the\ninternal instruments method proposed by Plagborg-Moller and\nWolf (2021).\n\n## Notes\n- IRFs are computed from Cholesky-orthogonalized shocks with\nrespect to the selected `instrument`.\n- Shocks are normalized by the response of the\n`normalisingVariable` at `normalisingHorizon`.\n- The `instrument` can be specified as an integer (index) or\ncharacter (variable name).\n- Defaults:\n- `instrument = 1` (first variable)\n- `normalisingHorizon = 0`\n\n## Reference\n- Plagborg-Moller, M., & Wolf, C. K. (2021).\n\"Local Projections and VARs Estimate the Same Impulse Responses.\"\n*Econometrica*, 89(2), 955-980.\n[https://doi.org/10.3982/ecta17813]\n\nSee also `IdentificationMethod`, `Recursive`"}