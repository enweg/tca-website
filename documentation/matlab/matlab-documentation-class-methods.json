{"Q":{"Q":"\n`Q` Construct a transmission condition.\n\n`obj = Q(vars)` constructs a transmission condition with the given variable.\n`obj = Q(vars, multiplier)` constructs a transmission condition with\na specified multiplier.\n\n## Arguments\n- `vars` (string, cell array of strings, or integer): The variable(s)\nin the Boolean condition. Must be formatted as `x<num>`.\n- `multiplier` (number or vector): Multiplier(s) associated with\neach term.\n\n## Returns\n- `obj` (Q): A transmission condition.\n\n## Example\n```\nq = Q('x1');            % Single variable\nq = Q({'x1', 'x2'}, [1, -1]);  % Multiple variables with multipliers\n```\n\n## Notes\n- The recommended way to define a variable is using `Q(i)`, where `i`\nis an integer representing a variable index.\n- Users should not directly specify OR (`|`) inside the variable strings.","display":"","or":"\n`|` Combine two transmission conditions using a logical OR.\n\n`result = q1 | q2` performs a logical OR operation between two\ntransmission conditions, returning a new `Q` object.\n\n## Arguments\n- `obj1` (Q): First transmission condition.\n- `obj2` (Q): Second transmission condition.\n\n## Returns\n- `result` (Q): The combined transmission condition.\n\n## Example\n```\nq1 = Q(1);\nq2 = Q(2);\nq = q1 | q2;\n```\n\nSee also `and` (`&`), `not` (`~`)","not":"\n`~` Negate a boolean condition using the logican NOT.\n\n`result = ~q` negates a transmission condition, creating a condition\nwhere the given Boolean statement does not hold.\n\n## Arguments\n- `obj` (Q): A transmission condition to negate.\n\n## Returns\n- `result` (Q): The negated transmission condition.\n\n## Example\n```\nq1 = Q(1);\nq = ~q1;\n```\n\n## Notes\n- If the condition consists of a single variable, it is simply negated.\n- If the condition is more complex, an auxiliary `\"T\"` (true) condition\nis used and the returned condition is equivalent to $Q(T) - Q(b)$\nwhere $b$ is the origional Boolean condition.\n\nSee also `and` (`&`), `or` (`|`)","and":"\n`&` combine two transmission conditions using logical AND.\n\n`result = q1 & q2` performs a logical AND operation between two\ntransmission conditions, returning a new `Q` object. This is the\nsame as $Q(b \\land b')$ where $b$ and $b'$ are the Boolean conditions for\n`q1` and `q2` respectively.\n\n## Arguments\n- `obj1` (Q): First transmission condition.\n- `obj2`(Q): Second transmission condition.\n\n## Returns\n- `result`(Q): The combined transmission condition.\n\nExample:\n```\nq1 = Q(1);\nq2 = Q(2);\nq = q1 & q2;  % Returns Q(\"x2 & x1\")\n```\n\nSee also `or` (`|`), `not` (`~`)","disp":"\n`disp` Display a transmission condition in either systems form or dynamic form.\n\n`disp(q)` displays the transmission condition using the systems form notation.\n\n`disp(q, order)` displays the transmission condition using the dynamic form\nnotation, where `order` is the variable ordering defined by the transmission\nmatrix.\n\n## Arguments\n- `q` (Q): A transmission condition.\n- `order` (vector of integers, optional): The variable ordering defined\nby the transmission matrix. If provided, the condition is displayed\nusing the dynamic form notation.\n\n## Example\n```\nq = makeCondition(\"x1 | x2\");\n\ndisp(q); % Displays condition in systems form.\n\norder = [3, 1, 2];\ndisp(q, order); % Displays condition in dynamic form.\n```"},"SVAR":{"nobs":"","SVAR":"\n`SVAR` Construct a Structural VAR (SVAR) model object.\n\n`obj = SVAR(data, p, varargin)` creates an SVAR object with lag\nlength `p`, based on the provided dataset and structural\nspecification.\n\n## Arguments\n- `data` (table or matrix): Input dataset for the SVAR model.\n- `p` (integer): Lag order of the SVAR.\n- `varargin`: Name-value pairs for optional arguments:\n- `trendExponents` (vector): Exponents for deterministic\ntrends. Defaults to `[0]` (constant term).\n- `A0` (matrix): Contemporaneous coefficient matrix.\n- `APlus` (matrix): Stacked coefficient matrix `[A1, ..., Ap]`.\n- `VARModel` (VAR): Precomputed reduced-form VAR model.\n\n## Returns\n- `obj` (SVAR): Constructed SVAR model object.\n\n## Notes\n- If `VARModel`, `A0`, `APlus` are not provided, they are\nestimated from the data.\n\nSee also `VAR`","getVariableNames":"","fitted":"\n`fitted` Return the fitted values of the SVAR model.\n\n`Yhat = fitted(obj)` returns the fitted values from the\nreduced-form VAR model associated with the SVAR.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `Yhat` (matrix): Matrix of fitted values `(T-p) x k`.","IRF_":"\n`IRF_` Compute impulse response functions for an SVAR model.\n\n`irfs = IRF_(A0, APlus, p, maxHorizon)` computes the structural\nimpulse response functions up to `maxHorizon` given the\ncontemporaneous matrix `A0` and stacked lag matrices `APlus`.\n\n## Arguments\n- `A0` (matrix): Contemporaneous coefficient matrix.\n- `APlus` (matrix): Stacked lag coefficient matrix `[A1 ... Ap]`,\nexcluding deterministic components.\n- `p` (integer): Lag order of the SVAR.\n- `maxHorizon` (integer): Maximum horizon for IRFs.\n\n## Returns\n- `irfs` (3D array): Impulse response functions of size\n`(k x k x (maxHorizon+1))`, where:\n- First dimension: Endogenous variables (responses).\n- Second dimension: Structural shocks.\n- Third dimension: Horizon.\n\n## Notes\n- `APlus` must not include coefficients on deterministic terms.\n\nSee also `VAR.IRF_`","transmission":"\n`transmission` Compute transmission effects in an SVAR model.\n\n`effects = transmission(obj, shock, condition, order, maxHorizon, varargin)`\ncomputes the transmission effects of a `shock` under a `condition`,\nusing the transmission matrix defined by `order`, up to `maxHorizon`.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n- `shock` (integer): Index of the shock variable.\n- `condition` (Q): Transmission condition object.\n- `order` (cell array of char): Variable transmission ordering.\n- `maxHorizon` (integer): Maximum horizon.\n- `varargin`: Name-value pairs for options:\n- `identificationMethod` (IdentificationMethod, optional):\nMethod to identify the SVAR if not yet fitted.\n\n## Returns\n- `effects` (3D array): Transmission effects over horizons, where:\n- First dimension: Endogenous variables (responses).\n- Second dimension: Shocks (only the selected shock).\n- Third dimension: Horizon.\n\n## Notes\n- If `identificationMethod` is provided, the model is fitted first.\n\nSee also `SVAR.through`, `SVAR.notThrough`, `VAR.transmission`","isStructural":"","sic":"\n`sic` Compute Schwarz Information Criterion (SIC) for SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `val` (number): SIC value.\n\nSee also `aic`, `hqc`, `bic`, `VAR.sic`","getIndependent":"","makeCompanionMatrix":"\n`makeCompanionMatrix` Form the companion matrix of the SVAR model.\n\n`C = makeCompanionMatrix(obj)` returns the companion matrix\nassociated with the reduced-form VAR model of the SVAR.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `C` (matrix): Companion matrix.","getInputData":"","isFitted":"","fit":"\n`fit` Estimate the SVAR model using an identification method.\n\n`fit(obj, identificationMethod)` first fits the reduced-form\nVAR model using ordinary least squares (OLS), then identifies\nthe structural matrices using the provided identification method.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n- `identificationMethod` (object): An object of type\n`IdentificationMethod` used to identify `A0` and `APlus`.\n\n## Notes\n- `identificationMethod` must implement an `identify` method\ntaking a VAR object and returning `A0` and `APlus`.\n\nSee also `VAR.fit`, `IdentificationMethod`","bic":"\n`bic` Compute Bayesian Information Criterion (BIC) for SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `val` (number): BIC value.\n\nSee also `aic`, `hqc`, `sic`, `VAR.bic`","simulate":"\n`simulate` Simulate a Structural VAR (SVAR) process.\n\n`Y = simulate(shocksOrT, A0, APlus, varargin)` simulates an SVAR\nmodel using either provided structural shocks or by generating\nrandom shocks.\n\n## Arguments\n- `shocksOrT` (matrix or integer): Either a `(k x T)` matrix of\nstructural shocks or an integer specifying the number of\nperiods to simulate.\n- `A0` (matrix): Contemporaneous coefficient matrix.\n- `APlus` (matrix): Coefficient matrix `[C A1 ... Ap]`.\n- `varargin`: Name-value pairs for options:\n- `trendExponents` (vector): Exponents for deterministic\ntrends. Defaults to `[0]` (constant).\n- `initial` (vector): Initial lag values, default is zeros.\n\n## Returns\n- `Y` (matrix): Simulated data matrix, size `(T x k)`.\n\n## Notes\n- If `shocksOrT` is a scalar, shocks are drawn from a standard\nnormal distribution with identity covariance.\n\nSee also `VAR.simulate`","coeffs":"\n`coeffs` Return the SVAR coefficient matrices.\n\n`[A0, APlus] = coeffs(obj, excludeDeterministic)` returns the\ncontemporaneous matrix `A0` and the lag coefficient matrix\n`APlus` for the SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n- `excludeDeterministic` (logical, optional): If true,\nexclude coefficients on deterministic components from `APlus`.\nDefaults to false.\n\n## Returns\n- `A0` (matrix): Contemporaneous coefficient matrix.\n- `APlus` (matrix): Coefficient matrix. If\n`excludeDeterministic` is true, returns only lag matrices\n`[A1 ... Ap]`. Otherwise `APlus = [C A_1 ... A_p]` is returned.","residuals":"\n`residuals` Return the residuals of the SVAR model.\n\n`U = residuals(obj)` returns the residuals from the\nreduced-form VAR model associated with the SVAR.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `U` (matrix): Matrix of residuals `(T-p) x k`.","fitAndSelect":"\n`fitAndSelect` Estimate and select the best SVAR model by IC.\n\n`[modelBest, icTable] = fitAndSelect(obj, identificationMethod, icFunction)`\nfits the SVAR model for different lag lengths and selects the one\nminimizing the information criterion. The maximuml lag length\nis determined by the lag length of the given model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n- `identificationMethod` (`IdentificationMethod`): Identification\nmethod for SVAR.\n- `icFunction` (function handle, optional): Information criterion\nfunction to minimize. Defaults to `aic`.\n\n## Returns\n- `modelBest` (SVAR): Best fitting SVAR model.\n- `icTable` (table): Table of lag lengths and IC values.\n\n## Notes\n- Maximum lag length is given by the lag length of the provided model.\n\nSee also `SVAr.fit`, `aic`, `bic`, `hqc`, `sic`, `VAR.fitAndSelect`","getDependent":"","spectralRadius":"\n`spectralRadius` Compute the spectral radius of the SVAR model.\n\n`rho = spectralRadius(obj)` returns the spectral radius of the\ncompanion matrix associated with the SVAR.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `rho` (number): Spectral radius of the companion matrix.","aic":"\n`aic` Compute Akaike Information Criterion (AIC) for SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `val` (number): AIC value.\n\nSee also `bic`, `hqc`, `sic`, `VAR.aic`","isStable":"\n`isStable` Check if the SVAR model is stable.\n\n`flag = isStable(obj)` returns true if the spectral radius of\nthe companion matrix is less than 1.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `flag` (logical): True if the model is stable, false otherwise.","hqc":"\n`hqc` Compute Hannan-Quinn Criterion (HQC) for SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n\n## Returns\n- `val` (number): HQC value.\n\nSee also `aic`, `bic`, `sic`, `VAR.hqc`","IRF":"\n`IRF` Compute structural impulse response functions for SVAR.\n\n`irfObj = IRF(obj, maxHorizon)` computes structural IRFs up to\nhorizon `maxHorizon` from an estimated SVAR model.\n\n## Arguments\n- `obj` (SVAR): SVAR model object.\n- `maxHorizon` (integer): Maximum horizon for IRFs.\n\n## Returns\n- `irfObj` (IRFContainer): Container with computed IRFs.\n\n## Notes\n- The IRFs have dimensions `(k x k x (maxHorizon+1))`:\n- First dimension: Responding variables.\n- Second dimension: Structural shocks.\n- Third dimension: Horizons.\n\nSee also `VAR.IRF`, ~IRFContainer`"},"LP":{"nobs":"","getVariableNames":"","createXY_":"\n`createXY_` Construct regressor matrix `X` and response array `Y`.\n\n`[X, Y] = createXY_(data, treatment, p, horizons, varargin)`\nprepares the design matrices for local projection estimation.\n\n## Arguments\n- `data` (matrix or table): Input time series dataset.\n- `treatment` (char or int): Treatment variable.\n- `p` (int): Lag length.\n- `horizons` (vector): Forecast horizons.\n- `varargin`: Name-value pairs for options:\n- `includeConstant` (logical): Include constant column in `X`\n(Default is true).\n\n## Returns\n- `X` (matrix): Common regressor matrix for all horizons.\n- `Y` (3D array): Outcome variables stacked over horizons (along\nthe third dimension).\n\n## Notes\n- `X` is structured as [deterministic contemporaneous treatment lagged]\n- `Y` stacks future outcomes across selected horizons along the\nthird dimension.\n- Shape of `Y`: (observations, variables, horizons).\n\n## Details\n- All variables ordered before the treatment in `data` are\nincluded as contemporaneous controls.\n","fitted":"\n`fitted` Return the fitted values from the LP model.\n\n`Yhat = fitted(obj)` returns the fitted values obtained from\nthe local projection regressions.\n\n## Arguments\n- `obj` (LP): LP model object.\n\n## Returns\n- `Yhat` (3D array): Fitted values with dimensions:\n- First dimension: Time.\n- Second dimension: Outcome variable.\n- Third dimension: Horizon.\n\nSee also `residuals`, `coeffs`, `fit`","LP":"\n`LP` Construct a Local Projection (LP) model object.\n\n`obj = LP(data, treatment, p, horizons, varargin)` initializes\nan LP object for estimating impulse response functions.\n\n## Arguments\n- `data` (matrix or table): Input time series dataset.\n- `treatment` (char or int): Treatment variable.\n- `p` (integer): Lag length.\n- `horizons` (vector): Forecast horizons.\n- `varargin`: Name-value pairs for options:\n- `includeConstant` (logical): Include constant in regressors\n(Defaults to true).","transmission":"\n`transmission` Compute transmission effects in an LP model.\n\n`effects = transmission(obj, shock, condition, order, maxHorizon, varargin)`\ncomputes transmission effects for a `shock` satisfying a\n`condition`, based on the ordering `order`, up to `maxHorizon`.\n\n## Arguments\n- `obj` (LP): LP model object.\n- `shock` (integer): Index of the shock variable.\n- `condition` (Q): Transmission condition object.\n- `order` (cell array of char): Variable transmission ordering.\n- `maxHorizon` (integer): Maximum horizon.\n- `varargin`: Name-value pairs for options:\n- `identificationMethod` (optional): Identification method.\n\n## Returns\n- `effects` (3D array): Transmission effects over horizons:\n- First dimension: Endogenous variables (responses).\n- Second dimension: Selected shock.\n- Third dimension: Horizon.\n\n## Notes\n- If `identificationMethod` is provided, the LP model is refitted.\n\nSee also `LP.through`, `LP.notThrough`, `LP.IRF`","isStructural":"","getIndependent":"","getInputData":"","isFitted":"","fit":"\n`fit` Estimate the LP model with an identification method.\n\n`fit(obj, identificationMethod)` estimates the LP model,\nidentifying causal effects with respect to the treatment.\n\n## Arguments\n- `obj` (LP): LP model object.\n- `identificationMethod` (object, optional): Identification\nmethod. Must be of type `IdentificationMethod`. Defaults to\n`Recursive`.\n\nSee also `coeffs`, `fitted`, `residuals`, `Recursive`","coeffs":"\n`coeffs` Return coefficient estimates from LP model.\n\n`B = coeffs(obj, excludeDeterministic)` returns the estimated\ncoefficients from the fitted LP model.\n\n## Arguments\n- `obj` (LP): LP model object.\n- `excludeDeterministic` (logical, optional): If true, excludes\nconstant terms from the coefficients. Defaults to false.\n\n## Returns\n- `B` (3D array): Coefficients array with dimensions:\n- First dimension: Outcome variable.\n- Second dimension: Regressors.\n- Third dimension: Horizon.\n\nSee also `fit`","residuals":"\n`residuals` Return residuals from the LP model.\n\n`U = residuals(obj)` returns the residuals from the local\nprojection regressions.\n\n## Arguments\n- `obj` (LP): LP model object.\n\n## Returns\n- `U` (3D array): Residuals with dimensions:\n- First dimension: Time.\n- Second dimension: Outcome variable.\n- Third dimension: Horizon.\n\nSee also `fitted`, `coeffs`, `fit`","fitAndSelect":"\n`fitAndSelect` Select optimal lag length for LP model.\n\n`[modelBest, icTable] = fitAndSelect(obj, identificationMethod, icFunction)`\nselects the optimal lag length based on an equivalent VAR model.\n\n## Arguments\n- `obj` (LP): LP model object.\n- `identificationMethod` (`IdentificationMethod`, optional):\nIdentification method. Defaults to `Recursive`.\n- `icFunction` (function handle, optional): Information criterion\nfunction to minimize. Defaults to `aic`.\n\n## Returns\n- `modelBest` (LP): Best fitting LP model.\n- `icTable` (table): Table of lag lengths and IC values.\n\n## Notes\n- Maximum lag length considered is the lag length of `obj`.\n\nSee also `fit`, `VAR.fitAndSelect`, `Recursive`","getDependent":"","IRF":"\n`IRF` Compute impulse response functions from LP model.\n\n`irfObj = IRF(obj, maxHorizon, varargin)` computes IRFs up to\n`maxHorizon` based on the LP model.\n\n## Arguments\n- `obj` (LP): LP model object.\n- `maxHorizon` (integer): Maximum forecast horizon.\n- `varargin`: Name-value pairs for options:\n- `identificationMethod` (optional): Identification method.\n\n## Returns\n- `irfObj` (IRFContainer): Container with computed IRFs.\n\n## Notes\n- If `identificationMethod` is provided, LP is refitted first.\n- The IRFs have dimensions `(k x k x (maxHorizon+1))`:\n- First dimension: Responding variables.\n- Second dimension: Shocks.\n- Third dimension: Horizon.\n\nSee also `fit`, `IRFContainer`"},"ExternalInstrument":{"identify":"","identifyLP_":"","ExternalInstrument":"","fit2SLS_":""},"DSGE":{"nobs":"","dynareCellArrayToVec_":"","getVariableNames":"","getShockNames":"\n`getShockNames` returns a vector of shock names.","fitted":"","getShockSize_":"\n`getShockSize_` Obtain the standard deviation of a specified shock.\n\n`shockSize = getShockSize_(shockName, M_)` computes the standard\ndeviation (size) of a specified shock in a DSGE model\nestimated using Dynare.\n\n## Arguments\n- `shockName` (string): The name of the shock whose size and\nindex are required.\n- `M_` (struct): Returned by Dynare.\n\n## Returns\n- `shockSize` (double): The standard deviation of the specified shock.\n","transmission":"\n`transmission` Compute transmission effects in a DSGE model.\n\n`effects = transmission(obj, shock, condition, order, maxHorizon)`\ncomputes the transmission effects for a `shock` under a\n`condition` based on `order`, up to `maxHorizon`.\n\n## Arguments\n- `obj` (DSGE): DSGE model object.\n- `shock` (char or int): Shock name or index.\n- `condition` (Q): Transmission condition object.\n- `order` (cell array or vector): Variable ordering.\n- `maxHorizon` (integer): Maximum forecast horizon.\n\n## Returns\n- `effects` (3D array): Transmission effects over horizons:\n- First dimension: Endogenous variables.\n- Second dimension: Selected shock.\n- Third dimension: Horizon.\n\n## Notes\n- `shock` and `order` can be provided by name or index.\n\nSee also `DSGE.through`, `DSGE.notThrough`","isStructural":"","DSGE":"","checkDynare_":"\n`checkDynare_` Ensure Dynare is properly loaded and available.","getIndependent":"","fit":"","isFitted":"","getVariableIdx_":"","getInputData":"","varmaIrfs_":"\n`varmaIrfs_` Compute structural impulse response functions (IRFs)\nfor a VARMA model.\n\n`irfs = varmaIrfs_(Phi0, As, Psis, horizon)` computes the\nstructural impulse response functions (IRFs) of a VARMA model,\ngiven the structural shock impact matrix, autoregressive (AR)\ncoefficients, and moving average (MA) coefficients.\n\n## Model Specification\nThe VARMA model is defined as:\n$$\ny_t = \\sum_{i=1}^{p} A_i y_{t-i} + \\sum_{j=1}^{q} \\Psi_j u_{t-j} + u_t,\n$$\nwhere:\n- $u_t = \\Phi_0 \\varepsilon_t$, with $\\varepsilon_t$ being\nstructural shocks.\n\n## Arguments\n- `Phi0` (matrix): Impact matrix linking structural shocks to\nreduced-form errors.\n- `As` (cell array): AR coefficient matrices\n`{A_1, A_2, ..., A_p}`.\n- `Psis` (cell array): MA coefficient matrices\n`{Psi_1, Psi_2, ..., Psi_q}`.\n- `horizon` (integer): Number of periods for which IRFs are\ncomputed. `horizon=0` means only contemporaneous impulses are\ncomputed which are the same as `Phi0`.\n\n## Returns\n- `irfs` (3D array): Structural IRFs of size `(n, m, horizon+1)`,\nwhere `n` is the number of endogenous variables, `m` is the\nnumber of shocks, assumed to satisfy `m=n`. The IRFs capture\nthe dynamic response of each variable to a unit shock over\nthe specified horizon.\n","defineOrder_":"\n`defineOrder_` Determine the ordering of observed variables.\n\n`defineOrder_(vars, options_)` returns an ordering vector `order`\nthat maps the variables in `vars` to their corresponding positions\nin the list of observed variables of a DSGE model estimated using\nDynare. It defines the transmission matrix and can be used in\n`makeB`, `makeOmega`, `makeSystemsForm`, `makeConditionY`,\n`notThrough`, `through`, and `transmission`.\n\n## Arguments\n- `vars` (vector): A list of observed variable names.\n- `options_` (struct): Options structure returned by Dynare.\n\n## Returns\n- `order` (vector): Indices of `vars` in the original observed\nvariable list.\n\nSee also `transmission`, `through`, `notThrough`, `makeSystemsForm`.","getShockSize":"\n`getShockSize` Get size (standard deviation) of a structural shock.\n\n`shockSize = getShockSize(obj, shockname)` returns the standard\ndeviation of the specified structural shock.\n\n## Arguments\n- `obj` (DSGE): DSGE model object.\n- `shockname` (char): Name of the structural shock.\n\n## Returns\n- `shockSize` (number): Standard deviation of the shock.\n\nSee also `getVariableIdx`, `getShockIdx`","getVariableIdx":"\n`getVariableIdx` Get index of an observed variable in DSGE model.\n\n`idx = getVariableIdx(obj, varname)` returns the index of\n`varname` in the list of observed variables of a DSGE model.\n\n## Arguments\n- `obj` (DSGE): DSGE model object.\n- `varname` (char): Name of the observed variable.\n\n## Returns\n- `idx` (integer): Index of the observed variable.\n\nSee also `getShockIdx`, `getShockSize`","dynareToVarma_":"\n`dynareToVarma_` Transform a DSGE model into VARMA representation.\n\n`[Phi0, As, Psis, p, q] = dynareToVarma_(M_, oo_, options_, maxKappa)`\nconverts a linearized DSGE model estimated using Dynare into a\nVARMA form, following the method of Morris (2016).\n\n## Arguments\n- `M_` (struct): Model structure returned by Dynare.\n- `oo_` (struct): Output structure returned by Dynare.\n- `options_` (struct): Options structure returned by Dynare.\n- `maxKappa` (integer, optional): Tuning parameter related to\nmaximum AR order via `maxArOrder = maxKappa + 1`. Defaults to 20.\n\n## Returns\n- `Phi0` (matrix): Impact matrix linking shocks to reduced-form errors.\n- `As` (cell array): AR coefficient matrices `{A_1, ..., A_p}`.\n- `Psis` (cell array): MA coefficient matrices `{Psi_1, ..., Psi_q}`.\n- `p` (integer): Determined autoregressive order.\n- `q` (integer): Determined moving average order.\n\n## Methodology\nThe function follows the approach outlined in Morris (2016)\nand returns a VARMA of the form:\n$$\ny_t = \\sum_{i=1}^{p} A_i y_{t-i} + \\sum_{j=1}^{q} \\Psi_j u_{t-j} + u_t,\n$$\nwhere:\n- $u_t = \\Phi_0 \\varepsilon_t$, with $\\varepsilon_t$\nbeing structural shocks.\n\n## Reference\n- Morris, S. D. (2016). \"VARMA representation of DSGE models.\"\n*Economics Letters*, 138, 30â€“33.\n[https://doi.org/10.1016/j.econlet.2015.11.027](https://doi.org/10.1016/j.econlet.2015.11.027)\n\nSee also `getABCD_`, `varmaIrfs_`.","getShockIdx":"\n`getShockIdx` Get index of a structural shock in DSGE model.\n\n`idx = getShockIdx(obj, shockname)` returns the index of\n`shockname` in the list of shocks of a DSGE model.\n\n## Arguments\n- `obj` (DSGE): DSGE model object.\n- `shockname` (char): Name of the structural shock.\n\n## Returns\n- `idx` (integer): Index of the structural shock.\n\nSee also `getVariableIdx`, `getShockSize`","getShockIdx_":"","coeffs":"\n`coeffs` Return VARMA coefficients from the DSGE model.\n\n`[Phi0, As, Psis] = coeffs(obj)` computes and returns the\nVARMA coefficients of the DSGE model.\n\n## Returns\n- `Phi0` (matrix): Contemporaneous impact effects of\nstructural shocks.\n- `As` (cell array): Reduced-form AR coefficient matrices.\n- `Psis` (cell array): Reduced-form MA coefficient matrices.\n\n## Notes\n- Internally calls `dynareToVarma_` to extract VARMA form.\n- The method follows Morris (2016) for VARMA approximation.\n\nSee also `DSGE.dynareToVarma_`","fitAndSelect":"","residuals":"","getABCD_":"\n`getABCD_` Obtain the ABCD state-space representation of a DSGE model.\n\n`[A, B, C, D] = getABCD_(M_, oo_, options_)` computes the state-space\nrepresentation\n$$\n\\begin{split}\nx_t &= Ax_{t-1} + B\\varepsilon_t \\\\\ny_t &= Cx_{t-1} + D\\varepsilon_t\n\\end{split}\nof a DSGE model estimated using Dynare. Only the minimal state\nrepresentation is returned.\n\n## Arguments\n- `M_` (struct): Returned by Dynare.\n- `oo_` (struct): Returned by Dynare.\n- `options_` (struct): Returned by Dynare.\n\n## Returns\n- `A` (matrix): State transition matrix. See above equation.\n- `B` (matrix): Control input matrix capturing exogenous shocks.\nSee above equation.\n- `C` (matrix): Observation matrix mapping state variables to\nobserved variables. See above equation.\n- `D` (matrix): Observation noise matrix. See above equation.\n\n## Notes\n- Requires MATLAB's Control System Toolbox.\n","getDependent":"","IRF":"\n`IRF` Compute impulse response functions for DSGE model.\n\n`irfObj = IRF(obj, maxHorizon)` computes IRFs of the DSGE\nmodel up to horizon `maxHorizon`.\n\n## Arguments\n- `obj` (DSGE): DSGE model object.\n- `maxHorizon` (integer): Maximum forecast horizon.\n\n## Returns\n- `irfObj` (IRFContainer): Container with computed IRFs.\n\n## Notes\n- Uses VARMA representation for IRF computation.\n\nSee also `coeffs`, `dynareToVarma_`, `varmaIrfs_`"},"Recursive":{"identify":"","identifyVAR_":"","identifyVARIrfs_":"","identifyLP_":"","identifyVARTransmission_":"","identifyIrfs":"","identifyTransmission":""},"VAR":{"makeCompanionMatrix_":"\n`makeCompanionMatrix_` Form the companion matrix of a VAR model.\n\n`C = makeCompanionMatrix_(B, p, m)` constructs the companion\nmatrix for a VAR(p) model given its coefficient matrix `B`.\n\n## Arguments\n- `B` (matrix): Coefficient matrix `[C B_1 ... B_p]`, where\n`C` are coefficients on deterministic components and `B_i`\nare lag matrices.\n- `p` (integer): Lag order of the VAR.\n- `m` (integer): Number of deterministic components.\n\n## Returns\n- `C` (matrix): Companion matrix of the VAR(p) system.\n\n## Notes\n- The companion matrix has the structure:\n\n$$\n\\begin{bmatrix}\nB_1 & B_2 & \\cdots & B_p \\\\\nI   & 0   & \\cdots & 0 \\\\\n0   & I   & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0   & 0   & \\cdots & I\n\\end{bmatrix}\n$$","nobs":"","getVariableNames":"","fitted":"\n`fitted` Return the fitted values of the VAR model.\n\n`Yhat = fitted(obj)` returns the matrix of fitted values\nwith size `(T-p) x k`, where `T` is the number of observations\nand `k` is the number of variables.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `Yhat` (matrix): Matrix of fitted values.","sic_":"\n`sic_` Compute Schwarz Information Criterion (SIC/BIC).\n\n`val = sic_(SigmaU, nCoeffs, T)` returns the SIC value given the\nresidual covariance matrix, number of coefficients, and sample size.\n\n## Arguments\n- `SigmaU` (matrix): Covariance matrix of the VAR residuals.\n- `nCoeffs` (integer): Total number of estimated coefficients.\n- `T` (integer): Number of effective observations.\n\n## Returns\n- `val` (number): Computed SIC value.","IRF_":"\n`IRF_` Compute impulse response functions for a VAR model.\n\n`irfs = IRF_(B, p, maxHorizon)` computes impulse response\nfunctions (IRFs) for horizons from 0 to `maxHorizon`, given a\ncoefficient matrix `B`.\n\n## Arguments\n- `B` (matrix): Stacked coefficient matrix `[B_1 ... B_p]`,\nexcluding deterministic components.\n- `p` (integer): Lag order of the VAR.\n- `maxHorizon` (integer): Maximum horizon for IRFs.\n\n## Returns\n- `irfs` (3D array): Impulse responses of size `(k x k x\n(maxHorizon+1))`, where:\n- First dimension: Endogenous variables (responses).\n- Second dimension: Shocks (impulses).\n- Third dimension: Horizon.\n\n## Notes\n- `B` must not include coefficients on deterministic components\n(such as constants or trends).","transmission":"\n`transmission` Compute transmission effects in a VAR model.\n\n`effects = transmission(obj, shock, condition, order, maxHorizon, varargin)`\ncomputes the transmission effects of a `shock` under a\n`condition`, using the transmission matrix defined by `order`,\nup to `maxHorizon`.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n- `shock` (integer): Index of the shock variable.\n- `condition` (Q): Transmission condition object.\n- `order` (cell array of char): Variable transmission ordering.\n- `maxHorizon` (integer): Maximum horizon.\n- `varargin`: Name-value pairs for options:\n- `identificationMethod` (`IdentificationMethod`): Required\nmethod to compute structural IRFs.\n\n## Returns\n- `effects` (3D array): Transmission effects over horizons, where:\n- First dimension: Endogenous variables (responses).\n- Second dimension: Shocks (of size one for the single\nselected shock).\n- Third dimension: Horizon.\n\nSee also `VAR.through`, `VAR.notThrough`","isStructural":"","hqc_":"\n`hqc_` Compute Hannan-Quinn Information Criterion (HQC).\n\n`val = hqc_(SigmaU, nCoeffs, T)` returns the HQC value given the\nresidual covariance matrix, number of coefficients, and sample size.\n\n## Arguments\n- `SigmaU` (matrix): Covariance matrix of the VAR residuals.\n- `nCoeffs` (integer): Total number of estimated coefficients.\n- `T` (integer): Number of effective observations.\n\n## Returns\n- `val` (number): Computed HQC value.","spectralRadius_":"\n`spectralRadius_` Compute the spectral radius of a matrix.\n\n`rho = spectralRadius_(C)` returns the spectral radius of the\ncompanion matrix `C`, defined as the maximum absolute value of\nits eigenvalues.\n\n## Arguments\n- `C` (matrix): Companion matrix of the VAR model.\n\n## Returns\n- `rho` (number): Spectral radius of the companion matrix.\n\nSee also `makeCompanionMatrix_`","sic":"\n`sic` Compute Schwarz Information Criterion (SIC) for VAR model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `val` (number): SIC value.\n\nSee also `aic`, `hqc`, `bic`, `fit`","aic_":"\n`aic_` Compute Akaike Information Criterion (AIC).\n\n`val = aic_(SigmaU, nCoeffs, T)` returns the AIC value given the\nresidual covariance matrix, number of coefficients, and sample size.\n\n## Arguments\n- `SigmaU` (matrix): Covariance matrix of the VAR residuals.\n- `nCoeffs` (integer): Total number of estimated coefficients.\n- `T` (integer): Number of effective observations.\n\n## Returns\n- `val` (number): Computed AIC value.","ncoeffs":"","getIndependent":"","makeCompanionMatrix":"\n`makeCompanionMatrix` Form the companion matrix of the VAR model.\n\n`C = makeCompanionMatrix(obj)` constructs the companion matrix\nfor the fitted VAR(p) model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `C` (matrix): Companion matrix of the VAR(p)","getInputData":"","isFitted":"","fit":"\n`fit` Estimate the VAR model using ordinary least squares (OLS).\n\n## Arguments\n- `obj` (VAR): VAR model object.","VAR":"\n`VAR` Construct a VAR(p) model.\n\n`obj = VAR(data, p, varargin)` creates a VAR with lag\nlength `p` based on the provided dataset.\n\n## Arguments\n- `data` (table or matrix): Input dataset for the VAR model.\n- `p` (integer): Lag order of the VAR.\n- `varargin`: Name-value pairs for optional arguments:\n- `trendExponents` (vector): Exponents for deterministic\ntrends. Defaults to `[0]` (constant term).\n- `B` (matrix): Coefficient matrix. Default is empty (must be\nestimated).\n- `SigmaU` (matrix): Covariance matrix of residuals. Default\nis empty (must be estimated).\n\n## Returns\n- `obj` (VAR): A VAR model.\n\nSee also `fit`, `simulate`","bic":"\n`bic` Compute Bayesian Information Criterion (BIC) for VAR model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `val` (number): BIC value.\n\nSee also `aic`, `hqc`, `sic`, `fit`","ic_":"\n`ic_` Compute a generic information criterion value.\n\n`val = ic_(SigmaU, nCoeffs, ct)` returns the value of an\ninformation criterion based on the log determinant of the\nresidual covariance matrix and a complexity penalty term.\n\n## Arguments\n- `SigmaU` (matrix): Covariance matrix of the VAR residuals.\n- `nCoeffs` (integer): Total number of estimated coefficients.\n- `ct` (number): Complexity term adjusting for sample size.\n\n## Returns\n- `val` (number): Computed information criterion value.","simulate":"\n`simulate` Simulate a VAR process given errors or time periods.\n\n`Y = simulate(errorsOrT, B, varargin)` simulates a VAR model using\neither provided error terms or by generating new errors from\na Normal distribution.\n\n## Arguments\n- `errorsOrT` (matrix or integer): Either a `(k x T)` matrix of\nerror terms or an integer specifying the number of periods `T`\nto simulate.\n- `B` (matrix): Coefficient matrix `[C B_1 ... B_p]` where `p`\nis the lag order.\n- `varargin`: Name-value pairs for optional arguments:\n- `trendExponents` (vector): Exponents for deterministic\ntrends. Default is `[0]` (constant term).\n- `initial` (vector): Initial values for lags, size `(p*k, 1)`.\nDefault is zeros.\n- `SigmaU` (matrix): Covariance matrix for error generation if\nsimulating errors. Default is identity matrix.\n\n## Returns\n- `Y` (matrix): Simulated data matrix, size `(T x k)`.","coeffs":"\n`coeffs` Return the VAR coefficient matrix.\n\n`B = coeffs(obj, excludeDeterministic)` returns the VAR\ncoefficient matrix `[C, B_1, ..., B_p]`. If\n`excludeDeterministic` is true, returns `[B_1, ..., B_p]`\ninstead, excluding deterministic components.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n- `excludeDeterministic` (logical, optional): If true,\nexclude coefficients on deterministic components.\nDefaults to false.\n\n## Returns\n- `B` (matrix): VAR coefficient matrix.","residuals":"\n`residuals` Return the residuals of the VAR model.\n\n`U = residuals(obj)` returns the matrix of VAR residuals\nwith size `(T-p) x k`, where `T` is the number of observations\nand `k` is the number of variables.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `U` (matrix): Matrix of residuals.","fitAndSelect":"\n`fitAndSelect` Estimate and select the best VAR model by IC.\n\n`[modelBest, icTable] = fitAndSelect(obj, icFunction)` fits\nthe VAR model for different lag lengths and selects the one\nminimizing the information criterion. Maximum lag length is\ngiven by the lag length of the provided model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n- `icFunction` (function handle, optional): Information\ncriterion function to minimize. Defaults to `aic`.\n\n## Returns\n- `modelBest` (VAR): Best fitting model.\n- `icTable` (table): Table of lag lengths and IC values.\n\nSee also `fit`, `aic`, `bic`, `hqc`, `sic`","getDependent":"","bic_":"\n`bic_` Compute Bayesian Information Criterion (SIC/BIC).\n\n`val = sic_(SigmaU, nCoeffs, T)` returns the BIC value given the\nresidual covariance matrix, number of coefficients, and sample size.\n\n## Arguments\n- `SigmaU` (matrix): Covariance matrix of the VAR residuals.\n- `nCoeffs` (integer): Total number of estimated coefficients.\n- `T` (integer): Number of effective observations.\n\n## Returns\n- `val` (number): Computed BIC value.\n\n## Notes\n- BIC is the same as SIC.","spectralRadius":"\n`spectralRadius` Compute the spectral radius of the VAR model.\n\n`rho = spectralRadius(obj)` returns the spectral radius of the\ncompanion matrix associated with the fitted VAR model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `rho` (number): Spectral radius of the companion matrix.","aic":"\n`aic` Compute Akaike Information Criterion (AIC) for VAR model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `val` (number): AIC value.\n\nSee also `hqc`, `sic`, `bic`, `fit`","isStable":"\n`isStable` Check if the VAR model is stable.\n\n`flag = isStable(obj)` returns true if the spectral radius of\nthe companion matrix is less than 1.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `flag` (logical): True if the model is stable, false otherwise.","hqc":"\n`hqc` Compute Hannan-Quinn Criterion (HQC) for VAR model.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n\n## Returns\n- `val` (number): HQC value.\n\nSee also `aic`, `sic`, `bic`, `fit`","IRF":"\n`IRF` Compute impulse response functions for the VAR model.\n\n`irfObj = IRF(obj, maxHorizon, varargin)` computes IRFs up to\nhorizon `maxHorizon`. If an `identificationMethod` is provided,\nstructural IRFs are computed.\n\n## Arguments\n- `obj` (VAR): VAR model object.\n- `maxHorizon` (integer): Maximum horizon for IRFs.\n- `varargin`: Name-value pairs for options:\n- `identificationMethod` (an `IdentificationMethod`): Optional\nmethod to compute structural IRFs.\n\n## Returns\n- `irfObj` (IRFContainer): Object containing computed IRFs.\n\n## Notes\n- Without an identification method, reduced-form IRFs are\ncomputed.\n- With an identification method, structural IRFs are computed.\n\nSee also `IRF_`, `IRFContainer`, `fit`, `IdentificationMethod`","coeffsToCellArray_":"\n`coeffsToCellArray_` Transform coefficient matrix into cell array\nof lag matrices.\n\n`BCellArray = coeffsToCellArray_(B)` converts the\ncoefficient matrix `[B_1 B_2 ... B_p]` into a cell array where\neach element corresponds to one lag matrix `B_i`.\n\n## Arguments\n- `B` (matrix): Stacked coefficient matrix excluding\ndeterministic components (i.e., the matrix does not include\nthe constant or trend coefficients `C`). Size is `(k, k*p)`\nwhere `k` is the number of variables and `p` is the lag order.\n\n## Returns\n- `BCellArray` (cell array): A 1-by-`p` cell array where each\ncell contains the `(k x k)` lag coefficient matrix for one lag.\n\n## Notes\n- Assumes that `B` has already been stripped of coefficients on\ndeterministic components.\n"},"IRFContainer":{"getIrfArray":"","plus":"","minus":"","IRFContainer":"","subsref":"","rdivide":"","times":"","disp":""},"IdentificationMethod":{},"Model":{"vars2idx_":"\n`vars2idx_` Map variable names or indices to their corresponding\ncolumn indices.\n\n`vars2idx_(obj, vars)` returns the column indices corresponding\nto the variables specified in `vars`. If `vars` is a numeric\narray, it is returned unchanged. If `vars` is a character or\ncell array of characters, the corresponding column indices in\nthe model data are returned.\n\n## Arguments\n- `obj` (object): Model object that must implement `getVariableNames`.\n- `vars` (integer, char, or cell array of char): Variables\nspecified either by their indices or names.\n\n## Returns\n- `varsIdx` (integer array): Column indices corresponding to\nthe requested variables.\n\n## Notes\n- This function is intended for internal use only.\n- If a variable name does not exist, an error is thrown.\n\nSee also `getVariableNames`.","defineOrder":"\n`defineOrder` Define the transmission ordering of variables in a\nmodel.\n\n`defineOrder(obj, order)` specifies the ordering of variables\nby their names and returns the corresponding indices used\ninternally by the model.\n\n## Arguments\n- `obj` (object): Model object that implements `vars2idx_`.\n- `order` (cell array of char): Ordered list of variable names.\n\n## Returns\n- `orderIdx` (integer array): Ordered indices corresponding\nto the variable names.\n\nSee also `vars2idx_`, `getVariableNames`.","requireFitted":"\n`requireFitted` Ensure that the model has been estimated.\n\n`requireFitted(obj)` checks whether the model `obj` has been fitted.\nIf the model is not fitted, it throws an error of type `NotFitted`.\n\n## Arguments\n- `obj` (object): Model object that should have a method `isFitted`.\n\nSee also `isFitted`.","notThrough":"\n`notThrough` Create a transmission condition excluding specific\nvariables from the channel.\n\n`q = notThrough(obj, vars, horizons, order)` constructs a\ntransmission condition `q` where paths cannot pass through\nspecified variables at given time horizons.\n\n## Arguments\n- `obj` (object): A Model object.\n- `vars` (char or cell array of char): Name(s) of the variables\nthat paths cannot go through.\n- `horizons` (vector or cell array of vectors): Time horizons\nat which the paths cannot pass through the variable(s).\n- `order` (char or cell array of char): Variable ordering defining\nthe transission matrix.\n\n## Returns\n- `q` (Q): A transmission condition that can be used in\n`transmission` to compute the transmission effect.\n\nSee also `through`, `transmission`","through":"\n`through` Create a transmission condition enforcing paths through\nspecific variables.\n\n`q = through(obj, vars, horizons, order)` constructs a\ntransmission condition `q` where paths must pass through\nspecified variables at given time horizons.\n\n## Arguments\n- `obj` (object): A Model object.\n- `vars` (char or cell array of char): Name(s) of the\nvariables that paths must go through.\n- `horizons` (vector or cell array of vectors): Time horizons at\nwhich the paths must pass through the variable(s).\n- `order` (char or cell array of char): Variable ordering defining\nthe transmission matrix.\n\n## Returns\n- `q` (Q): A transmission condition that can be used in\n`transmission` to compute the transmission effect.\n\nSee also `notThrough`, `transmission`."},"InternalInstrument":{"identify":"","identifyVARIrfs_":"","InternalInstrument":"","identifyVARTransmission_":"","identifyIrfs":"","identifyTransmission":""}}