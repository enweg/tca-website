---
title: TransmissionChannelAnalysis.jl
engine: julia
bibliography: "../../references.bib"
---


```{julia}
#| echo: false
#| output: false

using DocUtils
using TransmissionChannelAnalysis
```

The package `TransmissionChannelAnalysis.jl` provides functionns for TCA in Julia. It is to date the most advanced of the packages, allowing for all kinds of transmission channels. However, implementing more advanced trasnmission channels requires the use of more advanced methods within the package. For most users and for most applications, the basic funcionality is sufficient. This basic functionality will be documented first, with some more advanced features discussed later. 

::: {.callout-note}

# Contributer Information

For interested contributers or others interested in the internals of `TransmissionChannelAnalysis.jl` please have a look at the [explanation of the internals](internals.qmd).
:::

## Defining Simple Transmission Channels

Two helper functions are provided that allow for the definition of transmission channels without having to use the more advanced methods. These are `through`{.julia} and `not_throug`{.julia}. As the names hint at, `through`{.julia} is used to define a channel that must go through certain variables in certain periods, while `not_through`{.julia} is used to define a transmission channel that cannot go through certain variables in all defined periods. 


```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(through)
```

```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(not_through)
```

Both `through`{.julia} and `not_through`{.julia} return a transmission condition `Q`, which is simply an internal representation of the provided transmission channel (represented as [Boolean statements](/learn/boolean-conditions.qmd)). To double check whether the condition represents the desired channel, simply run `Q`{.julia} in the REPL, which will display the internal representation using the [systems form](/learn/systems-form.qmd) and thus using the variable notation $x$. Alternatively, `show_y`{.julia} or `@show_y`{.julia} can be used to display the internal representation in the [dynamic form](/learn/dynamic-form.qmd) and thus using the variable notation $y$. 

```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(show_y)
```

### Advanced Usage of `through`{.julia} and `not_through`{.julia}

Conditions created using `through`{.julia} and `not_through`{.julia} can be combined using AND (`&`{.julia}), OR (`|`{.julia}) and NOT (`!`{.julia}). Every new combination will return a new condition that combines the previous conditions. The returned conditions can again be combined using AND, OR, and NOT. For example, if `q1`{.julia}, `q2`{.julia} and `q3`{.julia} are conditions obtained using `through`{.julia} or `not_through`{.julia}, then the following works.


```{julia}
#| eval: false

q1_and_q2 = q1 & q2
q1_and_not_q3 = q1 & !q3
q4 = (q1 | q2) & !q3
q5 = q4 | q1
```

This functionality allows definitions of transmission channels that are not easily defined using `through`{.julia} and `not_through`{.julia}. For example, if we were interested in the transmission channel that goes through $y_{1,0}$ OR through $y_{1,1}$, then neither of the helper functions can be used, since neither can handle OR statements. However, we can use [Boolean logic](/learn/boolean-conditions.qmd) and the [rules for the manipulation of transmission conditions](/learn/algebra.qmd) to define this transmission channel using our helper functions. 

In most cases, the easiest step is to negate the original condition. The above condition can be succintly be represented as 
$$
y_{1,0} \lor y_{1,1}.
$$
The negated statement is thus 
$$
\neg y_{1,0} \land \neg y_{1,1}.
$$
This can be defined using `not_through`{.julia} in the following way 

```{julia}
#| eval: false

q = not_through(1, [0,1], 1:n)
```

where we assumed that the transmission matrix is the identity matrix, implying an ordering `1:n`{.julia}.  

To obtain the original transmission channel, we can simply negate this condition.

```{julia}
#| eval: false

original_condition = !q
```

## Defining Complex Transmission Channels

Although `through`{.julia} and `not_through`{.julia} are sufficient for many situations, it is still sometimes more convenient to directly define the transmission channel as a [Boolean condition](/learn/boolean-conditions.qmd) withough having to refer back to `though`{.julia} and `not_through`{.julia}. 

Say, for example, we are again interested in the transmission channel going through `y_{1,0}` OR `y_{1,1}`. Instead of using the approach of first negating the statement, then using `not_through`{.julia}, just to negate this statement again, we may as well just define the condition directly using the more advanced functionality of `TransmissionChannelAnalysis.jl`. 

The advanced functionality simply takes a `String` that defines the transmission channel as a Boolean condition. The string can either be defined using the variables of the [dynamic form](/learn/dynamic-form.qmd) $y$ or the variables using the [systems form](/learn/systems-form.qmd) $x$. In the former case, the ordering defined by the transmission matrix must also be defined. In either case, `make_condition`{.julia} is used. 

```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(make_condition)
```

So, to define the transmission channel that goes through `y_{1,0}` OR through $y_{1,1}$ with an identity transmission matrix, we can do either of the following. 


```{julia}
#| eval: false

# Note, we assume 4 variables in the system. 
q = make_condition("y_{1,0} | y_{1,1}", 1:4)
# With an identity transmission matrix, y_{1,0} -> x1
# and y_{1,1} -> x5 if the transmission matrix
# is the identity matrix.
q = make_condition("x1 | x5")
```

## Computing Transmission Effects

Transmission effects, i.e. the effect through the transmission channel, can be computed in one of two ways in `TransmissionChannelAnalysis.jl`. The first way is to use the [systems form](/learn/systems-form.qmd) to compute the transmission effect. The second way exploits the sufficiency of impulse response functions (IRFs)[^1] and uses these to compute the effects. The following sections describe both methods. 

[^1]: See Section 4 in @wegnerTCA2024.

### Using the Systems Form

```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(make_systems_form)
```

### Using IRFs


### Computing

```{julia}
#| echo: false
#| output: asis

include_quarto_callout_doc(transmission)
```

